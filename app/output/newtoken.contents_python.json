[
    {
        "path": "token.routing.yml",
        "contents": "token.tree:\n  path: '/token/tree'\n  defaults:\n    _controller: '\\Drupal\\token\\Controller\\TokenTreeController::outputTree'\n  requirements:\n    _csrf_token: 'TRUE'\n\ntoken.flush_cache:\n  path: '/token/flush-cache'\n  defaults:\n    _controller: '\\Drupal\\token\\Controller\\TokenCacheController::flush'\n  requirements:\n    _permission: 'flush caches'\n    _csrf_token: 'TRUE'\n    _module_dependencies: 'admin_menu'\n"
    },
    {
        "path": "token.drush.inc",
        "contents": "<?php\n\n/**\n * @file\n * Drush integration for the Token module.\n */\n\n/**\n * Implements hook_drush_cache_clear().\n */\nfunction token_drush_cache_clear(&$types) {\n  $types['token'] = 'drush_token_cache_clear_token_info';\n}\n\n/**\n * Clear caches internal to Token module.\n */\nfunction drush_token_cache_clear_token_info() {\n  token_clear_cache();\n}\n"
    },
    {
        "path": "token.module",
        "contents": "<?php\n\n/**\n * @file\n * Enhances the token API in core: adds a browseable UI, missing tokens, etc.\n */\n\nuse Drupal\\Component\\Render\\PlainTextOutput;\nuse Drupal\\Core\\Block\\BlockPluginInterface;\nuse Drupal\\Core\\Entity\\EntityTypeInterface;\nuse Drupal\\Core\\Field\\BaseFieldDefinition;\nuse Drupal\\Core\\Form\\FormStateInterface;\nuse Drupal\\Core\\Menu\\MenuLinkInterface;\nuse Drupal\\Core\\Render\\BubbleableMetadata;\nuse Drupal\\Core\\Render\\Element;\nuse Drupal\\Core\\Routing\\RouteMatchInterface;\nuse Drupal\\menu_link_content\\Entity\\MenuLinkContent;\nuse Drupal\\menu_link_content\\MenuLinkContentInterface;\nuse Drupal\\node\\Entity\\Node;\nuse Drupal\\node\\NodeInterface;\n\n/**\n * Implements hook_help().\n */\nfunction token_help($route_name, RouteMatchInterface $route_match) {\n  if ($route_name == 'help.page.token') {\n    $token_tree = \\Drupal::service('token.tree_builder')->buildAllRenderable([\n      'click_insert' => FALSE,\n      'show_restricted' => TRUE,\n      'show_nested' => FALSE,\n    ]);\n    $output = '<h3>' . t('About') . '</h3>';\n    $output .= '<p>' . t('The <a href=\":project\">Token</a> module provides a user interface for the site token system. It also adds some additional tokens that are used extensively during site development. Tokens are specially formatted chunks of text that serve as placeholders for a dynamically generated value. For more information, covering both the token system and the additional tools provided by the Token module, see the <a href=\":online\">online documentation</a>.', [':online' => 'https://www.drupal.org/documentation/modules/token', ':project' => 'https://www.drupal.org/project/token']) . '</p>';\n    $output .= '<h3>' . t('Uses') . '</h3>';\n    $output .= '<p>' . t('Your website uses a shared token system for exposing and using placeholder tokens and their appropriate replacement values. This allows for any module to provide placeholder tokens for strings without having to reinvent the wheel. It also ensures consistency in the syntax used for tokens, making the system as a whole easier for end users to use.') . '</p>';\n    $output .= '<dl>';\n    $output .= '<dt>' . t('The list of the currently available tokens on this site are shown below.') . '</dt>';\n    $output .= '<dd>' . \\Drupal::service('renderer')->render($token_tree) . '</dd>';\n    $output .= '</dl>';\n    return $output;\n  }\n}\n\n/**\n * Return an array of the core modules supported by token.module.\n */\nfunction _token_core_supported_modules() {\n  return ['book', 'field', 'menu_ui'];\n}\n\n/**\n * Implements hook_theme().\n */\nfunction token_theme() {\n  $info['token_tree_link'] = [\n    'variables' => [\n      'token_types' => [],\n      'global_types' => TRUE,\n      'click_insert' => TRUE,\n      'show_restricted' => FALSE,\n      'show_nested' => FALSE,\n      'recursion_limit' => 3,\n      'text' => NULL,\n      'options' => [],\n    ],\n    'file' => 'token.pages.inc',\n  ];\n\n  return $info;\n}\n\n/**\n * Implements hook_block_view_alter().\n */\nfunction token_block_view_alter(&$build, BlockPluginInterface $block) {\n  if (isset($build['#configuration'])) {\n    $label = $build['#configuration']['label'];\n    if ($label != '<none>') {\n      // The label is automatically escaped, avoid escaping it twice.\n      // @todo https://www.drupal.org/node/2580723 will add a method or option\n      //   to the token API to do this, use that when available.\n      $bubbleable_metadata = BubbleableMetadata::createFromRenderArray($build);\n      $build['#configuration']['label'] = PlainTextOutput::renderFromHtml(\\Drupal::token()->replace($label, [], [], $bubbleable_metadata));\n      $bubbleable_metadata->applyTo($build);\n    }\n  }\n}\n\n/**\n * Implements hook_form_FORM_ID_alter().\n */\nfunction token_form_block_form_alter(&$form, FormStateInterface $form_state) {\n  $token_tree = [\n    '#theme' => 'token_tree_link',\n    '#token_types' => [],\n  ];\n  $rendered_token_tree = \\Drupal::service('renderer')->render($token_tree);\n  $form['settings']['label']['#description'] = t('This field supports tokens. @browse_tokens_link', [\n    '@browse_tokens_link' => $rendered_token_tree,\n  ]);\n  $form['settings']['label']['#element_validate'][] = 'token_element_validate';\n  $form['settings']['label'] += ['#token_types' => []];\n}\n\n/**\n * Implements hook_field_info_alter().\n */\nfunction token_field_info_alter(&$info) {\n  $defaults = [\n    'taxonomy_term_reference' => 'taxonomy_term_reference_plain',\n    'number_integer' => 'number_unformatted',\n    'number_decimal' => 'number_unformatted',\n    'number_float' => 'number_unformatted',\n    'file' => 'file_url_plain',\n    'image' => 'file_url_plain',\n    'text' => 'text_default',\n    'text_long' => 'text_default',\n    'text_with_summary' => 'text_default',\n    'list_integer' => 'list_default',\n    'list_float' => 'list_default',\n    'list_string' => 'list_default',\n    'list_boolean' => 'list_default',\n  ];\n  foreach ($defaults as $field_type => $default_token_formatter) {\n    if (isset($info[$field_type])) {\n      $info[$field_type] += ['default_token_formatter' => $default_token_formatter];\n    }\n  }\n}\n\n/**\n * Implements hook_ENTITY_TYPE_insert().\n */\nfunction token_date_format_insert() {\n  token_clear_cache();\n}\n\n/**\n * Implements hook_ENTITY_TYPE_delete().\n */\nfunction token_date_format_delete() {\n  token_clear_cache();\n}\n\n/**\n * Implements hook_ENTITY_TYPE_presave().\n */\nfunction token_field_config_presave($instance) {\n  token_clear_cache();\n}\n\n/**\n * Implements hook_ENTITY_TYPE_delete().\n */\nfunction token_field_config_delete($instance) {\n  token_clear_cache();\n}\n\n/**\n * Clear token caches and static variables.\n */\nfunction token_clear_cache() {\n  \\Drupal::token()->resetInfo();\n  \\Drupal::service('token.entity_mapper')->resetInfo();\n  drupal_static_reset('token_menu_link_load_all_parents');\n  drupal_static_reset('token_book_link_load');\n}\n\n/**\n * Implements hook_entity_type_alter().\n *\n * Because some token types to do not match their entity type names, we have to\n * map them to the proper type. This is purely for other modules' benefit.\n *\n * @see \\Drupal\\token\\TokenEntityMapperInterface::getEntityTypeMappings()\n * @see http://drupal.org/node/737726\n */\nfunction token_entity_type_alter(array &$entity_types) {\n  $devel_exists = \\Drupal::moduleHandler()->moduleExists('devel');\n  /* @var $entity_types EntityTypeInterface[] */\n  foreach ($entity_types as $entity_type_id => $entity_type) {\n    if (!$entity_type->get('token_type')) {\n      // Fill in default token types for entities.\n      switch ($entity_type_id) {\n        case 'taxonomy_term':\n        case 'taxonomy_vocabulary':\n          // Stupid taxonomy token types...\n          $entity_type->set('token_type', str_replace('taxonomy_', '', $entity_type_id));\n          break;\n\n        default:\n          // By default the token type is the same as the entity type.\n          $entity_type->set('token_type', $entity_type_id);\n          break;\n      }\n    }\n\n    if ($devel_exists\n      && $entity_type->hasViewBuilderClass()\n      && !$entity_type->hasLinkTemplate('token-devel')) {\n      $entity_type->setLinkTemplate('token-devel', \"/devel/token/$entity_type_id/{{$entity_type_id}}\");\n    }\n  }\n}\n\n/**\n * Return the module responsible for a token.\n *\n * @param string $type\n *   The token type.\n * @param string $name\n *   The token name.\n *\n * @return mixed\n *   The value of $info['tokens'][$type][$name]['module'] from token info, or\n *   NULL if the value does not exist.\n *\n * @deprecated in token:8.x-1.x and is removed from token:2.0.0. Use the\n *   token.module_provider service instead.\n */\nfunction _token_module($type, $name) {\n  return \\Drupal::service('token.module_provider')->getTokenModule($type, $name);\n}\n\n/**\n * Validate a form element that should have tokens in it.\n *\n * Form elements that want to add this validation should have the #token_types\n * parameter defined.\n *\n * For example:\n * @code\n * $form['my_node_text_element'] = [\n *   '#type' => 'textfield',\n *   '#title' => t('Some text to token-ize that has a node context.'),\n *   '#default_value' => 'The title of this node is [node:title].',\n *   '#element_validate' => ['token_element_validate'],\n *   '#token_types' => ['node'],\n *   '#min_tokens' => 1,\n *   '#max_tokens' => 10,\n * ];\n * @endcode\n */\nfunction token_element_validate($element, FormStateInterface $form_state) {\n  $value = isset($element['#value']) ? $element['#value'] : $element['#default_value'];\n\n  if (empty($value)) {\n    // Empty value needs no further validation since the element should depend\n    // on using the '#required' FAPI property.\n    return $element;\n  }\n\n  $tokens = \\Drupal::token()->scan($value);\n  $title = empty($element['#title']) ? $element['#parents'][0] : $element['#title'];\n\n  // Validate if an element must have a minimum number of tokens.\n  if (isset($element['#min_tokens']) && count($tokens) < $element['#min_tokens']) {\n    $error = \\Drupal::translation()->formatPlural($element['#min_tokens'], '%name must contain at least one token.', '%name must contain at least @count tokens.', ['%name' => $title]);\n    $form_state->setError($element, $error);\n  }\n\n  // Validate if an element must have a maximum number of tokens.\n  if (isset($element['#max_tokens']) && count($tokens) > $element['#max_tokens']) {\n    $error = \\Drupal::translation()->formatPlural($element['#max_tokens'], '%name must contain at most one token.', '%name must contain at most @count tokens.', ['%name' => $title]);\n    $form_state->setError($element, $error);\n  }\n\n  // Check if the field defines specific token types.\n  if (isset($element['#token_types'])) {\n    $invalid_tokens = \\Drupal::token()->getInvalidTokensByContext($tokens, $element['#token_types']);\n    if ($invalid_tokens) {\n      $form_state->setError($element, t('%name is using the following invalid tokens: @invalid-tokens.', ['%name' => $title, '@invalid-tokens' => implode(', ', $invalid_tokens)]));\n    }\n  }\n\n  return $element;\n}\n\n/**\n * Implements hook_form_FORM_ID_alter().\n */\nfunction token_form_field_config_edit_form_alter(&$form, FormStateInterface $form_state) {\n  $field_config = $form_state->getFormObject()->getEntity();\n  $field_storage = $field_config->getFieldStorageDefinition();\n  if ($field_storage->isLocked()) {\n    return;\n  }\n  $field_type = $field_storage->getType();\n  if (($field_type == 'file' || $field_type == 'image') && isset($form['settings']['file_directory'])) {\n    // GAH! We can only support global tokens in the upload file directory path.\n    $form['settings']['file_directory']['#element_validate'][] = 'token_element_validate';\n    // Date support needs to be implicitly added, as while technically it's not\n    // a global token, it is a not only used but is the default value.\n    // https://www.drupal.org/node/2642160\n    $form['settings']['file_directory'] += ['#token_types' => ['date']];\n    $form['settings']['file_directory']['#description'] .= ' ' . t('This field supports tokens.');\n  }\n\n  // Note that the description is tokenized via token_field_widget_form_alter().\n  $form['description']['#element_validate'][] = 'token_element_validate';\n  $form['description'] += ['#token_types' => []];\n\n  $form['token_tree'] = [\n    '#theme' => 'token_tree_link',\n    '#token_types' => [],\n    '#weight' => $form['description']['#weight'] + 0.5,\n  ];\n}\n\n/**\n * Implements hook_form_BASE_FORM_ID_alter().\n *\n * Alters the configure action form to add token context validation and\n * adds the token tree for a better token UI and selection.\n */\nfunction token_form_action_form_alter(&$form, $form_state) {\n  if (isset($form['plugin'])) {\n    switch ($form['plugin']['#value']) {\n      case 'action_message_action':\n      case 'action_send_email_action':\n      case 'action_goto_action':\n        $form['token_tree'] = [\n          '#theme' => 'token_tree_link',\n          '#token_types' => 'all',\n          '#weight' => 100,\n        ];\n        $form['actions']['#weight'] = 101;\n        // @todo Add token validation to the action fields that can use tokens.\n        break;\n    }\n  }\n}\n\n/**\n * Implements hook_form_FORM_ID_alter().\n *\n * Alters the user e-mail fields to add token context validation and\n * adds the token tree for a better token UI and selection.\n */\nfunction token_form_user_admin_settings_alter(&$form, FormStateInterface $form_state) {\n  $email_token_help = t('Available variables are: [site:name], [site:url], [user:display-name], [user:account-name], [user:mail], [site:login-url], [site:url-brief], [user:edit-url], [user:one-time-login-url], [user:cancel-url].');\n\n  foreach (Element::children($form) as $key) {\n    $element = &$form[$key];\n\n    // Remove the crummy default token help text.\n    if (!empty($element['#description'])) {\n      $element['#description'] = trim(str_replace($email_token_help, t('The list of available tokens that can be used in e-mails is provided below.'), $element['#description']));\n    }\n\n    switch ($key) {\n      case 'email_admin_created':\n      case 'email_pending_approval':\n      case 'email_no_approval_required':\n      case 'email_password_reset':\n      case 'email_cancel_confirm':\n        // Do nothing, but allow execution to continue.\n        break;\n\n      case 'email_activated':\n      case 'email_blocked':\n      case 'email_canceled':\n        // These fieldsets have their e-mail elements inside a 'settings'\n        // sub-element, so switch to that element instead.\n        $element = &$form[$key]['settings'];\n        break;\n\n      default:\n        continue 2;\n    }\n\n    foreach (Element::children($element) as $sub_key) {\n      if (!isset($element[$sub_key]['#type'])) {\n        continue;\n      }\n      elseif ($element[$sub_key]['#type'] == 'textfield' && substr($sub_key, -8) === '_subject') {\n        // Add validation to subject textfields.\n        $element[$sub_key]['#element_validate'][] = 'token_element_validate';\n        $element[$sub_key] += ['#token_types' => ['user']];\n      }\n      elseif ($element[$sub_key]['#type'] == 'textarea' && substr($sub_key, -5) === '_body') {\n        // Add validation to body textareas.\n        $element[$sub_key]['#element_validate'][] = 'token_element_validate';\n        $element[$sub_key] += ['#token_types' => ['user']];\n      }\n    }\n  }\n\n  // Add the token tree UI.\n  $form['email']['token_tree'] = [\n    '#theme' => 'token_tree_link',\n    '#token_types' => ['user'],\n    '#show_restricted' => TRUE,\n    '#show_nested' => FALSE,\n    '#weight' => 90,\n  ];\n}\n\n/**\n * Prepare a string for use as a valid token name.\n *\n * @param $name\n *   The token name to clean.\n * @return\n *   The cleaned token name.\n */\nfunction token_clean_token_name($name) {\n  static $names = [];\n\n  if (!isset($names[$name])) {\n    $cleaned_name = strtr($name, [' ' => '-', '_' => '-', '/' => '-', '[' => '-', ']' => '']);\n    $cleaned_name = preg_replace('/[^\\w\\-]/i', '', $cleaned_name);\n    $cleaned_name = trim($cleaned_name, '-');\n    $names[$name] = $cleaned_name;\n  }\n\n  return $names[$name];\n}\n\n/**\n * Do not use this function yet. Its API has not been finalized.\n */\nfunction token_render_array(array $array, array $options = []) {\n  $rendered = [];\n\n  /** @var \\Drupal\\Core\\Render\\RendererInterface $renderer */\n  $renderer = \\Drupal::service('renderer');\n\n  foreach (token_element_children($array) as $key) {\n    $value = $array[$key];\n    $rendered[] = is_array($value) ? $renderer->renderPlain($value) : (string) $value;\n  }\n  $join = isset($options['join']) ? $options['join'] : ', ';\n  return implode($join, $rendered);\n}\n\n/**\n * Do not use this function yet. Its API has not been finalized.\n */\nfunction token_render_array_value($value, array $options = []) {\n  /** @var \\Drupal\\Core\\Render\\RendererInterface $renderer */\n  $renderer = \\Drupal::service('renderer');\n\n  $rendered = is_array($value) ? $renderer->renderPlain($value) : (string) $value;\n  return $rendered;\n}\n\n/**\n * Coyp of drupal_render_cache_set() that does not care about request method.\n */\nfunction token_render_cache_set(&$markup, $elements) {\n  // This should only run of drupal_render_cache_set() did not.\n  if (in_array(\\Drupal::request()->server->get('REQUEST_METHOD'), ['GET', 'HEAD'])) {\n    return FALSE;\n  }\n\n  $original_method = \\Drupal::request()->server->get('REQUEST_METHOD');\n  \\Drupal::request()->server->set('REQUEST_METHOD', 'GET');\n  drupal_render_cache_set($markup, $elements);\n  \\Drupal::request()->server->set('REQUEST_METHOD', $original_method);\n}\n\n/**\n * Loads menu link titles for all purents of a menu link plugin ID.\n *\n * @param string $plugin_id\n *   The menu link plugin ID.\n * @param string $langcode\n *   The language code.\n *\n * @return string[]\n *   List of menu link parent titles.\n */\nfunction token_menu_link_load_all_parents($plugin_id, $langcode) {\n  $cache = &drupal_static(__FUNCTION__, []);\n\n  if (!isset($cache[$plugin_id][$langcode])) {\n    $cache[$plugin_id][$langcode] = [];\n    /** @var \\Drupal\\Core\\Menu\\MenuLinkManagerInterface $menu_link_manager */\n    $menu_link_manager = \\Drupal::service('plugin.manager.menu.link');\n    $parent_ids = $menu_link_manager->getParentIds($plugin_id);\n    // Remove the current plugin ID from the parents.\n    unset($parent_ids[$plugin_id]);\n    foreach ($parent_ids as $parent_id) {\n      $parent = $menu_link_manager->createInstance($parent_id);\n      $cache[$plugin_id][$langcode] = [$parent_id => token_menu_link_translated_title($parent, $langcode)] + $cache[$plugin_id][$langcode];\n    }\n  }\n\n  return $cache[$plugin_id][$langcode];\n}\n\n/**\n * Returns the translated link of a menu title.\n *\n * If the underlying entity is a content menu item, load it to get the\n * translated menu item title.\n *\n * @todo Remove this when there is a better way to get a translated menu\n *   item title in core: https://www.drupal.org/node/2795143\n *\n * @param \\Drupal\\Core\\Menu\\MenuLinkInterface $menu_link\n *   The menu link.\n * @param string|null $langcode\n *   (optional) The langcode, defaults to the current language.\n *\n * @return string\n *   The menu link title.\n */\nfunction token_menu_link_translated_title(MenuLinkInterface $menu_link, $langcode = NULL) {\n  $metadata = $menu_link->getMetaData();\n  if (isset($metadata['entity_id']) && $menu_link->getProvider() == 'menu_link_content') {\n    /** @var \\Drupal\\menu_link_content\\MenuLinkContentInterface $entity */\n    $entity = \\Drupal::entityTypeManager()->getStorage('menu_link_content')->load($metadata['entity_id']);\n    if (!empty($entity)) {\n      $entity = \\Drupal::service('entity.repository')->getTranslationFromContext($entity, $langcode);\n      return $entity->getTitle();\n    }\n  }\n  return $menu_link->getTitle();\n}\n\n/**\n * Loads all the parents of the term in the specified language.\n *\n * @param int $tid\n *   The term id.\n * @param string $langcode\n *   The language code.\n *\n * @return string[]\n *   The term parents collection.\n */\nfunction token_taxonomy_term_load_all_parents($tid, $langcode) {\n  $cache = &drupal_static(__FUNCTION__, []);\n\n  if (!is_numeric($tid)) {\n    return [];\n  }\n\n  if (!isset($cache[$langcode][$tid])) {\n    $cache[$langcode][$tid] = [];\n    /** @var \\Drupal\\taxonomy\\TermStorageInterface $term_storage */\n    $term_storage = \\Drupal::entityTypeManager()->getStorage('taxonomy_term');\n    $parents = $term_storage->loadAllParents($tid);\n    // Remove this term from the array.\n    array_shift($parents);\n    $parents = array_reverse($parents);\n    foreach ($parents as $term) {\n      $translation = \\Drupal::service('entity.repository')->getTranslationFromContext($term, $langcode);\n      $cache[$langcode][$tid][$term->id()] = $translation->label();\n    }\n  }\n\n  return $cache[$langcode][$tid];\n}\n\nfunction token_element_children(&$elements, $sort = FALSE) {\n  // Do not attempt to sort elements which have already been sorted.\n  $sort = isset($elements['#sorted']) ? !$elements['#sorted'] : $sort;\n\n  // Filter out properties from the element, leaving only children.\n  $children = [];\n  $sortable = FALSE;\n  foreach ($elements as $key => $value) {\n    if (is_int($key) || $key === '' || $key[0] !== '#') {\n      $children[$key] = $value;\n      if (is_array($value) && isset($value['#weight'])) {\n        $sortable = TRUE;\n      }\n    }\n  }\n  // Sort the children if necessary.\n  if ($sort && $sortable) {\n    uasort($children, 'Drupal\\Component\\Utility\\SortArray::sortByWeightProperty');\n    // Put the sorted children back into $elements in the correct order, to\n    // preserve sorting if the same element is passed through\n    // element_children() twice.\n    foreach ($children as $key => $child) {\n      unset($elements[$key]);\n      $elements[$key] = $child;\n    }\n    $elements['#sorted'] = TRUE;\n  }\n\n  return array_keys($children);\n}\n\n/**\n * Loads all the parents of the book page.\n *\n * @param array $book\n *   The book data. The 'nid' key points to the current page of the book.\n *   The 'p1' ... 'p9' keys point to parents of the page, if they exist, with 'p1'\n *   pointing to the book itself and the last defined pX to the current page.\n *\n * @return string[]\n *   List of node titles of the book parents.\n */\nfunction token_book_load_all_parents(array $book) {\n  $cache = &drupal_static(__FUNCTION__, []);\n\n  if (empty($book['nid'])) {\n    return [];\n  }\n  $nid = $book['nid'];\n\n  if (!isset($cache[$nid])) {\n    $cache[$nid] = [];\n    $i = 1;\n    while ($book[\"p$i\"] != $nid) {\n      $cache[$nid][] = Node::load($book[\"p$i\"])->getTitle();\n      $i++;\n    }\n  }\n\n  return $cache[$nid];\n}\n\n/**\n * Implements hook_entity_base_field_info().\n */\nfunction token_entity_base_field_info(EntityTypeInterface $entity_type) {\n  // We add a pseudo entity-reference field to track the menu entry created\n  // from the node add/edit form so that tokens generated at that time that\n  // reference the menu link can access the yet to be saved menu link.\n  // @todo Revisit when https://www.drupal.org/node/2315773 is resolved.\n  if ($entity_type->id() === 'node' && \\Drupal::moduleHandler()->moduleExists('menu_ui')) {\n    $fields['menu_link'] = BaseFieldDefinition::create('entity_reference')\n      ->setLabel(t('Menu link'))\n      ->setDescription(t('Computed menu link for the node (only available during node saving).'))\n      ->setRevisionable(TRUE)\n      ->setSetting('target_type', 'menu_link_content')\n      ->setClass('\\Drupal\\token\\MenuLinkFieldItemList')\n      ->setTranslatable(TRUE)\n      ->setInternal(TRUE)\n      ->setDisplayOptions('view', [\n        'label' => 'hidden',\n        'region' => 'hidden',\n      ])\n      ->setComputed(TRUE)\n      ->setDisplayOptions('form', [\n        'region' => 'hidden',\n      ]);\n\n    return $fields;\n  }\n  return [];\n}\n\n/**\n * Implements hook_form_BASE_FORM_ID_alter() for node_form.\n *\n * Populates menu_link field on nodes from the menu item on unsaved nodes.\n *\n * @see menu_ui_form_node_form_submit()\n * @see token_entity_base_field_info()\n */\nfunction token_form_node_form_alter(&$form, FormStateInterface $form_state) {\n  if (!\\Drupal::moduleHandler()->moduleExists('menu_ui')) {\n    return;\n  }\n  $form['#entity_builders'][] = 'token_node_menu_link_submit';\n}\n\n/**\n * Entity builder.\n */\nfunction token_node_menu_link_submit($entity_type, NodeInterface $node, &$form, FormStateInterface $form_state) {\n  // Entity builders run twice, once during validation and again during\n  // submission, so we only run this code after validation has been performed.\n  if (!$form_state->isValueEmpty('menu') && $form_state->getTemporaryValue('entity_validated')) {\n\n    // Don't create a menu link if the node is not being saved.\n    $triggering_element = $form_state->getTriggeringElement();\n    if (!$triggering_element || !isset($triggering_element['#submit']) || !in_array('::save', $triggering_element['#submit'])) {\n      return;\n    }\n\n    $values = $form_state->getValue('menu');\n    if (!empty($values['enabled']) && trim($values['title'])) {\n      if (!empty($values['menu_parent'])) {\n        [$menu_name, $parent] = explode(':', $values['menu_parent'], 2);\n        $values['menu_name'] = $menu_name;\n        $values['parent'] = $parent;\n      }\n      // Construct an unsaved entity.\n      if ($entity_id = $form_state->getValue(['menu', 'entity_id'])) {\n        // Use the existing menu_link_content entity.\n        $entity = MenuLinkContent::load($entity_id);\n        // If the loaded MenuLinkContent doesn't have a translation for the\n        // Node's active langcode, create a new translation.\n        if ($entity->isTranslatable()) {\n          if (!$entity->hasTranslation($node->language()->getId())) {\n            $entity = $entity->addTranslation($node->language()->getId(), $entity->toArray());\n          }\n          else {\n            $entity = $entity->getTranslation($node->language()->getId());\n          }\n        }\n      }\n      else {\n        if ($node->isNew()) {\n          // Create a new menu_link_content entity.\n          $entity = MenuLinkContent::create([\n            // Lets just reference the UUID for now, the link is not important for\n            // token generation.\n            'link' => ['uri' => 'internal:/node/' . $node->uuid()],\n            'langcode' => $node->language()->getId(),\n          ]);\n        }\n        else {\n          // Create a new menu_link_content entity.\n          $entity = MenuLinkContent::create([\n            'link' => ['uri' => 'entity:node/' . $node->id()],\n            'langcode' => $node->language()->getId(),\n          ]);\n        }\n      }\n      $entity->title->value = trim($values['title']);\n      $entity->description->value = trim($values['description'] ?? '');\n      $entity->menu_name->value = $values['menu_name'];\n      $entity->parent->value = $values['parent'];\n      $entity->weight->value = isset($values['weight']) ? $values['weight'] : 0;\n      $entity->isDefaultRevision($node->isDefaultRevision());\n      $entity->save();\n      $node->menu_link = $entity;\n      // Leave this for _menu_ui_node_save() to pick up so we don't end up with\n      // duplicate menu-links.\n      $form_state->setValue(['menu', 'entity_id'], $entity->id());\n    }\n  }\n}\n\n/**\n * Implements hook_ENTITY_TYPE_insert for node entities.\n */\nfunction token_node_insert(NodeInterface $node) {\n  if ($node->hasField('menu_link') && $menu_link = $node->menu_link->entity) {\n    // Update the menu-link to point to the now saved node.\n    $menu_link->link = 'entity:node/' . $node->id();\n    $menu_link->save();\n  }\n}\n\n/**\n * Implements hook_ENTITY_TYPE_presave() for menu_link_content.\n */\nfunction token_menu_link_content_presave(MenuLinkContentInterface $menu_link_content) {\n  drupal_static_reset('token_menu_link_load_all_parents');\n}\n"
    },
    {
        "path": "token.install",
        "contents": "<?php\n\n/**\n * @file\n * Install, update and uninstall functions for the token module.\n */\n\n/**\n * Implements hook_requirements().\n */\nfunction token_requirements($phase = 'runtime') {\n  $requirements = [];\n\n  if ($phase == 'runtime') {\n    // Check for various token definition problems.\n    $token_problems = token_get_token_problems();\n    // Format and display each token problem.\n    foreach ($token_problems as $problem_key => $problem) {\n      if (!empty($problem['problems'])) {\n        $problems = array_unique($problem['problems']);\n\n        $build = [\n          '#theme' => 'item_list',\n          '#items' => $problems,\n        ];\n\n        $requirements['token-' . $problem_key] = [\n          'title' => $problem['label'],\n          'value' => \\Drupal::service('renderer')->renderPlain($build),\n          'severity' => $problem['severity'],\n        ];\n      }\n    }\n  }\n\n  return $requirements;\n}\n\n/**\n * Implements hook_install().\n */\nfunction token_install() {\n  // Create a token view mode for each entity type.\n  $info = \\Drupal::entityTypeManager()->getDefinitions();\n  foreach ($info as $entity_type => $entity_type_info) {\n    // We're only interested in entity types with a view builder.\n    if (!$entity_type_info->getViewBuilderClass()) {\n      continue;\n    }\n    // Try to find a token view mode for that entity type.\n    $storage = \\Drupal::entityTypeManager()->getStorage('entity_view_mode');\n    // Add a token view mode if it does not already exist.\n    if (!$storage->load(\"$entity_type.token\")) {\n      $storage->create([\n        'targetEntityType' => $entity_type,\n        'id' => \"$entity_type.token\",\n        'status' => TRUE,\n        'label' => t('Token'),\n      ])->save();\n    }\n  }\n}\n\n/**\n * Get token problems.\n */\nfunction token_get_token_problems() {\n  // @todo Improve the duplicate checking to report which modules are the offenders.\n  //$token_info = [];\n  //foreach (module_implements('token_info') as $module) {\n  //  $module_token_info = module_invoke($module, 'token_info');\n  //  if (in_array($module, _token_core_supported_modules())) {\n  //    $module .= '/token';\n  //  }\n  //  if (isset($module_token_info['types'])) {\n  //    if (is_array($module_token_info['types'])) {\n  //      foreach (array_keys($module_token_info['types']) as $type) {\n  //        if (is_array($module_token_info['types'][$type])) {\n  //          $module_token_info['types'][$type] += ['module' => $module];\n  //        }\n  //      }\n  //    }\n  //  }\n  //  if (isset($module_token_info['tokens'])) {\n  //    if (is_array($module_token_info['tokens'])) {\n  //\n  //    }\n  //  }\n  //  if (is_array($module_token_info)) {\n  //    $token_info = array_merge_recursive($token_info, $module_token_info);\n  //  }\n  //}\n\n  $token_info = \\Drupal::token()->getInfo();\n  $token_problems = [\n    'not-array' => [\n      'label' => t('Tokens or token types not defined as arrays'),\n      'severity' => REQUIREMENT_ERROR,\n    ],\n    'missing-info' => [\n      'label' => t('Tokens or token types missing name property'),\n      'severity' => REQUIREMENT_WARNING,\n    ],\n    'type-no-tokens' => [\n      'label' => t('Token types do not have any tokens defined'),\n      'severity' => REQUIREMENT_INFO,\n    ],\n    'tokens-no-type' => [\n      'label' => t('Token types are not defined but have tokens'),\n      'severity' => REQUIREMENT_INFO,\n    ],\n    'duplicate' => [\n      'label' => t('Token or token types are defined by multiple modules'),\n      'severity' => REQUIREMENT_ERROR,\n    ],\n  ];\n\n  // Check token types for problems.\n  foreach ($token_info['types'] as $type => $type_info) {\n    $real_type = !empty($type_info['type']) ? $type_info['type'] : $type;\n    if (!is_array($type_info)) {\n      $token_problems['not-array']['problems'][] = \"\\$info['types']['$type']\";\n      continue;\n    }\n    elseif (!isset($type_info['name'])) {\n      $token_problems['missing-info']['problems'][] = \"\\$info['types']['$type']\";\n    }\n    elseif (is_array($type_info['name'])) {\n      $token_problems['duplicate']['problems'][] = \"\\$info['types']['$type']\";\n    }\n    elseif (empty($token_info['tokens'][$real_type])) {\n      $token_problems['type-no-tokens']['problems'][] = \"\\$info['types']['$real_type']\";\n    }\n  }\n\n  // Check tokens for problems.\n  foreach ($token_info['tokens'] as $type => $tokens) {\n    if (!is_array($tokens)) {\n      $token_problems['not-array']['problems'][] = \"\\$info['tokens']['$type']\";\n      continue;\n    }\n    else {\n      foreach (array_keys($tokens) as $token) {\n        if (!is_array($tokens[$token])) {\n          $token_problems['not-array']['problems'][] = \"\\$info['tokens']['$type']['$token']\";\n          continue;\n        }\n        elseif (!isset($tokens[$token]['name'])) {\n          $token_problems['missing-info']['problems'][] = \"\\$info['tokens']['$type']['$token']\";\n        }\n        elseif (is_array($tokens[$token]['name'])) {\n          $token_problems['duplicate']['problems'][] = \"\\$info['tokens']['$type']['$token']\";\n        }\n      }\n    }\n    if (!isset($token_info['types'][$type])) {\n      $token_problems['tokens-no-type']['problems'][] = \"\\$info['types']['$type']\";\n    }\n  }\n\n  return $token_problems;\n}\n"
    },
    {
        "path": "token.info.yml",
        "contents": "name: Token\ntype: module\ndescription: Provides a user interface for the Token API and some missing core tokens.\ncore_version_requirement: ^9.2 || ^10\n"
    },
    {
        "path": "token.tokens.inc",
        "contents": "<?php\n\n/**\n * @file\n * Token callbacks for the token module.\n */\n\nuse Drupal\\Component\\Utility\\Html;\nuse Drupal\\Core\\Entity\\ContentEntityInterface;\nuse Drupal\\Core\\Entity\\ContentEntityTypeInterface;\nuse Drupal\\Core\\Entity\\EntityInterface;\nuse Drupal\\Core\\Entity\\FieldableEntityInterface;\nuse Drupal\\Core\\Entity\\TypedData\\EntityDataDefinitionInterface;\nuse Drupal\\Core\\Field\\FieldStorageDefinitionInterface;\nuse Drupal\\Core\\Language\\LanguageInterface;\nuse Drupal\\Core\\Render\\BubbleableMetadata;\nuse Drupal\\Core\\Routing\\RouteObjectInterface;\nuse Drupal\\Core\\TypedData\\DataReferenceDefinitionInterface;\nuse Drupal\\Core\\Url;\nuse Drupal\\field\\FieldStorageConfigInterface;\nuse Drupal\\image\\Entity\\ImageStyle;\nuse Drupal\\menu_link_content\\MenuLinkContentInterface;\nuse Drupal\\node\\Entity\\Node;\nuse Drupal\\node\\Entity\\NodeType;\nuse Drupal\\node\\NodeInterface;\nuse Drupal\\system\\Entity\\Menu;\nuse Drupal\\user\\UserInterface;\n\n/**\n * Implements hook_token_info_alter().\n */\nfunction token_token_info_alter(&$info) {\n  // Force 'date' type tokens to require input and add a 'current-date' type.\n  // @todo Remove when http://drupal.org/node/943028 is fixed.\n  $info['types']['date']['needs-data'] = 'date';\n  $info['types']['current-date'] = [\n    'name' => t('Current date'),\n    'description' => t('Tokens related to the current date and time.'),\n    'type' => 'date',\n  ];\n\n  // Add a 'dynamic' key to any tokens that have chained but dynamic tokens.\n  $info['tokens']['date']['custom']['dynamic'] = TRUE;\n\n  // Remove deprecated tokens from being listed.\n  unset($info['tokens']['node']['tnid']);\n  unset($info['tokens']['node']['type']);\n  unset($info['tokens']['node']['type-name']);\n\n  // Support 'url' type tokens for core tokens.\n  if (isset($info['tokens']['comment']['url']) && \\Drupal::moduleHandler()->moduleExists('comment')) {\n    $info['tokens']['comment']['url']['type'] = 'url';\n  }\n  if (isset($info['tokens']['node']['url']) && \\Drupal::moduleHandler()->moduleExists('node')) {\n    $info['tokens']['node']['url']['type'] = 'url';\n  }\n  if (isset($info['tokens']['term']['url']) && \\Drupal::moduleHandler()->moduleExists('taxonomy')) {\n    $info['tokens']['term']['url']['type'] = 'url';\n  }\n  $info['tokens']['user']['url']['type'] = 'url';\n\n  // Add [token:url] tokens for any URI-able entities.\n  $entities = \\Drupal::entityTypeManager()->getDefinitions();\n  foreach ($entities as $entity_info) {\n    // Do not generate tokens if the entity doesn't define a token type or is\n    // not a content entity.\n    if (!$entity_info->get('token_type') || (!$entity_info instanceof ContentEntityTypeInterface)) {\n      continue;\n    }\n\n    $token_type = $entity_info->get('token_type');\n    if (!isset($info['types'][$token_type]) || !isset($info['tokens'][$token_type])) {\n      // Define tokens for entity type's without their own integration.\n      $info['types'][$entity_info->id()] = [\n        'name' => $entity_info->getLabel(),\n        'needs-data' => $entity_info->id(),\n        'module' => 'token',\n      ];\n    }\n\n    // Add [entity:url] tokens if they do not already exist.\n    // @todo Support entity:label\n    if (!isset($info['tokens'][$token_type]['url'])) {\n      $info['tokens'][$token_type]['url'] = [\n        'name' => t('URL'),\n        'description' => t('The URL of the @entity.', ['@entity' => mb_strtolower($entity_info->getLabel())]),\n        'module' => 'token',\n        'type' => 'url',\n      ];\n    }\n\n    // Add [entity:language] tokens if they do not already exist.\n    if (!isset($info['tokens'][$token_type]['language'])) {\n      $info['tokens'][$token_type]['language'] = [\n        'name' => t('Language'),\n        'description' => t('The language of the @entity.', ['@entity' => mb_strtolower($entity_info->getLabel())]),\n        'module' => 'token',\n        'type' => 'language',\n      ];\n    }\n\n    // Add [entity:original] tokens if they do not already exist.\n    if (!isset($info['tokens'][$token_type]['original'])) {\n      $info['tokens'][$token_type]['original'] = [\n        'name' => t('Original @entity', ['@entity' => mb_strtolower($entity_info->getLabel())]),\n        'description' => t('The original @entity data if the @entity is being updated or saved.', ['@entity' => mb_strtolower($entity_info->getLabel())]),\n        'module' => 'token',\n        'type' => $token_type,\n      ];\n    }\n  }\n\n  // Add support for custom date formats.\n  // @todo Remove when http://drupal.org/node/1173706 is fixed.\n  $date_format_types = \\Drupal::entityTypeManager()->getStorage('date_format')->loadMultiple();\n  foreach ($date_format_types as $date_format_type => $date_format_type_info) {\n    /* @var \\Drupal\\system\\Entity\\DateFormat $date_format_type_info */\n    if (!isset($info['tokens']['date'][$date_format_type])) {\n      $info['tokens']['date'][$date_format_type] = [\n        'name' => Html::escape($date_format_type_info->label()),\n        'description' => t(\"A date in '@type' format. (%date)\", ['@type' => $date_format_type, '%date' => \\Drupal::service('date.formatter')->format(\\Drupal::time()->getRequestTime(), $date_format_type)]),\n        'module' => 'token',\n      ];\n    }\n  }\n\n  // Call proxy implementations.\n  if (\\Drupal::moduleHandler()->moduleExists('field')) {\n    _field_token_info_alter($info);\n  }\n}\n\n/**\n * Implements hook_token_info().\n */\nfunction token_token_info() {\n  $info = [];\n\n  // Call proxy implementations.\n  if (\\Drupal::moduleHandler()->moduleExists('book')) {\n    $info += _book_token_info();\n  }\n  if (\\Drupal::moduleHandler()->moduleExists('menu_ui')) {\n    $info = array_merge_recursive($info, _menu_ui_token_info());\n  }\n\n  // Node tokens.\n  if (\\Drupal::moduleHandler()->moduleExists('node')) {\n    $info['tokens']['node']['source'] = [\n      'name' => t('Translation source node'),\n      'description' => t(\"The source node for this current node's translation set.\"),\n      'type' => 'node',\n    ];\n    $info['tokens']['node']['log'] = [\n      'name' => t('Revision log message'),\n      'description' => t('The explanation of the most recent changes made to the node.'),\n    ];\n    $info['tokens']['node']['content-type'] = [\n      'name' => t('Content type'),\n      'description' => t('The content type of the node.'),\n      'type' => 'content-type',\n    ];\n\n    // Content type tokens.\n    $info['types']['content-type'] = [\n      'name' => t('Content types'),\n      'description' => t('Tokens related to content types.'),\n      'needs-data' => 'node_type',\n    ];\n    $info['tokens']['content-type']['name'] = [\n      'name' => t('Name'),\n      'description' => t('The name of the content type.'),\n    ];\n    $info['tokens']['content-type']['machine-name'] = [\n      'name' => t('Machine-readable name'),\n      'description' => t('The unique machine-readable name of the content type.'),\n    ];\n    $info['tokens']['content-type']['description'] = [\n      'name' => t('Description'),\n      'description' => t('The optional description of the content type.'),\n    ];\n    $info['tokens']['content-type']['node-count'] = [\n      'name' => t('Node count'),\n      'description' => t('The number of nodes belonging to the content type.'),\n    ];\n    $info['tokens']['content-type']['edit-url'] = [\n      'name' => t('Edit URL'),\n      'description' => t(\"The URL of the content type's edit page.\"),\n      // 'type' => 'url',\n    ];\n  }\n\n  // Taxonomy term and vocabulary tokens.\n  if (\\Drupal::moduleHandler()->moduleExists('taxonomy')) {\n    $info['tokens']['term']['source'] = [\n      'name' => t('Translation source term'),\n      'description' => t(\"The source term for this current term's translation set.\"),\n      'type' => 'term',\n    ];\n    $info['tokens']['term']['edit-url'] = [\n      'name' => t('Edit URL'),\n      'description' => t(\"The URL of the taxonomy term's edit page.\"),\n      // 'type' => 'url',\n    ];\n    $info['tokens']['term']['parents'] = [\n      'name' => t('Parents'),\n      'description' => t(\"An array of all the term's parents, starting with the root.\"),\n      'type' => 'array',\n    ];\n    $info['tokens']['term']['root'] = [\n      'name' => t('Root term'),\n      'description' => t(\"The root term of the taxonomy term.\"),\n      'type' => 'term',\n    ];\n\n    $info['tokens']['vocabulary']['machine-name'] = [\n      'name' => t('Machine-readable name'),\n      'description' => t('The unique machine-readable name of the vocabulary.'),\n    ];\n    $info['tokens']['vocabulary']['edit-url'] = [\n      'name' => t('Edit URL'),\n      'description' => t(\"The URL of the vocabulary's edit page.\"),\n      // 'type' => 'url',\n    ];\n  }\n\n  // File tokens.\n  $info['tokens']['file']['basename'] = [\n    'name' => t('Base name'),\n    'description' => t('The base name of the file.'),\n  ];\n  $info['tokens']['file']['extension'] = [\n    'name' => t('Extension'),\n    'description' => t('The extension of the file.'),\n  ];\n  $info['tokens']['file']['size-raw'] = [\n    'name' => t('File byte size'),\n    'description' => t('The size of the file, in bytes.'),\n  ];\n\n  // User tokens.\n  // Add information on the restricted user tokens.\n  $info['tokens']['user']['cancel-url'] = [\n    'name' => t('Account cancellation URL'),\n    'description' => t('The URL of the confirm delete page for the user account.'),\n    'restricted' => TRUE,\n    // 'type' => 'url',\n  ];\n  $info['tokens']['user']['one-time-login-url'] = [\n    'name' => t('One-time login URL'),\n    'description' => t('The URL of the one-time login page for the user account.'),\n    'restricted' => TRUE,\n    // 'type' => 'url',\n  ];\n  $info['tokens']['user']['roles'] = [\n    'name' => t('Roles'),\n    'description' => t('The user roles associated with the user account.'),\n    'type' => 'array',\n  ];\n\n  // Current user tokens.\n  $info['tokens']['current-user']['ip-address'] = [\n    'name' => t('IP address'),\n    'description' => t('The IP address of the current user.'),\n  ];\n\n  // Menu link tokens (work regardless if menu module is enabled or not).\n  $info['types']['menu-link'] = [\n    'name' => t('Menu links'),\n    'description' => t('Tokens related to menu links.'),\n    'needs-data' => 'menu-link',\n  ];\n  $info['tokens']['menu-link']['mlid'] = [\n    'name' => t('Link ID'),\n    'description' => t('The unique ID of the menu link.'),\n  ];\n  $info['tokens']['menu-link']['title'] = [\n    'name' => t('Title'),\n    'description' => t('The title of the menu link.'),\n  ];\n  $info['tokens']['menu-link']['url'] = [\n    'name' => t('URL'),\n    'description' => t('The URL of the menu link.'),\n    'type' => 'url',\n  ];\n  $info['tokens']['menu-link']['parent'] = [\n    'name' => t('Parent'),\n    'description' => t(\"The menu link's parent.\"),\n    'type' => 'menu-link',\n  ];\n  $info['tokens']['menu-link']['parents'] = [\n    'name' => t('Parents'),\n    'description' => t(\"An array of all the menu link's parents, starting with the root.\"),\n    'type' => 'array',\n  ];\n  $info['tokens']['menu-link']['root'] = [\n    'name' => t('Root'),\n    'description' => t(\"The menu link's root.\"),\n    'type' => 'menu-link',\n  ];\n\n  // Language tokens.\n  $info['types']['language'] = [\n    'name' => t('Language'),\n    'description' => t('Tokens related to site language.'),\n  ];\n  $info['tokens']['language']['name'] = [\n    'name' => t('Language name'),\n    'description' => t('The language name.'),\n  ];\n  $info['tokens']['language']['langcode'] = [\n    'name' => t('Language code'),\n    'description' => t('The language code.'),\n  ];\n  $info['tokens']['language']['direction'] = [\n    'name' => t('Direction'),\n    'description' => t('Whether the language is written left-to-right (ltr) or right-to-left (rtl).'),\n  ];\n  $info['tokens']['language']['domain'] = [\n    'name' => t('Domain'),\n    'description' => t('The domain name to use for the language.'),\n  ];\n  $info['tokens']['language']['prefix'] = [\n    'name' => t('Path prefix'),\n    'description' => t('Path prefix for URLs in the language.'),\n  ];\n\n  // Current page tokens.\n  $info['types']['current-page'] = [\n    'name' => t('Current page'),\n    'description' => t('Tokens related to the current page request.'),\n  ];\n  $info['tokens']['current-page']['title'] = [\n    'name' => t('Title'),\n    'description' => t('The title of the current page.'),\n  ];\n  $info['tokens']['current-page']['url'] = [\n    'name' => t('URL'),\n    'description' => t('The URL of the current page.'),\n    'type' => 'url',\n  ];\n  $info['tokens']['current-page']['page-number'] = [\n    'name' => t('Page number'),\n    'description' => t('The page number of the current page when viewing paged lists.'),\n  ];\n  $info['tokens']['current-page']['query'] = [\n    'name' => t('Query string value'),\n    'description' => t('The value of a specific query string field of the current page.'),\n    'dynamic' => TRUE,\n  ];\n  $info['tokens']['current-page']['interface-language'] = [\n    'name' => t('Interface language'),\n    'description' => t('The active user interface language.'),\n    'type' => 'language',\n  ];\n  $info['tokens']['current-page']['content-language'] = [\n    'name' => t('Content language'),\n    'description' => t('The active content language.'),\n    'type' => 'language',\n  ];\n\n  // URL tokens.\n  $info['types']['url'] = [\n    'name' => t('URL'),\n    'description' => t('Tokens related to URLs.'),\n    'needs-data' => 'path',\n  ];\n  $info['tokens']['url']['path'] = [\n    'name' => t('Path'),\n    'description' => t('The path component of the URL.'),\n  ];\n  $info['tokens']['url']['relative'] = [\n    'name' => t('Relative URL'),\n    'description' => t('The relative URL.'),\n  ];\n  $info['tokens']['url']['absolute'] = [\n    'name' => t('Absolute URL'),\n    'description' => t('The absolute URL.'),\n  ];\n  $info['tokens']['url']['brief'] = [\n    'name' => t('Brief URL'),\n    'description' => t('The URL without the protocol and trailing backslash.'),\n  ];\n  $info['tokens']['url']['unaliased'] = [\n    'name' => t('Unaliased URL'),\n    'description' => t('The unaliased URL.'),\n    'type' => 'url',\n  ];\n  $info['tokens']['url']['args'] = [\n    'name' => t('Arguments'),\n    'description' => t(\"The specific argument of the current page (e.g. 'arg:1' on the page 'node/1' returns '1').\"),\n    'type' => 'array',\n  ];\n\n  // Array tokens.\n  $info['types']['array'] = [\n    'name' => t('Array'),\n    'description' => t('Tokens related to arrays of strings.'),\n    'needs-data' => 'array',\n    'nested' => TRUE,\n  ];\n  $info['tokens']['array']['first'] = [\n    'name' => t('First'),\n    'description' => t('The first element of the array.'),\n  ];\n  $info['tokens']['array']['last'] = [\n    'name' => t('Last'),\n    'description' => t('The last element of the array.'),\n  ];\n  $info['tokens']['array']['count'] = [\n    'name' => t('Count'),\n    'description' => t('The number of elements in the array.'),\n  ];\n  $info['tokens']['array']['reversed'] = [\n    'name' => t('Reversed'),\n    'description' => t('The array reversed.'),\n    'type' => 'array',\n  ];\n  $info['tokens']['array']['keys'] = [\n    'name' => t('Keys'),\n    'description' => t('The array of keys of the array.'),\n    'type' => 'array',\n  ];\n  $info['tokens']['array']['join'] = [\n    'name' => t('Imploded'),\n    'description' => t('The values of the array joined together with a custom string in-between each value.'),\n    'dynamic' => TRUE,\n  ];\n  $info['tokens']['array']['value'] = [\n    'name' => t('Value'),\n    'description' => t('The specific value of the array.'),\n    'dynamic' => TRUE,\n  ];\n\n  // Random tokens.\n  $info['types']['random'] = [\n    'name' => t('Random'),\n    'description' => t('Tokens related to random data.'),\n  ];\n  $info['tokens']['random']['number'] = [\n    'name' => t('Number'),\n    'description' => t('A random number from 0 to @max.', ['@max' => mt_getrandmax()]),\n  ];\n  $info['tokens']['random']['hash'] = [\n    'name' => t('Hash'),\n    'description' => t('A random hash. The possible hashing algorithms are: @hash-algos.', ['@hash-algos' => implode(', ', hash_algos())]),\n    'dynamic' => TRUE,\n  ];\n\n  // Define image_with_image_style token type.\n  if (\\Drupal::moduleHandler()->moduleExists('image')) {\n    $info['types']['image_with_image_style'] = [\n      'name' => t('Image with image style'),\n      'needs-data' => 'image_with_image_style',\n      'module' => 'token',\n      'nested' => TRUE,\n    ];\n\n    // Provide tokens for the ImageStyle attributes.\n    $info['tokens']['image_with_image_style']['mimetype'] = [\n      'name' => t('MIME type'),\n      'description' => t('The MIME type (image/png, image/bmp, etc.) of the image.'),\n    ];\n    $info['tokens']['image_with_image_style']['filesize'] = [\n      'name' => t('File size'),\n      'description' => t('The file size of the image.'),\n    ];\n    $info['tokens']['image_with_image_style']['height'] = [\n      'name' => t('Height'),\n      'description' => t('The height the image, in pixels.'),\n    ];\n    $info['tokens']['image_with_image_style']['width'] = [\n      'name' => t('Width'),\n      'description' => t('The width of the image, in pixels.'),\n    ];\n    $info['tokens']['image_with_image_style']['uri'] = [\n      'name' => t('URI'),\n      'description' => t('The URI to the image.'),\n    ];\n    $info['tokens']['image_with_image_style']['url'] = [\n      'name' => t('URL'),\n      'description' => t('The URL to the image.'),\n    ];\n  }\n\n  return $info;\n}\n\n/**\n * Implements hook_tokens().\n */\nfunction token_tokens($type, array $tokens, array $data, array $options, BubbleableMetadata $bubbleable_metadata) {\n  $replacements = [];\n\n  // Call proxy implementations.\n  if (\\Drupal::moduleHandler()->moduleExists('book')) {\n    $replacements += _book_tokens($type, $tokens, $data, $options, $bubbleable_metadata);\n  }\n  if (\\Drupal::moduleHandler()->moduleExists('menu_ui')) {\n    $replacements += _menu_ui_tokens($type, $tokens, $data, $options, $bubbleable_metadata);\n  }\n  if (\\Drupal::moduleHandler()->moduleExists('field')) {\n    $replacements += _field_tokens($type, $tokens, $data, $options, $bubbleable_metadata);\n  }\n\n  $language_manager = \\Drupal::languageManager();\n  $url_options = ['absolute' => TRUE];\n  if (isset($options['langcode'])) {\n    $url_options['language'] = $language_manager->getLanguage($options['langcode']);\n    $langcode = $options['langcode'];\n  }\n  else {\n    $langcode = $language_manager->getCurrentLanguage()->getId();\n  }\n\n  // Date tokens.\n  if ($type == 'date') {\n    $date = !empty($data['date']) ? $data['date'] : \\Drupal::time()->getRequestTime();\n\n    // @todo Remove when http://drupal.org/node/1173706 is fixed.\n    $date_format_types = \\Drupal::entityTypeManager()->getStorage('date_format')->loadMultiple();\n    foreach ($tokens as $name => $original) {\n      if (isset($date_format_types[$name]) && \\Drupal::service('token.module_provider')->getTokenModule('date', $name) == 'token') {\n        $replacements[$original] = \\Drupal::service('date.formatter')->format($date, $name, '', NULL, $langcode);\n      }\n    }\n  }\n\n  // Current date tokens.\n  // @todo Remove when http://drupal.org/node/943028 is fixed.\n  if ($type == 'current-date') {\n    $replacements += \\Drupal::token()->generate('date', $tokens, ['date' => \\Drupal::time()->getRequestTime()], $options, $bubbleable_metadata);\n  }\n\n  // Comment tokens.\n  if ($type == 'comment' && !empty($data['comment'])) {\n    /* @var \\Drupal\\comment\\CommentInterface $comment */\n    $comment = $data['comment'];\n\n    // Chained token relationships.\n    if (($url_tokens = \\Drupal::token()->findWithPrefix($tokens, 'url'))) {\n      // Add fragment to url options.\n      $replacements += \\Drupal::token()->generate('url', $url_tokens, ['url' => $comment->toUrl('canonical', ['fragment' => \"comment-{$comment->id()}\"])], $options, $bubbleable_metadata);\n    }\n  }\n\n  // Node tokens.\n  if ($type == 'node' && !empty($data['node'])) {\n    /* @var \\Drupal\\node\\NodeInterface $node */\n    $node = $data['node'];\n\n    foreach ($tokens as $name => $original) {\n      switch ($name) {\n        case 'log':\n          $replacements[$original] = (string) $node->revision_log->value;\n          break;\n\n        case 'content-type':\n          $type_name = \\Drupal::entityTypeManager()->getStorage('node_type')->load($node->getType())->label();\n          $replacements[$original] = $type_name;\n          break;\n      }\n    }\n\n    // Chained token relationships.\n    if (($parent_tokens = \\Drupal::token()->findWithPrefix($tokens, 'source')) && $source_node = $node->getUntranslated()) {\n      $replacements += \\Drupal::token()->generate('node', $parent_tokens, ['node' => $source_node], $options, $bubbleable_metadata);\n    }\n    if (($node_type_tokens = \\Drupal::token()->findWithPrefix($tokens, 'content-type')) && $node_type = NodeType::load($node->bundle())) {\n      $replacements += \\Drupal::token()->generate('content-type', $node_type_tokens, ['node_type' => $node_type], $options, $bubbleable_metadata);\n    }\n    if (($url_tokens = \\Drupal::token()->findWithPrefix($tokens, 'url'))) {\n      $replacements += \\Drupal::token()->generate('url', $url_tokens, ['url' => $node->toUrl()], $options, $bubbleable_metadata);\n    }\n  }\n\n  // Content type tokens.\n  if ($type == 'content-type' && !empty($data['node_type'])) {\n    /* @var \\Drupal\\node\\NodeTypeInterface $node_type */\n    $node_type = $data['node_type'];\n\n    foreach ($tokens as $name => $original) {\n      switch ($name) {\n        case 'name':\n          $replacements[$original] = $node_type->label();\n          break;\n\n        case 'machine-name':\n          $replacements[$original] = $node_type->id();\n          break;\n\n        case 'description':\n          $replacements[$original] = $node_type->getDescription();\n          break;\n\n        case 'node-count':\n          $count = \\Drupal::entityQueryAggregate('node')\n            ->aggregate('nid', 'COUNT')\n            ->condition('type', $node_type->id())\n            ->accessCheck(TRUE)\n            ->execute();\n          $replacements[$original] = (int) $count;\n          break;\n\n        case 'edit-url':\n          $result = $node_type->toUrl('edit-form', $url_options)->toString(TRUE);\n          $bubbleable_metadata->addCacheableDependency($result);\n          $replacements[$original] = $result->getGeneratedUrl();\n          break;\n      }\n    }\n  }\n\n  // Taxonomy term tokens.\n  if ($type == 'term' && !empty($data['term'])) {\n    /* @var \\Drupal\\taxonomy\\TermInterface $term */\n    $term = $data['term'];\n\n    /** @var \\Drupal\\taxonomy\\TermStorageInterface $term_storage */\n    $term_storage = \\Drupal::entityTypeManager()->getStorage('taxonomy_term');\n\n    foreach ($tokens as $name => $original) {\n      switch ($name) {\n        case 'edit-url':\n          $result = Url::fromRoute('entity.taxonomy_term.edit_form', ['taxonomy_term' => $term->id()], $url_options)->toString(TRUE);\n          $bubbleable_metadata->addCacheableDependency($result);\n          $replacements[$original] = $result->getGeneratedUrl();\n          break;\n\n        case 'parents':\n          if ($parents = token_taxonomy_term_load_all_parents($term->id(), $langcode)) {\n            $replacements[$original] = token_render_array($parents, $options);\n          }\n          break;\n\n        case 'root':\n          $parents = $term_storage->loadAllParents($term->id());\n          $root_term = end($parents);\n          if ($root_term->id() != $term->id()) {\n            $root_term = \\Drupal::service('entity.repository')->getTranslationFromContext($root_term, $langcode);\n            $replacements[$original] = $root_term->label();\n          }\n          break;\n      }\n    }\n\n    // Chained token relationships.\n    if (($parent_tokens = \\Drupal::token()->findWithPrefix($tokens, 'source')) && $source_term = \\Drupal::service('entity.repository')->getTranslationFromContext($term, LanguageInterface::LANGCODE_DEFAULT)) {\n      $replacements += \\Drupal::token()->generate('term', $parent_tokens, [\n        'term' => $source_term,\n      ], ['langcode' => $source_term->language()->getId()] + $options, $bubbleable_metadata);\n    }\n    if (($url_tokens = \\Drupal::token()->findWithPrefix($tokens, 'url'))) {\n      $replacements += \\Drupal::token()->generate('url', $url_tokens, ['url' => $term->toUrl()], $options, $bubbleable_metadata);\n    }\n    // [term:parents:*] chained tokens.\n    if ($parents_tokens = \\Drupal::token()->findWithPrefix($tokens, 'parents')) {\n      if ($parents = token_taxonomy_term_load_all_parents($term->id(), $langcode)) {\n        $replacements += \\Drupal::token()->generate('array', $parents_tokens, ['array' => $parents], $options, $bubbleable_metadata);\n      }\n    }\n    if ($root_tokens = \\Drupal::token()->findWithPrefix($tokens, 'root')) {\n      $parents = $term_storage->loadAllParents($term->id());\n      $root_term = end($parents);\n      if ($root_term->tid != $term->id()) {\n        $replacements += \\Drupal::token()->generate('term', $root_tokens, ['term' => $root_term], $options, $bubbleable_metadata);\n      }\n    }\n  }\n\n  // Vocabulary tokens.\n  if ($type == 'vocabulary' && !empty($data['vocabulary'])) {\n    $vocabulary = $data['vocabulary'];\n\n    foreach ($tokens as $name => $original) {\n      switch ($name) {\n        case 'machine-name':\n          $replacements[$original] = $vocabulary->id();\n          break;\n\n        case 'edit-url':\n          $result = Url::fromRoute('entity.taxonomy_vocabulary.edit_form', ['taxonomy_vocabulary' => $vocabulary->id()], $url_options)->toString(TRUE);\n          $bubbleable_metadata->addCacheableDependency($result);\n          $replacements[$original] = $result->getGeneratedUrl();\n          break;\n      }\n    }\n  }\n\n  // File tokens.\n  if ($type == 'file' && !empty($data['file'])) {\n    $file = $data['file'];\n\n    foreach ($tokens as $name => $original) {\n      switch ($name) {\n        case 'basename':\n          $basename = pathinfo($file->uri->value, PATHINFO_BASENAME);\n          $replacements[$original] = $basename;\n          break;\n\n        case 'extension':\n          $extension = pathinfo($file->uri->value, PATHINFO_EXTENSION);\n          $replacements[$original] = $extension;\n          break;\n\n        case 'size-raw':\n          $replacements[$original] = (int) $file->filesize->value;\n          break;\n      }\n    }\n  }\n\n  // User tokens.\n  if ($type == 'user' && !empty($data['user'])) {\n    /* @var \\Drupal\\user\\UserInterface $account */\n    $account = $data['user'];\n\n    foreach ($tokens as $name => $original) {\n      switch ($name) {\n        case 'picture':\n          if ($account instanceof UserInterface && $account->hasField('user_picture')) {\n            /** @var \\Drupal\\Core\\Render\\RendererInterface $renderer */\n            $renderer = \\Drupal::service('renderer');\n            $output = [\n              '#theme' => 'user_picture',\n              '#account' => $account,\n            ];\n            $replacements[$original] = $renderer->renderPlain($output);\n          }\n          break;\n\n        case 'roles':\n          $roles = $account->getRoles();\n          $roles_names = array_combine($roles, $roles);\n          $replacements[$original] = token_render_array($roles_names, $options);\n          break;\n      }\n    }\n\n    // Chained token relationships.\n    if ($account instanceof UserInterface && $account->hasField('user_picture') && ($picture_tokens = \\Drupal::token()->findWithPrefix($tokens, 'picture'))) {\n      $replacements += \\Drupal::token()->generate('file', $picture_tokens, ['file' => $account->user_picture->entity], $options, $bubbleable_metadata);\n    }\n    if ($url_tokens = \\Drupal::token()->findWithPrefix($tokens, 'url')) {\n      $replacements += \\Drupal::token()->generate('url', $url_tokens, ['url' => $account->toUrl()], $options, $bubbleable_metadata);\n    }\n    if ($role_tokens = \\Drupal::token()->findWithPrefix($tokens, 'roles')) {\n      $roles = $account->getRoles();\n      $roles_names = array_combine($roles, $roles);\n      $replacements += \\Drupal::token()->generate('array', $role_tokens, ['array' => $roles_names], $options, $bubbleable_metadata);\n    }\n  }\n\n  // Current user tokens.\n  if ($type == 'current-user') {\n    foreach ($tokens as $name => $original) {\n      switch ($name) {\n        case 'ip-address':\n          $ip = \\Drupal::request()->getClientIp();\n          $replacements[$original] = $ip;\n          break;\n      }\n    }\n  }\n\n  // Menu link tokens.\n  if ($type == 'menu-link' && !empty($data['menu-link'])) {\n    /** @var \\Drupal\\Core\\Menu\\MenuLinkInterface $link */\n    $link = $data['menu-link'];\n    /** @var \\Drupal\\Core\\Menu\\MenuLinkManagerInterface $menu_link_manager */\n    $menu_link_manager = \\Drupal::service('plugin.manager.menu.link');\n\n    if ($link instanceof MenuLinkContentInterface) {\n      $link = $menu_link_manager->createInstance($link->getPluginId());\n    }\n\n    foreach ($tokens as $name => $original) {\n      switch ($name) {\n        case 'id':\n          $replacements[$original] = $link->getPluginId();\n          break;\n\n        case 'title':\n          $replacements[$original] = token_menu_link_translated_title($link, $langcode);\n          break;\n\n        case 'url':\n          $result = $link->getUrlObject()->setAbsolute()->toString(TRUE);\n          $bubbleable_metadata->addCacheableDependency($result);\n          $replacements[$original] = $result->getGeneratedUrl();\n          break;\n\n        case 'parent':\n          /** @var \\Drupal\\Core\\Menu\\MenuLinkInterface $parent */\n          if ($link->getParent() && $parent = $menu_link_manager->createInstance($link->getParent())) {\n            $replacements[$original] = token_menu_link_translated_title($parent, $langcode);\n          }\n          break;\n\n        case 'parents':\n          if ($parents = token_menu_link_load_all_parents($link->getPluginId(), $langcode)) {\n            $replacements[$original] = token_render_array($parents, $options);\n          }\n          break;\n\n        case 'root';\n          if ($link->getParent() && $parent_ids = array_keys(token_menu_link_load_all_parents($link->getPluginId(), $langcode))) {\n            $root = $menu_link_manager->createInstance(array_shift($parent_ids));\n            $replacements[$original] = token_menu_link_translated_title($root, $langcode);\n          }\n          break;\n      }\n    }\n\n    // Chained token relationships.\n    /** @var \\Drupal\\Core\\Menu\\MenuLinkInterface $parent */\n    if ($link->getParent() && ($parent_tokens = \\Drupal::token()->findWithPrefix($tokens, 'parent')) && $parent = $menu_link_manager->createInstance($link->getParent())) {\n      $replacements += \\Drupal::token()->generate('menu-link', $parent_tokens, ['menu-link' => $parent], $options, $bubbleable_metadata);\n    }\n    // [menu-link:parents:*] chained tokens.\n    if ($parents_tokens = \\Drupal::token()->findWithPrefix($tokens, 'parents')) {\n      if ($parents = token_menu_link_load_all_parents($link->getPluginId(), $langcode)) {\n        $replacements += \\Drupal::token()->generate('array', $parents_tokens, ['array' => $parents], $options, $bubbleable_metadata);\n      }\n    }\n    if (($root_tokens = \\Drupal::token()->findWithPrefix($tokens, 'root')) && $link->getParent() && $parent_ids = array_keys(token_menu_link_load_all_parents($link->getPluginId(), $langcode))) {\n      $root = $menu_link_manager->createInstance(array_shift($parent_ids));\n      $replacements += \\Drupal::token()->generate('menu-link', $root_tokens, ['menu-link' => $root], $options, $bubbleable_metadata);\n    }\n    if ($url_tokens = \\Drupal::token()->findWithPrefix($tokens, 'url')) {\n      $replacements += \\Drupal::token()->generate('url', $url_tokens, ['url' => $link->getUrlObject()], $options, $bubbleable_metadata);\n    }\n\n  }\n\n  // Language tokens.\n  if ($type == 'language' && !empty($langcode)) {\n    $language = $language_manager->getLanguage($langcode);\n    if ($language) {\n      foreach ($tokens as $name => $original) {\n        switch ($name) {\n          case 'name':\n            $replacements[$original] = $language->getName();\n            break;\n          case 'langcode':\n            $replacements[$original] = $langcode;\n            break;\n          case 'direction':\n            $replacements[$original] = $language->getDirection();\n            break;\n          case 'domain':\n            if (!isset($language_url_domains)) {\n              $language_url_domains = \\Drupal::config('language.negotiation')->get('url.domains');\n            }\n            if (isset($language_url_domains[$langcode])) {\n              $replacements[$original] = $language_url_domains[$langcode];\n            }\n            break;\n          case 'prefix':\n            if (!isset($language_url_prefixes)) {\n              $language_url_prefixes = \\Drupal::config('language.negotiation')->get('url.prefixes');\n            }\n            if (isset($language_url_prefixes[$langcode])) {\n              $replacements[$original] = $language_url_prefixes[$langcode];\n            }\n            break;\n        }\n      }\n    }\n  }\n\n  // Current page tokens.\n  if ($type == 'current-page') {\n    $request = \\Drupal::request();\n    foreach ($tokens as $name => $original) {\n      switch ($name) {\n        case 'title':\n          $route = $request->attributes->get(RouteObjectInterface::ROUTE_OBJECT);\n          if ($route) {\n            $title = \\Drupal::service('title_resolver')->getTitle($request, $route);\n            $replacements[$original] = token_render_array_value($title);\n          }\n          break;\n\n        case 'url':\n          $bubbleable_metadata->addCacheContexts(['url.path']);\n          try {\n            $url = Url::createFromRequest($request)->setOptions($url_options);\n          }\n          catch (\\Exception $e) {\n            // Url::createFromRequest() can fail, e.g. on 404 pages.\n            // Fall back and try again with Url::fromUserInput().\n            try {\n              $url = Url::fromUserInput($request->getPathInfo(), $url_options);\n            }\n            catch (\\Exception $e) {\n              // Instantiation would fail again on malformed urls.\n            }\n          }\n          if (isset($url)) {\n            $result = $url->toString(TRUE);\n            $bubbleable_metadata->addCacheableDependency($result);\n            $replacements[$original] = $result->getGeneratedUrl();\n          }\n          break;\n\n        case 'page-number':\n          if ($page = $request->query->get('page')) {\n            // @see PagerDefault::execute()\n            $pager_page_array = explode(',', $page);\n            $page = $pager_page_array[0];\n          }\n          $replacements[$original] = (int) $page + 1;\n          break;\n      }\n      // [current-page:interface-language:*] chained tokens.\n      if ($language_interface_tokens = \\Drupal::token()->findWithPrefix($tokens, 'interface-language')) {\n        $language_interface = $language_manager->getCurrentLanguage(LanguageInterface::TYPE_INTERFACE);\n        $langcode = $language_interface->getId();\n        $replacements += \\Drupal::token()->generate('language', $language_interface_tokens, $data, ['langcode' => $langcode] + $options, $bubbleable_metadata);\n      }\n      // [current-page:content-language:*] chained tokens.\n      if ($language_content_tokens = \\Drupal::token()->findWithPrefix($tokens, 'content-language')) {\n        $language_content = $language_manager->getCurrentLanguage(LanguageInterface::TYPE_CONTENT);\n        $langcode = $language_content->getId();\n        $replacements += \\Drupal::token()->generate('language', $language_content_tokens, $data, ['langcode' => $langcode] + $options, $bubbleable_metadata);\n      }\n    }\n\n    // @deprecated\n    // [current-page:arg] dynamic tokens.\n    if ($arg_tokens = \\Drupal::token()->findWithPrefix($tokens, 'arg')) {\n      $path = ltrim(\\Drupal::service('path.current')->getPath(), '/');\n      // Make sure its a system path.\n      $path = \\Drupal::service('path_alias.manager')->getPathByAlias($path);\n      foreach ($arg_tokens as $name => $original) {\n        $parts = explode('/', $path);\n        if (is_numeric($name) && isset($parts[$name])) {\n          $replacements[$original] = $parts[$name];\n        }\n      }\n    }\n\n    // [current-page:query] dynamic tokens.\n    if ($query_tokens = \\Drupal::token()->findWithPrefix($tokens, 'query')) {\n      $bubbleable_metadata->addCacheContexts(['url.query_args']);\n      foreach ($query_tokens as $name => $original) {\n        if (\\Drupal::request()->query->has($name)) {\n          $value = \\Drupal::request()->query->get($name);\n          $replacements[$original] = $value;\n        }\n      }\n    }\n\n    // Chained token relationships.\n    if ($url_tokens = \\Drupal::token()->findWithPrefix($tokens, 'url')) {\n      $url = NULL;\n      try {\n        $url = Url::createFromRequest($request)->setOptions($url_options);\n      }\n      catch (\\Exception $e) {\n        // Url::createFromRequest() can fail, e.g. on 404 pages.\n        // Fall back and try again with Url::fromUserInput().\n        try {\n          $url = Url::fromUserInput($request->getPathInfo(), $url_options);\n        }\n        catch (\\Exception $e) {\n          // Instantiation would fail again on malformed urls.\n        }\n      }\n      // Add cache contexts to ensure this token functions on a per-path basis\n      $bubbleable_metadata->addCacheContexts(['url.path']);\n      $replacements += \\Drupal::token()->generate('url', $url_tokens, ['url' => $url], $options, $bubbleable_metadata);\n    }\n  }\n\n  // URL tokens.\n  if ($type == 'url' && !empty($data['url'])) {\n    /** @var \\Drupal\\Core\\Url $url */\n    $url = $data['url'];\n    // To retrieve the correct path, modify a copy of the Url object.\n    $path_url = clone $url;\n    $path = '/';\n    // Ensure the URL is routed to avoid throwing an exception.\n    if ($url->isRouted()) {\n      $path .= $path_url->setAbsolute(FALSE)->setOption('fragment', NULL)->getInternalPath();\n    }\n\n    foreach ($tokens as $name => $original) {\n      switch ($name) {\n        case 'path':\n          $value = !($url->getOption('alias')) ? \\Drupal::service('path_alias.manager')->getAliasByPath($path, $langcode) : $path;\n          $replacements[$original] = $value;\n          break;\n\n        case 'alias':\n          // @deprecated\n          $alias = \\Drupal::service('path_alias.manager')->getAliasByPath($path, $langcode);\n          $replacements[$original] = $alias;\n          break;\n\n        case 'absolute':\n          $result = $url->setAbsolute()->toString(TRUE);\n          $bubbleable_metadata->addCacheableDependency($result);\n          $replacements[$original] = $result->getGeneratedUrl();\n          break;\n\n        case 'relative':\n          $result = $url->setAbsolute(FALSE)->toString(TRUE);\n          $bubbleable_metadata->addCacheableDependency($result);\n          $replacements[$original] = $result->getGeneratedUrl();\n          break;\n\n        case 'brief':\n          $result = $url->setAbsolute()->toString(TRUE);\n          $bubbleable_metadata->addCacheableDependency($result);\n          $replacements[$original] = preg_replace(['!^https?://!', '!/$!'], '', $result->getGeneratedUrl());\n          break;\n\n        case 'unaliased':\n          $unaliased = clone $url;\n          $result = $unaliased->setAbsolute()->setOption('alias', TRUE)->toString(TRUE);\n          $bubbleable_metadata->addCacheableDependency($result);\n          $replacements[$original] = $result->getGeneratedUrl();\n          break;\n\n        case 'args':\n          $value = !($url->getOption('alias')) ? \\Drupal::service('path_alias.manager')->getAliasByPath($path, $langcode) : $path;\n          $replacements[$original] = token_render_array(explode('/', $value), $options);\n          break;\n      }\n    }\n\n    // [url:args:*] chained tokens.\n    if ($arg_tokens = \\Drupal::token()->findWithPrefix($tokens, 'args')) {\n      $value = !($url->getOption('alias')) ? \\Drupal::service('path_alias.manager')->getAliasByPath($path, $langcode) : $path;\n      $replacements += \\Drupal::token()->generate('array', $arg_tokens, ['array' => explode('/', ltrim($value, '/'))], $options, $bubbleable_metadata);\n    }\n\n    // [url:unaliased:*] chained tokens.\n    if ($unaliased_tokens = \\Drupal::token()->findWithPrefix($tokens, 'unaliased')) {\n      $url->setOption('alias', TRUE);\n      $replacements += \\Drupal::token()->generate('url', $unaliased_tokens, ['url' => $url], $options, $bubbleable_metadata);\n    }\n\n  }\n  /** @var \\Drupal\\token\\TokenModuleProvider $token_module_provider */\n  $token_module_provider = \\Drupal::service('token.module_provider');\n\n  // Entity tokens.\n  if (!empty($data[$type]) && $entity_type = \\Drupal::service('token.entity_mapper')->getEntityTypeForTokenType($type)) {\n    /* @var \\Drupal\\Core\\Entity\\EntityInterface $entity */\n    $entity = $data[$type];\n\n    foreach ($tokens as $name => $original) {\n      switch ($name) {\n        case 'url':\n          if ($token_module_provider->getTokenModule($type, 'url') === 'token' && !$entity->isNew() && $entity->hasLinkTemplate('canonical')) {\n            $result = $entity->toUrl('canonical')->toString(TRUE);\n            $bubbleable_metadata->addCacheableDependency($result);\n            $replacements[$original] = $result->getGeneratedUrl();\n          }\n          break;\n\n        case 'original':\n          if ($token_module_provider->getTokenModule($type, 'original') == 'token' && !empty($entity->original)) {\n            $label = $entity->original->label();\n            $replacements[$original] = $label;\n          }\n          break;\n      }\n    }\n\n    // [entity:url:*] chained tokens.\n    if (($url_tokens = \\Drupal::token()->findWithPrefix($tokens, 'url')) && $token_module_provider->getTokenModule($type, 'url') == 'token') {\n      $replacements += \\Drupal::token()->generate('url', $url_tokens, ['url' => $entity->toUrl()], $options, $bubbleable_metadata);\n    }\n\n    // [entity:original:*] chained tokens.\n    if (($original_tokens = \\Drupal::token()->findWithPrefix($tokens, 'original')) && $token_module_provider->getTokenModule($type, 'original') == 'token' && !empty($entity->original)) {\n      $replacements += \\Drupal::token()->generate($type, $original_tokens, [$type => $entity->original], $options, $bubbleable_metadata);\n    }\n\n    // [entity:language:*] chained tokens.\n    if (($language_tokens = \\Drupal::token()->findWithPrefix($tokens, 'language')) && $token_module_provider->getTokenModule($type, 'language') == 'token') {\n      $language_options = array_merge($options, ['langcode' => $entity->get('langcode')->value]);\n      $replacements += \\Drupal::token()->generate('language', $language_tokens, [], $language_options, $bubbleable_metadata);\n    }\n\n    // Pass through to an generic 'entity' token type generation.\n    $entity_data = [\n      'entity_type' => $entity_type,\n      'entity' => $entity,\n      'token_type' => $type,\n    ];\n    // @todo Investigate passing through more data like everything from entity_extract_ids().\n    $replacements += \\Drupal::token()->generate('entity', $tokens, $entity_data, $options, $bubbleable_metadata);\n  }\n\n  // Array tokens.\n  if ($type == 'array' && !empty($data['array']) && is_array($data['array'])) {\n    $array = $data['array'];\n\n    $sort = isset($options['array sort']) ? $options['array sort'] : TRUE;\n    $keys = token_element_children($array, $sort);\n\n    /** @var \\Drupal\\Core\\Render\\RendererInterface $renderer */\n    $renderer = \\Drupal::service('renderer');\n\n    foreach ($tokens as $name => $original) {\n      switch ($name) {\n        case 'first':\n          $value = $array[$keys[0]];\n          $value = is_array($value) ? $renderer->renderPlain($value) : (string) $value;\n          $replacements[$original] = $value;\n          break;\n\n        case 'last':\n          $value = $array[$keys[count($keys) - 1]];\n          $value = is_array($value) ? $renderer->renderPlain($value) : (string) $value;\n          $replacements[$original] = $value;\n          break;\n\n        case 'count':\n          $replacements[$original] = count($keys);\n          break;\n\n        case 'keys':\n          $replacements[$original] = token_render_array($keys, $options);\n          break;\n\n        case 'reversed':\n          $reversed = array_reverse($array, TRUE);\n          $replacements[$original] = token_render_array($reversed, $options);\n          break;\n\n        case 'join':\n          $replacements[$original] = token_render_array($array, ['join' => ''] + $options);\n          break;\n      }\n    }\n\n    // [array:value:*] dynamic tokens.\n    if ($value_tokens = \\Drupal::token()->findWithPrefix($tokens, 'value')) {\n      foreach ($value_tokens as $key => $original) {\n        if ((is_int($key) || $key[0] !== '#') && isset($array[$key])) {\n          $replacements[$original] = token_render_array_value($array[$key], $options);\n        }\n      }\n    }\n\n    // [array:join:*] dynamic tokens.\n    if ($join_tokens = \\Drupal::token()->findWithPrefix($tokens, 'join')) {\n      foreach ($join_tokens as $join => $original) {\n        $replacements[$original] = token_render_array($array, ['join' => $join] + $options);\n      }\n    }\n\n    // [array:keys:*] chained tokens.\n    if ($key_tokens = \\Drupal::token()->findWithPrefix($tokens, 'keys')) {\n      $replacements += \\Drupal::token()->generate('array', $key_tokens, ['array' => $keys], $options, $bubbleable_metadata);\n    }\n\n    // [array:reversed:*] chained tokens.\n    if ($reversed_tokens = \\Drupal::token()->findWithPrefix($tokens, 'reversed')) {\n      $replacements += \\Drupal::token()->generate('array', $reversed_tokens, ['array' => array_reverse($array, TRUE)], ['array sort' => FALSE] + $options, $bubbleable_metadata);\n    }\n\n    // @todo Handle if the array values are not strings and could be chained.\n  }\n\n  // Random tokens.\n  if ($type == 'random') {\n    foreach ($tokens as $name => $original) {\n      switch ($name) {\n        case 'number':\n          $replacements[$original] = mt_rand();\n          break;\n      }\n    }\n\n    // [custom:hash:*] dynamic token.\n    if ($hash_tokens = \\Drupal::token()->findWithPrefix($tokens, 'hash')) {\n      $algos = hash_algos();\n      foreach ($hash_tokens as $name => $original) {\n        if (in_array($name, $algos)) {\n          $replacements[$original] = hash($name, random_bytes(55));\n        }\n      }\n    }\n  }\n\n  // If $type is a token type, $data[$type] is empty but $data[$entity_type] is\n  // not, re-run token replacements.\n  if (empty($data[$type]) && ($entity_type = \\Drupal::service('token.entity_mapper')->getEntityTypeForTokenType($type)) && $entity_type != $type && !empty($data[$entity_type]) && empty($options['recursive'])) {\n    $data[$type] = $data[$entity_type];\n    $options['recursive'] = TRUE;\n    $replacements += \\Drupal::moduleHandler()->invokeAll('tokens', [$type, $tokens, $data, $options, $bubbleable_metadata]);\n  }\n\n  // If the token type specifics a 'needs-data' value, and the value is not\n  // present in $data, then throw an error.\n  if (!empty($GLOBALS['drupal_test_info']['test_run_id'])) {\n    // Only check when tests are running.\n    $type_info = \\Drupal::token()->getTypeInfo($type);\n    if (!empty($type_info['needs-data']) && !isset($data[$type_info['needs-data']])) {\n      trigger_error(t('Attempting to perform token replacement for token type %type without required data', ['%type' => $type]), E_USER_WARNING);\n    }\n  }\n\n  return $replacements;\n}\n\n/**\n * Proxy implementation of hook_token_info() on behalf of book.module.\n */\nfunction _book_token_info() {\n  $info['types']['book'] = [\n    'name' => t('Book'),\n    'description' => t('Tokens related to books.'),\n    'needs-data' => 'book',\n  ];\n\n  $info['tokens']['book']['title'] = [\n    'name' => t('Title'),\n    'description' => t('Title of the book.'),\n  ];\n  $info['tokens']['book']['author'] = [\n    'name' => t('Author'),\n    'description' => t('The author of the book.'),\n    'type' => 'user',\n  ];\n  $info['tokens']['book']['root'] = [\n    'name' => t('Root'),\n    'description' => t('Top level of the book.'),\n    'type' => 'node',\n  ];\n  $info['tokens']['book']['parent'] = [\n    'name' => t('Parent'),\n    'description' => t('Parent of the current page.'),\n    'type' => 'node',\n  ];\n  $info['tokens']['book']['parents'] = [\n    'name' => t('Parents'),\n    'description' => t(\"An array of all the node's parents, starting with the root.\"),\n    'type' => 'array',\n  ];\n\n  $info['tokens']['node']['book'] = [\n    'name' => t('Book'),\n    'description' => t('The book page associated with the node.'),\n    'type' => 'book',\n  ];\n  return $info;\n}\n\n/**\n * Proxy implementation of hook_tokens() on behalf of book.module.\n */\nfunction _book_tokens($type, $tokens, array $data, array $options, BubbleableMetadata $bubbleable_metadata) {\n  $replacements = [];\n\n  // Node tokens.\n  if ($type == 'node' && !empty($data['node'])) {\n    $book = $data['node']->book;\n\n    if (!empty($book['bid'])) {\n      if ($book_tokens = \\Drupal::token()->findWithPrefix($tokens, 'book')) {\n        $child_node = Node::load($book['nid']);\n        $replacements += \\Drupal::token()->generate('book', $book_tokens, ['book' => $child_node], $options, $bubbleable_metadata);\n      }\n    }\n  }\n  // Book tokens.\n  elseif ($type == 'book' && !empty($data['book'])) {\n    $book = $data['book']->book;\n\n    if (!empty($book['bid'])) {\n      $book_node = Node::load($book['bid']);\n\n      foreach ($tokens as $name => $original) {\n        switch ($name) {\n          case 'root':\n          case 'title':\n            $replacements[$original] = $book_node->getTitle();\n            break;\n\n          case 'parent':\n            if (!empty($book['pid'])) {\n              $parent_node = Node::load($book['pid']);\n              $replacements[$original] = $parent_node->getTitle();\n            }\n            break;\n\n          case 'parents':\n            if ($parents = token_book_load_all_parents($book)) {\n              $replacements[$original] = token_render_array($parents, $options);\n            }\n            break;\n        }\n      }\n\n      if ($book_tokens = \\Drupal::token()->findWithPrefix($tokens, 'author')) {\n        $replacements += \\Drupal::token()->generate('user', $book_tokens, ['user' => $book_node->getOwner()], $options, $bubbleable_metadata);\n      }\n      if ($book_tokens = \\Drupal::token()->findWithPrefix($tokens, 'root')) {\n        $replacements += \\Drupal::token()->generate('node', $book_tokens, ['node' => $book_node], $options, $bubbleable_metadata);\n      }\n      if (!empty($book['pid']) && $book_tokens = \\Drupal::token()->findWithPrefix($tokens, 'parent')) {\n        $parent_node = Node::load($book['pid']);\n        $replacements += \\Drupal::token()->generate('node', $book_tokens, ['node' => $parent_node], $options, $bubbleable_metadata);\n      }\n      if ($book_tokens = \\Drupal::token()->findWithPrefix($tokens, 'parents')) {\n        $parents = token_book_load_all_parents($book);\n        $replacements += \\Drupal::token()->generate('array', $book_tokens, ['array' => $parents], $options, $bubbleable_metadata);\n      }\n    }\n  }\n\n  return $replacements;\n}\n\n/**\n * Proxy implementation of hook_token_info() on behalf of menu_ui.module.\n */\nfunction _menu_ui_token_info() {\n  // Menu tokens.\n  $info['types']['menu'] = [\n    'name' => t('Menus'),\n    'description' => t('Tokens related to menus.'),\n    'needs-data' => 'menu',\n  ];\n  $info['tokens']['menu']['name'] = [\n    'name' => t('Name'),\n    'description' => t(\"The name of the menu.\"),\n  ];\n  $info['tokens']['menu']['machine-name'] = [\n    'name' => t('Machine-readable name'),\n    'description' => t(\"The unique machine-readable name of the menu.\"),\n  ];\n  $info['tokens']['menu']['description'] = [\n    'name' => t('Description'),\n    'description' => t('The optional description of the menu.'),\n  ];\n  $info['tokens']['menu']['menu-link-count'] = [\n    'name' => t('Menu link count'),\n    'description' => t('The number of menu links belonging to the menu.'),\n  ];\n  $info['tokens']['menu']['edit-url'] = [\n    'name' => t('Edit URL'),\n    'description' => t(\"The URL of the menu's edit page.\"),\n  ];\n\n  $info['tokens']['menu-link']['menu'] = [\n    'name' => t('Menu'),\n    'description' => t('The menu of the menu link.'),\n    'type' => 'menu',\n  ];\n  $info['tokens']['menu-link']['edit-url'] = [\n    'name' => t('Edit URL'),\n    'description' => t(\"The URL of the menu link's edit page.\"),\n  ];\n\n  if (\\Drupal::moduleHandler()->moduleExists('node')) {\n    $info['tokens']['node']['menu-link'] = [\n      'name' => t('Menu link'),\n      'description' => t(\"The menu link for this node.\"),\n      'type' => 'menu-link',\n    ];\n  }\n\n  return $info;\n}\n\n/**\n * Proxy implementation of hook_tokens() on behalf of menu_ui.module.\n */\nfunction _menu_ui_tokens($type, $tokens, array $data, array $options, BubbleableMetadata $bubbleable_metadata) {\n  $replacements = [];\n\n  /** @var \\Drupal\\Core\\Menu\\MenuLinkManagerInterface $menu_link_manager */\n  $menu_link_manager = \\Drupal::service('plugin.manager.menu.link');\n\n  $url_options = ['absolute' => TRUE];\n  if (isset($options['langcode'])) {\n    $url_options['language'] = \\Drupal::languageManager()->getLanguage($options['langcode']);\n    $langcode = $options['langcode'];\n  }\n  else {\n    $langcode = NULL;\n  }\n\n  // Node tokens.\n  if ($type == 'node' && !empty($data['node'])) {\n    /** @var \\Drupal\\node\\NodeInterface $node */\n    $node = $data['node'];\n\n    foreach ($tokens as $name => $original) {\n      switch ($name) {\n        case 'menu-link':\n          // On node-form save we populate a calculated field with a menu_link\n          // references.\n          // @see token_node_menu_link_submit()\n          if ($node->getFieldDefinition('menu_link') && $menu_link = $node->menu_link->entity) {\n            /** @var \\Drupal\\menu_link_content\\MenuLinkContentInterface $menu_link */\n            $replacements[$original] = $menu_link->getTitle();\n          }\n          else {\n            $url = $node->toUrl();\n            if ($links = $menu_link_manager->loadLinksByRoute($url->getRouteName(), $url->getRouteParameters())) {\n              $link = _token_menu_link_best_match($node, $links);\n              $replacements[$original] = token_menu_link_translated_title($link, $langcode);\n            }\n          }\n          break;\n      }\n\n      // Chained token relationships.\n      if ($menu_tokens = \\Drupal::token()->findWithPrefix($tokens, 'menu-link')) {\n        if ($node->getFieldDefinition('menu_link') && $menu_link = $node->menu_link->entity) {\n          /** @var \\Drupal\\menu_link_content\\MenuLinkContentInterface $menu_link */\n          $replacements += \\Drupal::token()->generate('menu-link', $menu_tokens, ['menu-link' => $menu_link], $options, $bubbleable_metadata);\n        }\n        else {\n          $url = $node->toUrl();\n          if ($links = $menu_link_manager->loadLinksByRoute($url->getRouteName(), $url->getRouteParameters())) {\n            $link = _token_menu_link_best_match($node, $links);\n            $replacements += \\Drupal::token()->generate('menu-link', $menu_tokens, ['menu-link' => $link], $options, $bubbleable_metadata);\n          }\n        }\n      }\n    }\n  }\n\n  // Menu link tokens.\n  if ($type == 'menu-link' && !empty($data['menu-link'])) {\n    /** @var \\Drupal\\Core\\Menu\\MenuLinkInterface $link */\n    $link = $data['menu-link'];\n\n    if ($link instanceof MenuLinkContentInterface) {\n      $link = $menu_link_manager->createInstance($link->getPluginId());\n    }\n\n    foreach ($tokens as $name => $original) {\n      switch ($name) {\n        case 'menu':\n          if ($menu = Menu::load($link->getMenuName())) {\n            $replacements[$original] = $menu->label();\n          }\n          break;\n\n        case 'edit-url':\n          $route = $link->getEditRoute();\n          if ($route) {\n            $result = $link->getEditRoute()->setOptions($url_options)->toString(TRUE);\n            $bubbleable_metadata->addCacheableDependency($result);\n            $replacements[$original] = $result->getGeneratedUrl();\n          }\n          break;\n      }\n    }\n\n    // Chained token relationships.\n    if (($menu_tokens = \\Drupal::token()->findWithPrefix($tokens, 'menu')) && $menu = Menu::load($link->getMenuName())) {\n      $replacements += \\Drupal::token()->generate('menu', $menu_tokens, ['menu' => $menu], $options, $bubbleable_metadata);\n    }\n  }\n\n  // Menu tokens.\n  if ($type == 'menu' && !empty($data['menu'])) {\n    /** @var \\Drupal\\system\\MenuInterface $menu */\n    $menu = $data['menu'];\n\n    foreach ($tokens as $name => $original) {\n      switch ($name) {\n        case 'name':\n          $replacements[$original] = $menu->label();\n          break;\n\n        case 'machine-name':\n          $replacements[$original] = $menu->id();\n          break;\n\n        case 'description':\n          $replacements[$original] = $menu->getDescription();\n          break;\n\n        case 'menu-link-count':\n          $replacements[$original] = $menu_link_manager->countMenuLinks($menu->id());\n          break;\n\n        case 'edit-url':\n          $result = Url::fromRoute('entity.menu.edit_form', ['menu' => $menu->id()], $url_options)->toString(TRUE);\n          $bubbleable_metadata->addCacheableDependency($result);\n          $replacements[$original] = $result->getGeneratedUrl();\n          break;\n      }\n    }\n  }\n\n  return $replacements;\n}\n\n/**\n * Returns a best matched link for a given node.\n *\n * If the url exists in multiple menus, default to the one set on the node\n * itself.\n *\n * @param \\Drupal\\node\\NodeInterface $node\n *   The node to look up the default menu settings from.\n * @param array $links\n *   An array of instances keyed by plugin ID.\n *\n * @return \\Drupal\\Core\\Menu\\MenuLinkInterface\n *   A Link instance.\n */\nfunction _token_menu_link_best_match(NodeInterface $node, array $links) {\n  // Get the menu ui defaults so we can determine what menu was\n  // selected for this node. This ensures that if the node was added\n  // to the menu via the node UI, we use that as a default. If it\n  // was not added via the node UI then grab the first in the\n  // retrieved array.\n  $defaults = menu_ui_get_menu_link_defaults($node);\n  if (isset($defaults['id']) && isset($links[$defaults['id']])) {\n    $link = $links[$defaults['id']];\n  }\n  else {\n    $link = reset($links);\n  }\n  return $link;\n}\n\n/**\n * Proxy implementation of hook_token_info_alter() on behalf of field.module.\n *\n * We use hook_token_info_alter() rather than hook_token_info() as other\n * modules may already have defined some field tokens.\n */\nfunction _field_token_info_alter(&$info) {\n  $type_info = \\Drupal::service('plugin.manager.field.field_type')->getDefinitions();\n\n  // Attach field tokens to their respecitve entity tokens.\n  foreach (\\Drupal::entityTypeManager()->getDefinitions() as $entity_type_id => $entity_type) {\n    if (!$entity_type->entityClassImplements(ContentEntityInterface::class)) {\n      continue;\n    }\n\n    // Make sure a token type exists for this entity.\n    $token_type = \\Drupal::service('token.entity_mapper')->getTokenTypeForEntityType($entity_type_id);\n    if (empty($token_type) || !isset($info['types'][$token_type])) {\n      continue;\n    }\n\n    $fields = \\Drupal::service('entity_field.manager')->getFieldStorageDefinitions($entity_type_id);\n    foreach ($fields as $field_name => $field) {\n      /** @var \\Drupal\\field\\FieldStorageConfigInterface $field */\n\n      // Ensure the token implements FieldStorageConfigInterface or is defined\n      // in token module.\n      $provider = '';\n      if (isset($info['types'][$token_type]['module'])) {\n        $provider = $info['types'][$token_type]['module'];\n      }\n      if (!($field instanceof FieldStorageConfigInterface) && $provider != 'token') {\n        continue;\n      }\n\n      // If a token already exists for this field, then don't add it.\n      if (isset($info['tokens'][$token_type][$field_name])) {\n        continue;\n      }\n\n      if ($token_type == 'comment' && $field_name == 'comment_body') {\n        // Core provides the comment field as [comment:body].\n        continue;\n      }\n\n      // Do not define the token type if the field has no properties.\n      if (!$field->getPropertyDefinitions()) {\n        continue;\n      }\n\n      // Generate a description for the token.\n      $labels = _token_field_label($entity_type_id, $field_name);\n      $label = array_shift($labels);\n      $params['@type'] = $type_info[$field->getType()]['label'];\n      if (!empty($labels)) {\n        $params['%labels'] = implode(', ', $labels);\n        $description = t('@type field. Also known as %labels.', $params);\n      }\n      else {\n        $description = t('@type field.', $params);\n      }\n\n      $cardinality = $field->getCardinality();\n      $cardinality = ($cardinality == FieldStorageDefinitionInterface::CARDINALITY_UNLIMITED || $cardinality > 3) ? 3 : $cardinality;\n      $field_token_name = $token_type . '-' . $field_name;\n      $info['tokens'][$token_type][$field_name] = [\n        'name' => Html::escape($label),\n        'description' => $description,\n        'module' => 'token',\n        // For multivalue fields the field token is a list type.\n        'type' => $cardinality > 1 ? \"list<$field_token_name>\" : $field_token_name,\n      ];\n\n      // Field token type.\n      $info['types'][$field_token_name] = [\n        'name' => Html::escape($label),\n        'description' => t('@label tokens.', ['@label' => Html::escape($label)]),\n        'needs-data' => $field_token_name,\n        'nested' => TRUE,\n      ];\n      // Field list token type.\n      if ($cardinality > 1) {\n        $info['types'][\"list<$field_token_name>\"] = [\n          'name' => t('List of @type values', ['@type' => Html::escape($label)]),\n          'description' => t('Tokens for lists of @type values.', ['@type' => Html::escape($label)]),\n          'needs-data' => \"list<$field_token_name>\",\n          'nested' => TRUE,\n        ];\n      }\n\n      // Show a different token for each field delta.\n      if ($cardinality > 1) {\n        for ($delta = 0; $delta < $cardinality; $delta++) {\n          $info['tokens'][\"list<$field_token_name>\"][$delta] = [\n            'name' => t('@type type with delta @delta', ['@type' => Html::escape($label), '@delta' => $delta]),\n            'module' => 'token',\n            'type' => $field_token_name,\n          ];\n        }\n      }\n\n      // Property tokens.\n      foreach ($field->getPropertyDefinitions() as $property => $property_definition) {\n        if (is_subclass_of($property_definition->getClass(), 'Drupal\\Core\\TypedData\\PrimitiveInterface')) {\n          $info['tokens'][$field_token_name][$property] = [\n            'name' => $property_definition->getLabel(),\n            'description' => $property_definition->getDescription(),\n            'module' => 'token',\n          ];\n        }\n        elseif (($property_definition instanceof DataReferenceDefinitionInterface) && ($property_definition->getTargetDefinition() instanceof EntityDataDefinitionInterface)) {\n          $referenced_entity_type = $property_definition->getTargetDefinition()->getEntityTypeId();\n          $referenced_token_type = \\Drupal::service('token.entity_mapper')->getTokenTypeForEntityType($referenced_entity_type);\n          $info['tokens'][$field_token_name][$property] = [\n            'name' => $property_definition->getLabel(),\n            'description' => $property_definition->getDescription(),\n            'module' => 'token',\n            'type' => $referenced_token_type,\n          ];\n        }\n      }\n      // Provide image_with_image_style tokens for image fields.\n      if ($field->getType() == 'image') {\n        $image_styles = image_style_options(FALSE);\n        foreach ($image_styles as $style => $description) {\n          $info['tokens'][$field_token_name][$style] = [\n            'name' => $description,\n            'description' => t('Represents the image in the given image style.'),\n            'type' => 'image_with_image_style',\n          ];\n        }\n      }\n      // Provide format token for datetime fields.\n      $date_fields = ['datetime', 'timestamp', 'created', 'changed'];\n      if (in_array($field->getType(), $date_fields, TRUE)) {\n        $info['tokens'][$field_token_name]['date'] = $info['tokens'][$field_token_name]['value'];\n        $info['tokens'][$field_token_name]['date']['name'] .= ' ' . t('format');\n        $info['tokens'][$field_token_name]['date']['type'] = 'date';\n      }\n      if ($field->getType() == 'daterange' || $field->getType() == 'date_recur') {\n        $info['tokens'][$field_token_name]['start_date'] = $info['tokens'][$field_token_name]['value'];\n        $info['tokens'][$field_token_name]['start_date']['name'] .= ' ' . t('format');\n        $info['tokens'][$field_token_name]['start_date']['type'] = 'date';\n        $info['tokens'][$field_token_name]['end_date'] = $info['tokens'][$field_token_name]['end_value'];\n        $info['tokens'][$field_token_name]['end_date']['name'] .= ' ' . t('format');\n        $info['tokens'][$field_token_name]['end_date']['type'] = 'date';\n      }\n    }\n  }\n}\n\n/**\n * Returns the label of a certain field.\n *\n * Therefore it looks up in all bundles to find the most used instance.\n *\n * Based on views_entity_field_label().\n *\n * @todo Resync this method with views_entity_field_label().\n */\nfunction _token_field_label($entity_type, $field_name) {\n  $labels = [];\n  // Count the amount of instances per label per field.\n  foreach (array_keys(\\Drupal::service('entity_type.bundle.info')->getBundleInfo($entity_type)) as $bundle) {\n    $bundle_instances = \\Drupal::service('entity_field.manager')->getFieldDefinitions($entity_type, $bundle);\n    if (isset($bundle_instances[$field_name])) {\n      $instance = $bundle_instances[$field_name];\n      $label = (string) $instance->getLabel();\n      $labels[$label] = isset($labels[$label]) ? ++$labels[$label] : 1;\n    }\n  }\n\n  if (empty($labels)) {\n    return [$field_name];\n  }\n\n  // Sort the field labels by it most used label and return the labels.\n  arsort($labels);\n  return array_keys($labels);\n}\n\n/**\n * Proxy implementation of hook_tokens() on behalf of field.module.\n */\nfunction _field_tokens($type, $tokens, array $data, array $options, BubbleableMetadata $bubbleable_metadata) {\n  $replacements = [];\n\n  $langcode = isset($options['langcode']) ? $options['langcode'] : NULL;\n  // Entity tokens.\n  if ($type == 'entity' && !empty($data['entity_type']) && !empty($data['entity']) && !empty($data['token_type'])) {\n    /* @var \\Drupal\\Core\\Entity\\ContentEntityInterface $entity */\n    $entity = $data['entity'];\n    if (!($entity instanceof ContentEntityInterface)) {\n      return $replacements;\n    }\n\n    if (!isset($options['langcode'])) {\n      // Set the active language in $options, so that it is passed along.\n      $langcode = $options['langcode'] = $entity->language()->getId();\n    }\n    // Obtain the entity with the correct language.\n    $entity = \\Drupal::service('entity.repository')->getTranslationFromContext($entity, $langcode);\n\n    foreach ($tokens as $name => $original) {\n      // For the [entity:field_name] token.\n      if (strpos($name, ':') === FALSE) {\n        $field_name = $name;\n        $token_name = $name;\n      }\n      // For [entity:field_name:0], [entity:field_name:0:value] and\n      // [entity:field_name:value] tokens.\n      else {\n        [$field_name, $delta] = explode(':', $name, 2);\n        if (!is_numeric($delta)) {\n          unset($delta);\n        }\n        $token_name = $field_name;\n      }\n      // Ensure the entity has the requested field and that the token for it is\n      // defined by token.module.\n      if (!$entity->hasField($field_name) || \\Drupal::service('token.module_provider')->getTokenModule($data['token_type'], $token_name) != 'token') {\n        continue;\n      }\n\n      $display_options = 'token';\n      // Do not continue if the field is empty.\n      if ($entity->get($field_name)->isEmpty()) {\n        continue;\n      }\n      // Handle [entity:field_name] and [entity:field_name:0] tokens.\n      if ($field_name === $name || isset($delta)) {\n        $view_display = token_get_token_view_display($entity);\n        if (!$view_display) {\n          // We don't have the token view display and should fall back on\n          // default formatters. If the field has specified a specific formatter\n          // to be used by default with tokens, use that, otherwise use the\n          // default formatter.\n          /** @var \\Drupal\\Core\\Field\\FieldTypePluginManager $field_type_manager */\n          $field_type_manager = \\Drupal::service('plugin.manager.field.field_type');\n          $field_type_definition = $field_type_manager->getDefinition($entity->getFieldDefinition($field_name)->getType());\n          if (empty($field_type_definition['default_token_formatter']) && empty($field_type_definition['default_formatter'])) {\n            continue;\n          }\n          $display_options = [\n            'type' => !empty($field_type_definition['default_token_formatter']) ? $field_type_definition['default_token_formatter'] : $field_type_definition['default_formatter'],\n            'label' => 'hidden',\n          ];\n        }\n\n        // Render only one delta.\n        if (isset($delta)) {\n          if ($field_delta = $entity->{$field_name}[$delta]) {\n            $field_output = $field_delta->view($display_options);\n          }\n          // If no such delta exists, let's not replace the token.\n          else {\n            continue;\n          }\n        }\n        // Render the whole field (with all deltas).\n        else {\n          $field_output = $entity->$field_name->view($display_options);\n          // If we are displaying all field items we need this #pre_render\n          // callback.\n          $field_output['#pre_render'][] = '\\Drupal\\token\\TokenFieldRender::preRender';\n        }\n        $field_output['#token_options'] = $options;\n        $replacements[$original] = \\Drupal::service('renderer')->renderPlain($field_output);\n      }\n      // Handle [entity:field_name:value] and [entity:field_name:0:value]\n      // tokens.\n      elseif ($field_tokens = \\Drupal::token()->findWithPrefix($tokens, $field_name)) {\n        // With multiple nested tokens for the same field name, this might\n        // match the same field multiple times. Filter out those that have\n        // already been replaced.\n        $field_tokens = array_filter($field_tokens, function ($token) use ($replacements) {\n          return !isset($replacements[$token]);\n        });\n\n        if ($field_tokens) {\n          $property_token_data = [\n            'field_property' => TRUE,\n            $data['entity_type'] . '-' . $field_name => $entity->$field_name,\n            'field_name' => $data['entity_type'] . '-' . $field_name,\n          ];\n          // The optimization above only works on the root level, if there is\n          // more than one nested field it would still replace all in every\n          // call. Replace them one by one instead, which is slightly slower\n          // but ensures that the number of replacements do not grow\n          // exponentialy.\n          foreach ($field_tokens as $field_token_key => $field_token_value) {\n            $replacements += \\Drupal::token()->generate($field_name, [$field_token_key => $field_token_value], $property_token_data, $options, $bubbleable_metadata);\n          }\n        }\n      }\n    }\n\n    // Remove the cloned object from memory.\n    unset($entity);\n  }\n  elseif (!empty($data['field_property'])) {\n    foreach ($tokens as $token => $original) {\n      $filtered_tokens = $tokens;\n      $delta = 0;\n      $parts = explode(':', $token);\n      if (is_numeric($parts[0])) {\n        if (count($parts) > 1) {\n          $delta = $parts[0];\n          $property_name = $parts[1];\n          // Pre-filter the tokens to select those with the correct delta.\n          $filtered_tokens = \\Drupal::token()->findWithPrefix($tokens, $delta);\n          // Remove the delta to unify between having and not having one.\n          array_shift($parts);\n        }\n        else {\n          // Token is fieldname:delta, which is invalid.\n          continue;\n        }\n      }\n      else {\n        $property_name = $parts[0];\n      }\n\n      if (isset($data[$data['field_name']][$delta])) {\n        $field_item = $data[$data['field_name']][$delta];\n      }\n      else {\n        // The field has no such delta, abort replacement.\n        continue;\n      }\n\n      if (isset($field_item->$property_name) && ($field_item->$property_name instanceof FieldableEntityInterface)) {\n        // Entity reference field.\n        $entity = $field_item->$property_name;\n        // Obtain the referenced entity with the correct language.\n        $entity = \\Drupal::service('entity.repository')->getTranslationFromContext($entity, $langcode);\n\n        if (count($parts) > 1) {\n          $field_tokens = \\Drupal::token()->findWithPrefix($filtered_tokens, $property_name);\n          $token_type = \\Drupal::service('token.entity_mapper')->getTokenTypeForEntityType($entity->getEntityTypeId(), TRUE);\n          $replacements += \\Drupal::token()->generate($token_type, $field_tokens, [$token_type => $entity], $options, $bubbleable_metadata);\n        }\n        else {\n          $replacements[$original] = $entity->label();\n        }\n      }\n      elseif (($field_item->getFieldDefinition()->getType() == 'image') && ($style = ImageStyle::load($property_name))) {\n        // Handle [node:field_name:image_style:property] tokens and multivalued\n        // [node:field_name:delta:image_style:property] tokens. If the token is\n        // of the form [node:field_name:image_style], provide the URL as a\n        // replacement.\n        $property_name = isset($parts[1]) ? $parts[1] : 'url';\n        $entity = $field_item->entity;\n        if (!empty($field_item->entity)) {\n          $original_uri = $entity->getFileUri();\n\n          // Only generate the image derivative if needed.\n          if ($property_name === 'width' || $property_name === 'height') {\n            $dimensions = [\n              'width' => $field_item->width,\n              'height' => $field_item->height,\n            ];\n            $style->transformDimensions($dimensions, $original_uri);\n            $replacements[$original] = $dimensions[$property_name];\n          }\n          elseif ($property_name === 'uri') {\n            $replacements[$original] = $style->buildUri($original_uri);\n          }\n          elseif ($property_name === 'url') {\n            $replacements[$original] = $style->buildUrl($original_uri);\n          }\n          else {\n            // Generate the image derivative, if it doesn't already exist.\n            $derivative_uri = $style->buildUri($original_uri);\n            $derivative_exists = TRUE;\n            if (!file_exists($derivative_uri)) {\n              $derivative_exists = $style->createDerivative($original_uri, $derivative_uri);\n            }\n            if ($derivative_exists) {\n              $image = \\Drupal::service('image.factory')->get($derivative_uri);\n              // Provide the replacement.\n              switch ($property_name) {\n                case 'mimetype':\n                  $replacements[$original] = $image->getMimeType();\n                  break;\n\n                case 'filesize':\n                  $replacements[$original] = $image->getFileSize();\n                  break;\n              }\n            }\n          }\n        }\n      }\n      elseif (in_array($field_item->getFieldDefinition()->getType(), ['datetime', 'daterange', 'date_recur']) && in_array($property_name, ['date', 'start_date', 'end_date']) && !empty($field_item->$property_name)) {\n        $timestamp = $field_item->{$property_name}->getTimestamp();\n        // If the token is an exact match for the property or the delta and the\n        // property, use the timestamp as-is.\n        if ($property_name == $token || \"$delta:$property_name\" == $token) {\n          $replacements[$original] = $timestamp;\n        }\n        else {\n          $date_tokens = \\Drupal::token()->findWithPrefix($filtered_tokens, $property_name);\n          $replacements += \\Drupal::token()->generate('date', $date_tokens, ['date' => $timestamp], $options, $bubbleable_metadata);\n        }\n      }\n      elseif (in_array($field_item->getFieldDefinition()->getType(), ['timestamp', 'created', 'changed']) && in_array($property_name, ['date'])) {\n        $timestamp = $field_item->value;\n        if ($property_name == $token || \"$delta:$property_name\" == $token) {\n          $replacements[$original] = $timestamp;\n        }\n        else {\n          $field_tokens = \\Drupal::token()->findWithPrefix($filtered_tokens, $property_name);\n          $replacements += \\Drupal::token()->generate('date', $field_tokens, ['date' => $timestamp], $options, $bubbleable_metadata);\n        }\n      }\n      else {\n        $replacements[$original] = $field_item->$property_name;\n      }\n    }\n  }\n  return $replacements;\n}\n\n/**\n * Returns the token view display for the given entity if enabled.\n *\n * @param \\Drupal\\Core\\Entity\\EntityInterface $entity\n *   The entity.\n *\n * @return \\Drupal\\Core\\Entity\\Display\\EntityViewDisplayInterface|null\n *   The view display or null.\n */\nfunction token_get_token_view_display(EntityInterface $entity) {\n  $view_mode_name = $entity->getEntityTypeId() . '.' . $entity->bundle() . '.token';\n  $view_display = \\Drupal::entityTypeManager()->getStorage('entity_view_display')->load($view_mode_name);\n  return ($view_display && $view_display->status()) ? $view_display : NULL;\n}\n"
    },
    {
        "path": "token.links.task.yml",
        "contents": "token.devel_entities:\n  class: \\Drupal\\Core\\Menu\\LocalTaskDefault\n  deriver: \\Drupal\\token\\Plugin\\Derivative\\DevelLocalTask\n"
    },
    {
        "path": "phpstan.neon",
        "contents": "includes:\n  - phar://phpstan.phar/conf/bleedingEdge.neon\n\nparameters:\n  level: 1\n  ignoreErrors:\n    # new static() is a best practice in Drupal, so we cannot fix that.\n    - \"#^Unsafe usage of new static#\"\n"
    },
    {
        "path": "token.pages.inc",
        "contents": "<?php\n\n/**\n * @file\n * User page callbacks for the token module.\n */\nuse Drupal\\Component\\Serialization\\Json;\nuse Drupal\\Component\\Utility\\DiffArray;\nuse Drupal\\Core\\Link;\nuse Drupal\\Core\\Url;\n\n/**\n * Theme a link to a token tree shown as a dialog.\n */\nfunction template_preprocess_token_tree_link(&$variables) {\n  if (empty($variables['text'])) {\n    $variables['text'] = t('Browse available tokens.');\n  }\n\n  $variables['#attached']['library'][] = 'core/drupal.dialog.ajax';\n  $variables['#attached']['library'][] = 'token/token';\n  $variables['options']['attributes']['class'][] = 'token-dialog';\n  $variables['options']['attributes']['class'][] = 'use-ajax';\n\n  $tree_variables = [\n    'token_types' => [],\n    'global_types' => TRUE,\n    'click_insert' => TRUE,\n    'show_restricted' => FALSE,\n    'show_nested' => FALSE,\n    'recursion_limit' => 3,\n  ];\n  $query_options = array_intersect_key($variables, $tree_variables);\n  $query_options = DiffArray::diffAssocRecursive($query_options, $tree_variables);\n  if (!isset($variables['options']['query']['options'])) {\n    $variables['options']['query']['options'] = [];\n  }\n  $variables['options']['query']['options'] += $query_options;\n\n  // Because PHP converts query strings with arrays into a different syntax on\n  // the next request, the options have to be encoded with JSON in the query\n  // string so that we can reliably decode it for token comparison.\n  $variables['options']['query']['options'] = Json::encode($variables['options']['query']['options']);\n\n  // Set the token tree to open in a separate window.\n  $variables['options']['attributes'] += [\n    'data-dialog-type' => 'dialog',\n    'data-dialog-options' => json_encode([\n      'dialogClass' => 'token-tree-dialog',\n      'width' => 600,\n      'height' => 400,\n      'position' => ['my' => 'right bottom', 'at' => 'right-10 bottom-10'],\n      'draggable' => TRUE,\n      'autoResize' => FALSE,\n    ]),\n  ];\n\n  $variables['link'] = Link::createFromRoute($variables['text'], 'token.tree', [], $variables['options'])->toRenderable();\n  $variables['url'] = new Url('token.tree', [], $variables['options']);\n  $variables['attributes'] = $variables['options']['attributes'];\n}\n"
    },
    {
        "path": "drush.services.yml",
        "contents": "services:\n  token.commands:\n    class: Drupal\\token\\Drush\\Commands\\TokenCommands\n    arguments:\n      - '@module_handler'\n    tags:\n      -  { name: drush.command }\n"
    },
    {
        "path": "README.md",
        "contents": "CONTENTS OF THIS FILE\n---------------------\n\n * Introduction\n * Recommended modules\n * Installation\n * Configuration\n * Troubleshooting\n * Maintainers\n\nINTRODUCTION\n------------\n \n Provides common and resuable token UI elements and missing core tokens.\n\n * For a full description of the module, visit the project page:\n   https://drupal.org/project/token\n\n * To submit bug reports and feature suggestions, or to track changes:\n   https://drupal.org/project/issues/token\n\nRECOMMENDED MODULES\n-------------------\n\n * No extra module is required.\n\nINSTALLATION\n------------\n\n * Install as usual, see\n   https://www.drupal.org/docs/8/extending-drupal-8/installing-contributed-modules-find-import-enable-configure-drupal-8 for further\n   information.\n\nCONFIGURATION\n-------------\n\n * No configuration is needed.\n\nTROUBLESHOOTING\n---------------\n\n * Token module doesn't provide any visible functions to the user on its own, it\n   just provides token handling services for other modules.\n\n\nMAINTAINERS\n-----------\n\nCurrent maintainers:\n\n * Dave Reid (https://drupal.org/user/53892)\n * Sascha Grossenbacher (Berdir) (https://www.drupal.org/user/214652)\n"
    },
    {
        "path": "token.libraries.yml",
        "contents": "jquery.treeTable:\n  remote: 'http://plugins.jquery.com/treetable/'\n  version: 3.2.0\n  license:\n    name: MIT\n    url: https://github.com/ludo/jquery-treetable/blob/3.2.0/MIT-LICENSE.txt\n    gpl-compatible: true\n  js:\n    js/jquery.treetable.js: {}\n  css:\n    component:\n      css/jquery.treetable.css: {}\n      css/token.treetable.theme.css: {}\n  dependencies:\n    - core/jquery\ntoken:\n  version: VERSION\n  js:\n    js/token.js: {}\n  css:\n    component:\n      css/token.css: {}\n  dependencies:\n    - core/jquery\n    - core/drupal\n    - core/once\n    - token/jquery.treeTable\n"
    },
    {
        "path": ".gitlab-ci.yml",
        "contents": "################\n# DrupalCI GitLabCI template\n#\n# Gitlab-ci.yml to replicate DrupalCI testing for Contrib\n#\n# With thanks to:\n#   * The GitLab Acceleration Initiative participants\n#   * DrupalSpoons\n################\n\n################\n# Guidelines\n#\n# This template is designed to give any Contrib maintainer everything they need to test, without requiring modification. It is also designed to keep up to date with Core Development automatically through the use of include files that can be centrally maintained.\n#\n# However, you can modify this template if you have additional needs for your project.\n################\n\n################\n# Includes\n#\n# Additional configuration can be provided through includes.\n# One advantage of include files is that if they are updated upstream, the changes affect all pipelines using that include.\n#\n# Includes can be overridden by re-declaring anything provided in an include, here in gitlab-ci.yml\n# https://docs.gitlab.com/ee/ci/yaml/includes.html#override-included-configuration-values\n################\n\ninclude:\n  ################\n  # DrupalCI includes:\n  # As long as you include this, any future includes added by the Drupal Association will be accessible to your pipelines automatically.\n  # View these include files at https://git.drupalcode.org/project/gitlab_templates/\n  ################\n  - project: $_GITLAB_TEMPLATES_REPO\n    ref: $_GITLAB_TEMPLATES_REF\n    file:\n      - '/includes/include.drupalci.main.yml'\n      # EXPERIMENTAL: For Drupal 7, remove the above line and uncomment the below.\n      # - '/includes/include.drupalci.main-d7.yml'\n      - '/includes/include.drupalci.variables.yml'\n      - '/includes/include.drupalci.workflows.yml'\n\n################\n# Pipeline configuration variables\n#\n# These are the variables provided to the Run Pipeline form that a user may want to override.\n#\n# Docs at https://git.drupalcode.org/project/gitlab_templates/-/blob/1.0.x/includes/include.drupalci.variables.yml\n################\n# variables:\n#   SKIP_ESLINT: '1'\nvariables:\n  OPT_IN_TEST_PREVIOUS_MINOR: '1'\n  _PHPUNIT_CONCURRENT: 1\n\n###################################################################################\n#\n#                                        *\n#                                       /(\n#                                      ((((,\n#                                    /(((((((\n#                                   ((((((((((*\n#                                ,(((((((((((((((\n#                              ,(((((((((((((((((((\n#                            ((((((((((((((((((((((((*\n#                         *(((((((((((((((((((((((((((((\n#                       ((((((((((((((((((((((((((((((((((*\n#                    *((((((((((((((((((  .((((((((((((((((((\n#                  ((((((((((((((((((.       /(((((((((((((((((*\n#                /(((((((((((((((((            .(((((((((((((((((,\n#             ,((((((((((((((((((                 ((((((((((((((((((\n#           .((((((((((((((((((((                   .(((((((((((((((((\n#          (((((((((((((((((((((((                     ((((((((((((((((/\n#        (((((((((((((((((((((((((((/                    ,(((((((((((((((*\n#      .((((((((((((((/  /(((((((((((((.                   ,(((((((((((((((\n#     *((((((((((((((      ,(((((((((((((/                   *((((((((((((((.\n#    ((((((((((((((,          /(((((((((((((.                  ((((((((((((((,\n#   (((((((((((((/              ,(((((((((((((*                 ,(((((((((((((,\n#  *(((((((((((((                .(((((((((((((((                ,(((((((((((((\n#  ((((((((((((/                /((((((((((((((((((.              ,((((((((((((/\n# (((((((((((((              *(((((((((((((((((((((((*             *((((((((((((\n# (((((((((((((            ,(((((((((((((..(((((((((((((           *((((((((((((\n# ((((((((((((,          /((((((((((((*      /((((((((((((/         ((((((((((((\n# (((((((((((((        /((((((((((((/          (((((((((((((*       ((((((((((((\n# (((((((((((((/     /((((((((((((               ,((((((((((((,    *((((((((((((\n#  ((((((((((((((  *(((((((((((/                   *((((((((((((.  ((((((((((((/\n#  *((((((((((((((((((((((((((,                      /(((((((((((((((((((((((((\n#   (((((((((((((((((((((((((                         ((((((((((((((((((((((((,\n#   .(((((((((((((((((((((((/                         ,(((((((((((((((((((((((\n#     ((((((((((((((((((((((/                         ,(((((((((((((((((((((/\n#      *(((((((((((((((((((((                         (((((((((((((((((((((,\n#       ,(((((((((((((((((((((,                      ((((((((((((((((((((/\n#         ,(((((((((((((((((((((*                  /((((((((((((((((((((\n#            ((((((((((((((((((((((,           ,/((((((((((((((((((((,\n#              ,(((((((((((((((((((((((((((((((((((((((((((((((((((\n#                 .(((((((((((((((((((((((((((((((((((((((((((((\n#                     .((((((((((((((((((((((((((((((((((((,.\n#                          .,(((((((((((((((((((((((((.\n#\n###################################################################################\n"
    },
    {
        "path": "token.services.yml",
        "contents": "services:\n  token.entity_mapper:\n    class: Drupal\\token\\TokenEntityMapper\n    arguments: ['@entity_type.manager', '@module_handler']\n  token.tree_builder:\n    class: Drupal\\token\\TreeBuilder\n    arguments: ['@token', '@token.entity_mapper', '@cache.data', '@language_manager']\n  token.route_subscriber:\n    class: Drupal\\token\\Routing\\RouteSubscriber\n    arguments: ['@entity_type.manager', '@module_handler']\n    tags:\n      - { name: event_subscriber }\n  token.module_provider:\n    class: Drupal\\token\\TokenModuleProvider\n    arguments: ['@cache.default', '@lock', '@token']\n    tags:\n      - { name: needs_destruction }\n"
    },
    {
        "path": ".travis.yml",
        "contents": "language: php\ncache:\n  bundler: true\n  directories:\n    - $HOME/tmp/drush\n    - $HOME/.bundle\n  apt: true\n\nphp:\n  - 5.4\n  - 5.5\n\nenv:\n  - PATH=$PATH:/home/travis/.composer/vendor/bin\n\n# This will create the database\nmysql:\n  database: drupal\n  username: root\n  encoding: utf8\n\n# To be able to run a webbrowser\n# If we need anything more powerful\n# than e.g. phantomjs\nbefore_install:\n  - \"export DISPLAY=:99.0\"\n  - \"sh -e /etc/init.d/xvfb start\"\n\ninstall:\n  # Grab Drush\n  - composer global require drush/drush:dev-master --prefer-source\n  - cd /home/travis/.composer/vendor/drush/drush && cd -\n  # Make sure we don't fail when checking out projects\n  - echo -e \"Host github.com\\n\\tStrictHostKeyChecking no\\n\" >> ~/.ssh/config\n  # LAMP package installation (mysql is already started)\n  - sudo apt-get update\n  - sudo apt-get install apache2 libapache2-mod-fastcgi\n  # enable php-fpm, travis does not support any other method with php and apache\n  - sudo cp ~/.phpenv/versions/$(phpenv version-name)/etc/php-fpm.conf.default ~/.phpenv/versions/$(phpenv version-name)/etc/php-fpm.conf\n  - sudo a2enmod rewrite actions fastcgi alias\n  - echo \"cgi.fix_pathinfo = 1\" >> ~/.phpenv/versions/$(phpenv version-name)/etc/php.ini\n  - ~/.phpenv/versions/$(phpenv version-name)/sbin/php-fpm\n  # Make sure the apache root is in our wanted directory\n  - echo \"$(curl -fsSL https://gist.githubusercontent.com/nickveenhof/11386315/raw/b8abaf9304fe12b5cc7752d39c29c1edae8ac2e6/gistfile1.txt)\" | sed -e \"s,PATH,$TRAVIS_BUILD_DIR/../drupal,g\" | sudo tee /etc/apache2/sites-available/default > /dev/null\n  # Set sendmail so drush doesn't throw an error during site install.\n  - echo \"sendmail_path='true'\" >> `php --ini | grep \"Loaded Configuration\" | awk '{print $4}'`\n  # Forward the errors to the syslog so we can print them\n  - echo \"error_log=syslog\" >> `php --ini | grep \"Loaded Configuration\" | awk '{print $4}'`\n  # Get latest drupal 8 core\n  - cd $TRAVIS_BUILD_DIR/..\n  - git clone --depth 1 --branch 8.0.x http://git.drupal.org/project/drupal.git\n  # Restart apache and test it\n  - sudo service apache2 restart\n  - curl -v \"http://localhost\"\n  # Re-enable when trying to get CodeSniffer doesn't return a 403 anymore.\n  #- composer global require drupal/coder:\\>7\n\nbefore_script:\n  - cd $TRAVIS_BUILD_DIR/../drupal\n  # Update drupal core\n  - git pull origin 8.0.x\n  # Install the site\n  - drush -v site-install minimal --db-url=mysql://root:@localhost/drupal --yes\n  - drush en --yes simpletest\n  - drush cr\n  - phpenv rehash\n\nscript:\n  # go to our Drupal module directory\n  - mkdir $TRAVIS_BUILD_DIR/../drupal/modules/token\n  - cp -R $TRAVIS_BUILD_DIR/* $TRAVIS_BUILD_DIR/../drupal/modules/token/\n  # go to our Drupal main directory\n  - cd $TRAVIS_BUILD_DIR/../drupal\n  - ls -la $TRAVIS_BUILD_DIR/../drupal/sites/default\n  # Run the tests\n  - php core/scripts/run-tests.sh --verbose --color --concurrency 4 --php `which php` --url http://localhost \"token\" | tee /tmp/test.txt; TEST_EXIT=${PIPESTATUS[0]}\n  - echo $TEST_EXIT\n  # Check if we had fails in the run-tests.sh script\n  # Exit with the inverted value, because if there are no fails found, it will exit with 1 and for us that\\\n  # is a good thing so invert it to 0. Travis has some issues with the exclamation mark in front so we have to fiddle a\n  # bit.\n  # Also make the grep case insensitive and fail on run-tests.sh regular fails as well on fatal errors.\n  - TEST_OUTPUT=$(! egrep -i \"([0-9]+ fails)|(PHP Fatal error)|([0-9]+ exceptions)\" /tmp/test.txt > /dev/null)$?\n  - echo $TEST_OUTPUT\n  - cd $TRAVIS_BUILD_DIR/../drupal/core\n  - ./vendor/bin/phpunit --verbose --debug ../modules/token/; TEST_PHPUNIT=$?\n  - echo $TEST_PHPUNIT\n  # if the TEST_EXIT status is 0 AND the TEST_OUTPUT status is also 0 it means we succeeded, in all other cases we\n  # failed.\n  # Re-enable when trying to get CodeSniffer doesn't return a 403 anymore.\n  #- /home/travis/.composer/vendor/bin/phpcs --standard=/home/travis/.composer/vendor/drupal/coder/coder_sniffer/Drupal --extensions=php,inc,test,module,install --ignore=css/ $TRAVIS_BUILD_DIR/../drupal/modules/search_api\n  - php -i | grep 'php.ini'\n  - sudo cat /var/log/apache2/error.log\n  - sudo cat /var/log/syslog | grep 'php' | cat # Suppress grep exit status 1\n  # Exit the build\n  - if [ $TEST_EXIT -eq 0 ] && [ $TEST_OUTPUT -eq 0 ] && [ $TEST_PHPUNIT -eq 0 ]; then exit 0; else exit 1; fi\n"
    },
    {
        "path": "composer.json",
        "contents": "{\n  \"name\": \"drupal/token\",\n  \"type\": \"drupal-module\",\n  \"license\": \"GPL-2.0-or-later\",\n  \"description\": \"Provides a user interface for the Token API, some missing core tokens.\",\n  \"extra\": {\n    \"drush\": {\n      \"services\": {\n        \"drush.services.yml\": \">=9\"\n      }\n    }\n  }\n}\n"
    },
    {
        "path": "migrations/state/token.migrate_drupal.yml",
        "contents": "finished:\n  6:\n    token: token\n  7:\n    token: token\n"
    },
    {
        "path": "css/token.css",
        "contents": ".token-tree-dialog {\n  border: 1px solid #6b6b6b;\n  border-radius: 5px 5px 0 0;\n  box-shadow: 0 0 10px #6b6b6b;\n}\n\n.token-tree {\n  font-size: 0.85em;\n  margin-left: 19px;\n}\n\n.ui-dialog-content .token-tree {\n  margin-left: 0;\n}\n\n.token-tree td, .token-tree th {\n  padding-top: 0;\n  padding-bottom: 0;\n}\n\n.token-group {\n  font-weight: bold;\n}\n\n.js .token-group {\n  font-weight: normal;\n}\n\n/* Prevent the token columns from being wrapped. */\n.token-tree td.token-key {\n  white-space: nowrap;\n}\n"
    },
    {
        "path": "css/token.treetable.theme.css",
        "contents": "table.treetable {\n}\n\ntable.treetable caption {\n}\n\ntable.treetable thead {\n}\n\ntable.treetable thead tr th {\n}\n\ntable.treetable tbody tr td {\n  cursor: default;\n}\n\ntable.treetable span {\n  background-position: center left;\n  background-repeat: no-repeat;\n  padding: .2em 0 .2em 1.5em;\n}\n\ntable.treetable tr.collapsed span.indenter a {\n  background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAACXBIWXMAAAsTAAALEwEAmpwYAAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAAAgY0hSTQAAeiUAAICDAAD5/wAAgOkAAHUwAADqYAAAOpgAABdvkl/FRgAAAHlJREFUeNrcU1sNgDAQ6wgmcAM2MICGGlg1gJnNzWQcvwQGy1j4oUl/7tH0mpwzM7SgQyO+EZAUWh2MkkzSWhJwuRAlHYsJwEwyvs1gABDuzqoJcTw5qxaIJN0bgQRgIjnlmn1heSO5PE6Y2YXe+5Cr5+h++gs12AcAS6FS+7YOsj4AAAAASUVORK5CYII=);\n}\n\ntable.treetable tr.expanded span.indenter a {\n  background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAACXBIWXMAAAsTAAALEwEAmpwYAAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAAAgY0hSTQAAeiUAAICDAAD5/wAAgOkAAHUwAADqYAAAOpgAABdvkl/FRgAAAHFJREFUeNpi/P//PwMlgImBQsA44C6gvhfa29v3MzAwOODRc6CystIRbxi0t7fjDJjKykpGYrwwi1hxnLHQ3t7+jIGBQRJJ6HllZaUUKYEYRYBPOB0gBShKwKGA////48VtbW3/8clTnBIH3gCKkzJgAGvBX0dDm0sCAAAAAElFTkSuQmCC);\n}\n\ntable.treetable tr.branch {\n  background-color: #f9f9f9;\n}\n\ntable.treetable tr.selected {\n  background-color: #3875d7;\n  color: #fff;\n}\n\ntable.treetable tr span.indenter {\n  margin-left: -19px;\n}\ntable.treetable tr span.indenter a {\n  outline: none; /* Expander shows outline after upgrading to 3.0 (#141) */\n}\n\ntable.treetable tr.accept {\n  background-color: #a3bce4;\n  color: #fff\n}\n"
    },
    {
        "path": "css/jquery.treetable.css",
        "contents": "table.treetable span.indenter {\n  display: inline-block;\n  margin: 0;\n  padding: 0;\n  text-align: right;\n\n  /* Disable text selection of nodes (for better D&D UX) */\n  user-select: none;\n  -khtml-user-select: none;\n  -moz-user-select: none;\n  -o-user-select: none;\n  -webkit-user-select: none;\n\n  /* Force content-box box model for indenter (Bootstrap compatibility) */\n  -webkit-box-sizing: content-box;\n  -moz-box-sizing: content-box;\n  box-sizing: content-box;\n\n  width: 19px;\n}\n\ntable.treetable span.indenter a {\n  background-position: left center;\n  background-repeat: no-repeat;\n  display: inline-block;\n  text-decoration: none;\n  width: 19px;\n}\n"
    },
    {
        "path": "js/token.js",
        "contents": "\n(function ($, Drupal, drupalSettings) {\n\n  'use strict';\n\n  Drupal.behaviors.tokenTree = {\n    attach: function (context, settings) {\n      $(once('token-tree', 'table.token-tree', context)).treetable({ expandable: true});\n    }\n  };\n\n  Drupal.behaviors.tokenInsert = {\n    attach: function (context, settings) {\n      // Keep track of which textfield was last selected/focused.\n      $('textarea, input[type=\"text\"]', context).focus(function () {\n        drupalSettings.tokenFocusedField = this;\n      });\n\n      if (Drupal.CKEditor5Instances) {\n        Drupal.CKEditor5Instances.forEach(function (editor) {\n          editor.editing.view.document.on('change:isFocused', (event, data, isFocused) => {\n            if (isFocused) {\n              drupalSettings.tokenFocusedCkeditor5 = editor;\n            }\n          });\n        })\n      }\n\n      once('token-click-insert', '.token-click-insert .token-key', context).forEach(function (token) {\n        var newThis = $('<a href=\"javascript:void(0);\" title=\"' + Drupal.t('Insert this token into your form') + '\">' + $(token).html() + '</a>').click(function () {\n          var content = this.text;\n\n          // Always work in normal text areas that currently have focus.\n          if (drupalSettings.tokenFocusedField && (drupalSettings.tokenFocusedField.tokenDialogFocus || drupalSettings.tokenFocusedField.tokenHasFocus)) {\n            insertAtCursor(drupalSettings.tokenFocusedField, content);\n          }\n          // Direct tinyMCE support.\n          else if (typeof(tinyMCE) != 'undefined' && tinyMCE.activeEditor) {\n            tinyMCE.activeEditor.execCommand('mceInsertContent', false, content);\n          }\n          // Direct CKEditor support. Only works if the field currently has focus,\n          // which is unusual since the dialog is open.\n          else if (typeof(CKEDITOR) != 'undefined' && CKEDITOR.currentInstance) {\n            CKEDITOR.currentInstance.insertHtml(content);\n          }\n          // Direct CodeMirror support.\n          else if (typeof(CodeMirror) != 'undefined' && drupalSettings.tokenFocusedField && $(drupalSettings.tokenFocusedField).parents('.CodeMirror').length) {\n            var editor = $(drupalSettings.tokenFocusedField).parents('.CodeMirror')[0].CodeMirror;\n            editor.replaceSelection(content);\n            editor.focus();\n          }\n          // WYSIWYG support, should work in all editors if available.\n          else if (Drupal.wysiwyg && Drupal.wysiwyg.activeId) {\n            Drupal.wysiwyg.instances[Drupal.wysiwyg.activeId].insert(content)\n          }\n          // CKeditor module support.\n          else if (typeof(CKEDITOR) != 'undefined' && typeof(Drupal.ckeditorActiveId) != 'undefined') {\n            CKEDITOR.instances[Drupal.ckeditorActiveId].insertHtml(content);\n          }\n          else if (drupalSettings.tokenFocusedField) {\n            insertAtCursor(drupalSettings.tokenFocusedField, content);\n          }\n          else if (drupalSettings.tokenFocusedCkeditor5) {\n            const editor = drupalSettings.tokenFocusedCkeditor5;\n            editor.model.change((writer) => {\n              writer.insertText(\n                  content,\n                  editor.model.document.selection.getFirstPosition(),\n              );\n            })\n          }\n          else {\n            alert(Drupal.t('First click a text field to insert your tokens into.'));\n          }\n\n          return false;\n        });\n        $(token).html(newThis);\n      });\n\n      function insertAtCursor(editor, content) {\n        // Record the current scroll position.\n        var scroll = editor.scrollTop;\n\n        // IE support.\n        if (document.selection) {\n          editor.focus();\n          var sel = document.selection.createRange();\n          sel.text = content;\n        }\n\n        // Mozilla/Firefox/Netscape 7+ support.\n        else if (editor.selectionStart || editor.selectionStart == '0') {\n          var startPos = editor.selectionStart;\n          var endPos = editor.selectionEnd;\n          editor.value = editor.value.substring(0, startPos) + content + editor.value.substring(endPos, editor.value.length);\n        }\n\n        // Fallback, just add to the end of the content.\n        else {\n          editor.value += content;\n        }\n\n        // Ensure the textarea does not unexpectedly scroll.\n        editor.scrollTop = scroll;\n      }\n    }\n  };\n\n})(jQuery, Drupal, drupalSettings);\n"
    },
    {
        "path": "js/jquery.treetable.js",
        "contents": "/*\n * jQuery treetable Plugin 3.2.0\n * http://ludo.cubicphuse.nl/jquery-treetable\n *\n * Copyright 2013, Ludo van den Boom\n * Dual licensed under the MIT or GPL Version 2 licenses.\n */\n(function($) {\n  var Node, Tree, methods;\n\n  Node = (function() {\n    function Node(row, tree, settings) {\n      var parentId;\n\n      this.row = row;\n      this.tree = tree;\n      this.settings = settings;\n\n      // TODO Ensure id/parentId is always a string (not int)\n      this.id = this.row.data(this.settings.nodeIdAttr);\n\n      // TODO Move this to a setParentId function?\n      parentId = this.row.data(this.settings.parentIdAttr);\n      if (parentId != null && parentId !== \"\") {\n        this.parentId = parentId;\n      }\n\n      this.treeCell = $(this.row.children(this.settings.columnElType)[this.settings.column]);\n      this.expander = $(this.settings.expanderTemplate);\n      this.indenter = $(this.settings.indenterTemplate);\n      this.children = [];\n      this.initialized = false;\n      this.treeCell.prepend(this.indenter);\n    }\n\n    Node.prototype.addChild = function(child) {\n      return this.children.push(child);\n    };\n\n    Node.prototype.ancestors = function() {\n      var ancestors, node;\n      node = this;\n      ancestors = [];\n      while (node = node.parentNode()) {\n        ancestors.push(node);\n      }\n      return ancestors;\n    };\n\n    Node.prototype.collapse = function() {\n      if (this.collapsed()) {\n        return this;\n      }\n\n      this.row.removeClass(\"expanded\").addClass(\"collapsed\");\n\n      this._hideChildren();\n      this.expander.attr(\"title\", this.settings.stringExpand);\n\n      if (this.initialized && this.settings.onNodeCollapse != null) {\n        this.settings.onNodeCollapse.apply(this);\n      }\n\n      return this;\n    };\n\n    Node.prototype.collapsed = function() {\n      return this.row.hasClass(\"collapsed\");\n    };\n\n    // TODO destroy: remove event handlers, expander, indenter, etc.\n\n    Node.prototype.expand = function() {\n      if (this.expanded()) {\n        return this;\n      }\n\n      this.row.removeClass(\"collapsed\").addClass(\"expanded\");\n\n      if (this.initialized && this.settings.onNodeExpand != null) {\n        this.settings.onNodeExpand.apply(this);\n      }\n\n      if ($(this.row).is(\":visible\")) {\n        this._showChildren();\n      }\n\n      this.expander.attr(\"title\", this.settings.stringCollapse);\n\n      return this;\n    };\n\n    Node.prototype.expanded = function() {\n      return this.row.hasClass(\"expanded\");\n    };\n\n    Node.prototype.hide = function() {\n      this._hideChildren();\n      this.row.hide();\n      return this;\n    };\n\n    Node.prototype.isBranchNode = function() {\n      if(this.children.length > 0 || this.row.data(this.settings.branchAttr) === true) {\n        return true;\n      } else {\n        return false;\n      }\n    };\n\n    Node.prototype.updateBranchLeafClass = function(){\n      this.row.removeClass('branch');\n      this.row.removeClass('leaf');\n      this.row.addClass(this.isBranchNode() ? 'branch' : 'leaf');\n    };\n\n    Node.prototype.level = function() {\n      return this.ancestors().length;\n    };\n\n    Node.prototype.parentNode = function() {\n      if (this.parentId != null) {\n        return this.tree[this.parentId];\n      } else {\n        return null;\n      }\n    };\n\n    Node.prototype.removeChild = function(child) {\n      var i = $.inArray(child, this.children);\n      return this.children.splice(i, 1)\n    };\n\n    Node.prototype.render = function() {\n      var handler,\n          settings = this.settings,\n          target;\n\n      if (settings.expandable === true && this.isBranchNode()) {\n        handler = function(e) {\n          $(this).parents(\"table\").treetable(\"node\", $(this).parents(\"tr\").data(settings.nodeIdAttr)).toggle();\n          return e.preventDefault();\n        };\n\n        this.indenter.html(this.expander);\n        target = settings.clickableNodeNames === true ? this.treeCell : this.expander;\n\n        target.off(\"click.treetable\").on(\"click.treetable\", handler);\n        target.off(\"keydown.treetable\").on(\"keydown.treetable\", function(e) {\n          if (e.keyCode == 13) {\n            handler.apply(this, [e]);\n          }\n        });\n      }\n\n      this.indenter[0].style.paddingLeft = \"\" + (this.level() * settings.indent) + \"px\";\n\n      return this;\n    };\n\n    Node.prototype.reveal = function() {\n      if (this.parentId != null) {\n        this.parentNode().reveal();\n      }\n      return this.expand();\n    };\n\n    Node.prototype.setParent = function(node) {\n      if (this.parentId != null) {\n        this.tree[this.parentId].removeChild(this);\n      }\n      this.parentId = node.id;\n      this.row.data(this.settings.parentIdAttr, node.id);\n      return node.addChild(this);\n    };\n\n    Node.prototype.show = function() {\n      if (!this.initialized) {\n        this._initialize();\n      }\n      this.row.show();\n      if (this.expanded()) {\n        this._showChildren();\n      }\n      return this;\n    };\n\n    Node.prototype.toggle = function() {\n      if (this.expanded()) {\n        this.collapse();\n      } else {\n        this.expand();\n      }\n      return this;\n    };\n\n    Node.prototype._hideChildren = function() {\n      var child, _i, _len, _ref, _results;\n      _ref = this.children;\n      _results = [];\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        child = _ref[_i];\n        _results.push(child.hide());\n      }\n      return _results;\n    };\n\n    Node.prototype._initialize = function() {\n      var settings = this.settings;\n\n      this.render();\n\n      if (settings.expandable === true && settings.initialState === \"collapsed\") {\n        this.collapse();\n      } else {\n        this.expand();\n      }\n\n      if (settings.onNodeInitialized != null) {\n        settings.onNodeInitialized.apply(this);\n      }\n\n      return this.initialized = true;\n    };\n\n    Node.prototype._showChildren = function() {\n      var child, _i, _len, _ref, _results;\n      _ref = this.children;\n      _results = [];\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        child = _ref[_i];\n        _results.push(child.show());\n      }\n      return _results;\n    };\n\n    return Node;\n  })();\n\n  Tree = (function() {\n    function Tree(table, settings) {\n      this.table = table;\n      this.settings = settings;\n      this.tree = {};\n\n      // Cache the nodes and roots in simple arrays for quick access/iteration\n      this.nodes = [];\n      this.roots = [];\n    }\n\n    Tree.prototype.collapseAll = function() {\n      var node, _i, _len, _ref, _results;\n      _ref = this.nodes;\n      _results = [];\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        node = _ref[_i];\n        _results.push(node.collapse());\n      }\n      return _results;\n    };\n\n    Tree.prototype.expandAll = function() {\n      var node, _i, _len, _ref, _results;\n      _ref = this.nodes;\n      _results = [];\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        node = _ref[_i];\n        _results.push(node.expand());\n      }\n      return _results;\n    };\n\n    Tree.prototype.findLastNode = function (node) {\n      if (node.children.length > 0) {\n        return this.findLastNode(node.children[node.children.length - 1]);\n      } else {\n        return node;\n      }\n    };\n\n    Tree.prototype.loadRows = function(rows) {\n      var node, row, i;\n\n      if (rows != null) {\n        for (i = 0; i < rows.length; i++) {\n          row = $(rows[i]);\n\n          if (row.data(this.settings.nodeIdAttr) != null) {\n            node = new Node(row, this.tree, this.settings);\n            this.nodes.push(node);\n            this.tree[node.id] = node;\n\n            if (node.parentId != null && this.tree[node.parentId]) {\n              this.tree[node.parentId].addChild(node);\n            } else {\n              this.roots.push(node);\n            }\n          }\n        }\n      }\n\n      for (i = 0; i < this.nodes.length; i++) {\n        node = this.nodes[i].updateBranchLeafClass();\n      }\n\n      return this;\n    };\n\n    Tree.prototype.move = function(node, destination) {\n      // Conditions:\n      // 1: +node+ should not be inserted as a child of +node+ itself.\n      // 2: +destination+ should not be the same as +node+'s current parent (this\n      //    prevents +node+ from being moved to the same location where it already\n      //    is).\n      // 3: +node+ should not be inserted in a location in a branch if this would\n      //    result in +node+ being an ancestor of itself.\n      var nodeParent = node.parentNode();\n      if (node !== destination && destination.id !== node.parentId && $.inArray(node, destination.ancestors()) === -1) {\n        node.setParent(destination);\n        this._moveRows(node, destination);\n\n        // Re-render parentNode if this is its first child node, and therefore\n        // doesn't have the expander yet.\n        if (node.parentNode().children.length === 1) {\n          node.parentNode().render();\n        }\n      }\n\n      if(nodeParent){\n        nodeParent.updateBranchLeafClass();\n      }\n      if(node.parentNode()){\n        node.parentNode().updateBranchLeafClass();\n      }\n      node.updateBranchLeafClass();\n      return this;\n    };\n\n    Tree.prototype.removeNode = function(node) {\n      // Recursively remove all descendants of +node+\n      this.unloadBranch(node);\n\n      // Remove node from DOM (<tr>)\n      node.row.remove();\n\n      // Remove node from parent children list\n      if (node.parentId != null) {\n        node.parentNode().removeChild(node);\n      }\n\n      // Clean up Tree object (so Node objects are GC-ed)\n      delete this.tree[node.id];\n      this.nodes.splice($.inArray(node, this.nodes), 1);\n\n      return this;\n    }\n\n    Tree.prototype.render = function() {\n      var root, _i, _len, _ref;\n      _ref = this.roots;\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        root = _ref[_i];\n\n        // Naming is confusing (show/render). I do not call render on node from\n        // here.\n        root.show();\n      }\n      return this;\n    };\n\n    Tree.prototype.sortBranch = function(node, sortFun) {\n      // First sort internal array of children\n      node.children.sort(sortFun);\n\n      // Next render rows in correct order on page\n      this._sortChildRows(node);\n\n      return this;\n    };\n\n    Tree.prototype.unloadBranch = function(node) {\n      // Use a copy of the children array to not have other functions interfere\n      // with this function if they manipulate the children array\n      // (eg removeNode).\n      var children = node.children.slice(0),\n          i;\n\n      for (i = 0; i < children.length; i++) {\n        this.removeNode(children[i]);\n      }\n\n      // Reset node's collection of children\n      node.children = [];\n\n      node.updateBranchLeafClass();\n\n      return this;\n    };\n\n    Tree.prototype._moveRows = function(node, destination) {\n      var children = node.children, i;\n\n      node.row.insertAfter(destination.row);\n      node.render();\n\n      // Loop backwards through children to have them end up on UI in correct\n      // order (see #112)\n      for (i = children.length - 1; i >= 0; i--) {\n        this._moveRows(children[i], node);\n      }\n    };\n\n    // Special _moveRows case, move children to itself to force sorting\n    Tree.prototype._sortChildRows = function(parentNode) {\n      return this._moveRows(parentNode, parentNode);\n    };\n\n    return Tree;\n  })();\n\n  // jQuery Plugin\n  methods = {\n    init: function(options, force) {\n      var settings;\n\n      settings = $.extend({\n        branchAttr: \"ttBranch\",\n        clickableNodeNames: false,\n        column: 0,\n        columnElType: \"td\", // i.e. 'td', 'th' or 'td,th'\n        expandable: false,\n        expanderTemplate: \"<a href='#'>&nbsp;</a>\",\n        indent: 19,\n        indenterTemplate: \"<span class='indenter'></span>\",\n        initialState: \"collapsed\",\n        nodeIdAttr: \"ttId\", // maps to data-tt-id\n        parentIdAttr: \"ttParentId\", // maps to data-tt-parent-id\n        stringExpand: \"Expand\",\n        stringCollapse: \"Collapse\",\n\n        // Events\n        onInitialized: null,\n        onNodeCollapse: null,\n        onNodeExpand: null,\n        onNodeInitialized: null\n      }, options);\n\n      return this.each(function() {\n        var el = $(this), tree;\n\n        if (force || el.data(\"treetable\") === undefined) {\n          tree = new Tree(this, settings);\n          tree.loadRows(this.rows).render();\n\n          el.addClass(\"treetable\").data(\"treetable\", tree);\n\n          if (settings.onInitialized != null) {\n            settings.onInitialized.apply(tree);\n          }\n        }\n\n        return el;\n      });\n    },\n\n    destroy: function() {\n      return this.each(function() {\n        return $(this).removeData(\"treetable\").removeClass(\"treetable\");\n      });\n    },\n\n    collapseAll: function() {\n      this.data(\"treetable\").collapseAll();\n      return this;\n    },\n\n    collapseNode: function(id) {\n      var node = this.data(\"treetable\").tree[id];\n\n      if (node) {\n        node.collapse();\n      } else {\n        throw new Error(\"Unknown node '\" + id + \"'\");\n      }\n\n      return this;\n    },\n\n    expandAll: function() {\n      this.data(\"treetable\").expandAll();\n      return this;\n    },\n\n    expandNode: function(id) {\n      var node = this.data(\"treetable\").tree[id];\n\n      if (node) {\n        if (!node.initialized) {\n          node._initialize();\n        }\n\n        node.expand();\n      } else {\n        throw new Error(\"Unknown node '\" + id + \"'\");\n      }\n\n      return this;\n    },\n\n    loadBranch: function(node, rows) {\n      var settings = this.data(\"treetable\").settings,\n          tree = this.data(\"treetable\").tree;\n\n      // TODO Switch to $.parseHTML\n      rows = $(rows);\n\n      if (node == null) { // Inserting new root nodes\n        this.append(rows);\n      } else {\n        var lastNode = this.data(\"treetable\").findLastNode(node);\n        rows.insertAfter(lastNode.row);\n      }\n\n      this.data(\"treetable\").loadRows(rows);\n\n      // Make sure nodes are properly initialized\n      rows.filter(\"tr\").each(function() {\n        tree[$(this).data(settings.nodeIdAttr)].show();\n      });\n\n      if (node != null) {\n        // Re-render parent to ensure expander icon is shown (#79)\n        node.render().expand();\n      }\n\n      return this;\n    },\n\n    move: function(nodeId, destinationId) {\n      var destination, node;\n\n      node = this.data(\"treetable\").tree[nodeId];\n      destination = this.data(\"treetable\").tree[destinationId];\n      this.data(\"treetable\").move(node, destination);\n\n      return this;\n    },\n\n    node: function(id) {\n      return this.data(\"treetable\").tree[id];\n    },\n\n    removeNode: function(id) {\n      var node = this.data(\"treetable\").tree[id];\n\n      if (node) {\n        this.data(\"treetable\").removeNode(node);\n      } else {\n        throw new Error(\"Unknown node '\" + id + \"'\");\n      }\n\n      return this;\n    },\n\n    reveal: function(id) {\n      var node = this.data(\"treetable\").tree[id];\n\n      if (node) {\n        node.reveal();\n      } else {\n        throw new Error(\"Unknown node '\" + id + \"'\");\n      }\n\n      return this;\n    },\n\n    sortBranch: function(node, columnOrFunction) {\n      var settings = this.data(\"treetable\").settings,\n          prepValue,\n          sortFun;\n\n      columnOrFunction = columnOrFunction || settings.column;\n      sortFun = columnOrFunction;\n\n      if ($.isNumeric(columnOrFunction)) {\n        sortFun = function(a, b) {\n          var extractValue, valA, valB;\n\n          extractValue = function(node) {\n            var val = node.row.find(\"td:eq(\" + columnOrFunction + \")\").text();\n            // Ignore trailing/leading whitespace and use uppercase values for\n            // case insensitive ordering\n            return $.trim(val).toUpperCase();\n          }\n\n          valA = extractValue(a);\n          valB = extractValue(b);\n\n          if (valA < valB) return -1;\n          if (valA > valB) return 1;\n          return 0;\n        };\n      }\n\n      this.data(\"treetable\").sortBranch(node, sortFun);\n      return this;\n    },\n\n    unloadBranch: function(node) {\n      this.data(\"treetable\").unloadBranch(node);\n      return this;\n    }\n  };\n\n  $.fn.treetable = function(method) {\n    if (methods[method]) {\n      return methods[method].apply(this, Array.prototype.slice.call(arguments, 1));\n    } else if (typeof method === 'object' || !method) {\n      return methods.init.apply(this, arguments);\n    } else {\n      return $.error(\"Method \" + method + \" does not exist on jQuery.treetable\");\n    }\n  };\n\n  // Expose classes to world\n  window.TreeTable || (window.TreeTable = {});\n  window.TreeTable.Node = Node;\n  window.TreeTable.Tree = Tree;\n})(jQuery);\n"
    },
    {
        "path": "tests/modules/token_module_test/token_module_test.info.yml",
        "contents": "type: module\nname: Token Module Test\ndescription: Testing module for token functionality.\npackage: Testing\nhidden: TRUE\n"
    },
    {
        "path": "tests/modules/token_module_test/token_module_test.tokens.inc",
        "contents": "<?php\n\n/**\n * Implements hook_token_info()\n */\nfunction token_module_test_token_info() {\n  $info['tokens']['node']['colons:in:name'] = [\n    'name' => t('A test token with colons in the name'),\n    'description' => NULL,\n  ];\n\n  return $info;\n}\n"
    },
    {
        "path": "tests/modules/token_module_test/token_module_test.module",
        "contents": "<?php\n\n/**\n * @file\n * Helper module for token tests.\n */\n\nuse Drupal\\node\\NodeInterface;\n\n/**\n * Implements hook_page_attachments().\n */\nfunction token_module_test_page_attachments() {\n  if ($debug = \\Drupal::state()->get('token_page_tokens', [])) {\n    $debug += ['tokens' => [], 'data' => [], 'options' => []];\n    foreach (array_keys($debug['tokens']) as $token) {\n      $debug['values'][$token] = \\Drupal::token()->replace($token, $debug['data'], $debug['options']);\n    }\n    \\Drupal::state()->set('token_page_tokens', $debug);\n  }\n}\n\n/**\n * Implements hook_ENTITY_TYPE_presave for Node entities.\n */\nfunction token_module_test_node_presave(NodeInterface $node) {\n  // Transform tokens in the body.\n  // @see \\Drupal\\token\\Tests\\TokenMenuTest::testMenuTokens()\n  if ($node->hasField('body') && $node->get('body')->value) {\n    $node->body->value = \\Drupal::token()\n      ->replace($node->body->value, ['node' => $node]);\n  }\n}\n"
    },
    {
        "path": "tests/modules/token_module_test/token_module_test.routing.yml",
        "contents": "token_module_test.browse:\n  path: '/token_module_test/browse'\n  defaults:\n    _controller: '\\Drupal\\token_module_test\\Controller\\TokenTreeBrowseController::outputLink'\n    _title_callback: '\\Drupal\\token_module_test\\Controller\\TokenTreeBrowseController::getTitle'\n  requirements:\n    _access: 'TRUE'\n"
    },
    {
        "path": "tests/modules/token_module_test/config/install/core.date_format.token_module_test.yml",
        "contents": "id: token_module_test\nlabel: 'Token test'\nstatus: true\nlangcode: en\nlocked: true\npattern: Y\n"
    },
    {
        "path": "tests/modules/token_module_test/test_views/views.view.token_views_test.yml",
        "contents": "langcode: en\nstatus: true\ndependencies:\n  module:\n    - user\nid: token_views_test\nlabel: token_views_test\nmodule: views\ndescription: ''\ntag: ''\nbase_table: users_field_data\nbase_field: uid\ncore: 8.x\ndisplay:\n  default:\n    display_plugin: default\n    id: default\n    display_title: Master\n    position: 0\n    display_options:\n      access:\n        type: none\n        options: {  }\n      cache:\n        type: tag\n        options: {  }\n      query:\n        type: views_query\n        options:\n          disable_sql_rewrite: false\n          distinct: false\n          replica: false\n          query_comment: ''\n          query_tags: {  }\n      exposed_form:\n        type: basic\n        options:\n          submit_button: Apply\n          reset_button: false\n          reset_button_label: Reset\n          exposed_sorts_label: 'Sort by'\n          expose_sort_order: true\n          sort_asc_label: Asc\n          sort_desc_label: Desc\n      pager:\n        type: some\n        options:\n          items_per_page: 5\n          offset: 0\n      style:\n        type: default\n      row:\n        type: fields\n        options:\n          default_field_elements: true\n          inline: {  }\n          separator: ''\n          hide_empty: false\n      fields:\n        name:\n          id: name\n          table: users_field_data\n          field: name\n          entity_type: user\n          entity_field: name\n          label: ''\n          alter:\n            alter_text: false\n            make_link: false\n            absolute: false\n            trim: false\n            word_boundary: false\n            ellipsis: false\n            strip_tags: false\n            html: false\n          hide_empty: false\n          empty_zero: false\n          plugin_id: field\n          relationship: none\n          group_type: group\n          admin_label: ''\n          exclude: false\n          element_type: ''\n          element_class: ''\n          element_label_type: ''\n          element_label_class: ''\n          element_label_colon: true\n          element_wrapper_type: ''\n          element_wrapper_class: ''\n          element_default_classes: true\n          empty: ''\n          hide_alter_empty: true\n          click_sort_column: value\n          type: user_name\n          settings: {  }\n          group_column: value\n          group_columns: {  }\n          group_rows: true\n          delta_limit: 0\n          delta_offset: 0\n          delta_reversed: false\n          delta_first_last: false\n          multi_type: separator\n          separator: ', '\n          field_api_classes: false\n      filters: {  }\n      sorts: {  }\n      title: token_views_test\n      header: {  }\n      footer: {  }\n      empty: {  }\n      relationships: {  }\n      arguments: {  }\n      display_extenders: {  }\n      filter_groups:\n        operator: AND\n        groups: {  }\n    cache_metadata:\n      max-age: -1\n      contexts:\n        - 'languages:language_content'\n        - 'languages:language_interface'\n      tags: {  }\n  block_1:\n    display_plugin: block\n    id: block_1\n    display_title: Block\n    position: 1\n    display_options:\n      display_extenders: {  }\n"
    },
    {
        "path": "tests/modules/token_module_test/src/Controller/TokenTreeBrowseController.php",
        "contents": "<?php\n\nnamespace Drupal\\token_module_test\\Controller;\n\nuse Drupal\\Core\\Controller\\ControllerBase;\nuse Drupal\\token\\TokenInterface;\nuse Symfony\\Component\\DependencyInjection\\ContainerInterface;\nuse Symfony\\Component\\HttpFoundation\\Request;\n\n/**\n * Controller for token module test.\n */\nclass TokenTreeBrowseController extends ControllerBase {\n\n  /**\n   * Service to retrieve token information.\n   *\n   * @var \\Drupal\\token\\TokenInterface\n   */\n  protected $token;\n\n  /**\n   * The construct method.\n   *\n   * @param \\Drupal\\token\\TokenInterface $token\n   *   The token.\n   */\n  public function __construct(TokenInterface $token) {\n    $this->token = $token;\n  }\n\n  /**\n   * {@inheritdoc}\n   */\n  public static function create(ContainerInterface $container) {\n    return new static(\n      $container->get('token')\n    );\n  }\n\n  /**\n   * Page callback to output a link.\n   */\n  public function outputLink(Request $request) {\n    $build['tree']['#theme'] = 'token_tree_link';\n    $build['tokenarea'] = [\n      '#markup' => $this->token->replace('[current-page:title]'),\n      '#type' => 'markup',\n    ];\n    return $build;\n  }\n\n  /**\n   * Title callback for the page outputting a link.\n   *\n   * We are using a title callback instead of directly defining the title in the\n   * routing YML file. This is so that we could return an array instead of a\n   * simple string. This allows us to test if [current-page:title] works with\n   * render arrays and other objects as titles.\n   */\n  public function getTitle() {\n    return [\n      '#type' => 'markup',\n      '#markup' => 'Available Tokens',\n    ];\n  }\n\n}\n"
    },
    {
        "path": "tests/modules/token_user_picture/token_user_picture.info.yml",
        "contents": "type: module\nname: Token User picture\ndescription: Testing module that provides user pictures field.\npackage: Testing\nhidden: TRUE\ndependencies:\n  - drupal:image\n"
    },
    {
        "path": "tests/modules/token_user_picture/config/install/field.storage.user.user_picture.yml",
        "contents": "id: user.user_picture\nstatus: true\nlangcode: en\nfield_name: user_picture\nentity_type: user\ntype: image\nsettings:\n  uri_scheme: public\n  default_image:\n    uuid: null\n    alt: ''\n    title: ''\n    width: null\n    height: null\nmodule: image\nlocked: false\ncardinality: 1\ntranslatable: false\nindexes:\n  target_id:\n    - target_id\ndependencies:\n  module:\n    - image\n    - user\n"
    },
    {
        "path": "tests/modules/token_user_picture/config/install/field.field.user.user.user_picture.yml",
        "contents": "id: user.user.user_picture\nstatus: true\nlangcode: en\nentity_type: user\nbundle: user\nfield_name: user_picture\nlabel: Picture\ndescription: 'Your virtual face or picture.'\nrequired: false\ndefault_value: {  }\ndefault_value_function: ''\nsettings:\n  file_extensions: 'png gif jpg jpeg'\n  file_directory: pictures\n  max_filesize: '30 KB'\n  alt_field: false\n  title_field: false\n  max_resolution: 85x85\n  min_resolution: ''\n  default_image:\n    uuid: null\n    alt: ''\n    title: ''\n    width: null\n    height: null\n  alt_field_required: false\n  title_field_required: false\nfield_type: image\ndependencies:\n  config:\n    - field.storage.user.user_picture\n"
    },
    {
        "path": "tests/modules/token_user_picture/config/install/core.entity_form_display.user.user.default.yml",
        "contents": "langcode: de\nstatus: true\ndependencies:\n  module:\n    - image\n    - user\nid: user.user.default\ntargetEntityType: user\nbundle: user\nmode: default\ncontent:\n  account:\n    weight: -10\n  user_picture:\n    type: image_image\n    settings:\n      progress_indicator: throbber\n      preview_image_style: thumbnail\n    third_party_settings: {  }\n    weight: -1\n  timezone:\n    weight: 6\nhidden: {  }\n"
    },
    {
        "path": "tests/src/Functional/TokenURLTest.php",
        "contents": "<?php\n\nnamespace Drupal\\Tests\\token\\Functional;\n\nuse Drupal\\Core\\Url;\n\n/**\n * Tests url tokens.\n *\n * @group token\n */\nclass TokenURLTest extends TokenTestBase {\n\n  /**\n   * {@inheritdoc}\n   */\n  protected static $modules = ['node'];\n\n  /**\n   * {@inheritdoc}\n   */\n  public function setUp(): void {\n    parent::setUp();\n    $this->saveAlias('/node/1', '/first-node');\n  }\n\n  function testURLTokens() {\n    $url = new Url('entity.node.canonical', ['node' => 1]);\n    $tokens = [\n      'absolute' => $url->setAbsolute()->toString(),\n      'relative' => $url->setAbsolute(FALSE)->toString(),\n      'path' => '/first-node',\n      'brief' => preg_replace(['!^https?://!', '!/$!'], '', $url->setAbsolute()->toString()),\n      'args:value:0' => 'first-node',\n      'args:value:1' => NULL,\n      'args:value:N' => NULL,\n      'unaliased' => $url->setAbsolute()->setOption('alias', TRUE)->toString(),\n      'unaliased:relative' => $url->setAbsolute(FALSE)->setOption('alias', TRUE)->toString(),\n      'unaliased:path' => '/node/1',\n      'unaliased:brief' => preg_replace(['!^https?://!', '!/$!'], '', $url->setAbsolute()->setOption('alias', TRUE)->toString()),\n      'unaliased:args:value:0' => 'node',\n      'unaliased:args:value:1' => '1',\n      'unaliased:args:value:2' => NULL,\n      // Deprecated tokens.\n      'alias' => '/first-node',\n    ];\n    $this->assertTokens('url', ['url' => new Url('entity.node.canonical', ['node' => 1])], $tokens);\n  }\n}\n"
    },
    {
        "path": "tests/src/Functional/TokenTestBase.php",
        "contents": "<?php\n\nnamespace Drupal\\Tests\\token\\Functional;\n\nuse Drupal\\Tests\\BrowserTestBase;\n\n/**\n * Helper test class with some added functions for testing.\n */\nabstract class TokenTestBase extends BrowserTestBase {\n\n  use TokenTestTrait;\n\n  /**\n   * {@inheritdoc}\n   */\n  protected static $modules = ['path', 'token', 'token_module_test'];\n\n  /**\n   * {@inheritdoc}\n   */\n  protected $defaultTheme = 'stark';\n\n}\n"
    },
    {
        "path": "tests/src/Functional/TokenUserTest.php",
        "contents": "<?php\n\nnamespace Drupal\\Tests\\token\\Functional;\n\nuse Drupal\\Core\\File\\FileSystemInterface;\nuse Drupal\\Core\\Session\\AccountInterface;\nuse Drupal\\Core\\Session\\AnonymousUserSession;\nuse Drupal\\field\\Entity\\FieldStorageConfig;\nuse Drupal\\Tests\\TestFileCreationTrait;\n\n/**\n * Tests user tokens.\n *\n * @group token\n */\nclass TokenUserTest extends TokenTestBase {\n\n  use TestFileCreationTrait;\n\n  /**\n   * The user account.\n   *\n   * @var \\Drupal\\Core\\Session\\AccountInterface\n   */\n  protected $account = NULL;\n\n  /**\n   * {@inheritdoc}\n   */\n  protected static $modules = ['token_user_picture'];\n\n  /**\n   * {@inheritdoc}\n   */\n  public function setUp(): void {\n    parent::setUp();\n\n    $this->account = $this->drupalCreateUser([\n      'administer users',\n      'administer account settings',\n      'access content',\n    ]);\n    $this->drupalLogin($this->account);\n  }\n\n  /**\n   * Tests the user related tokens.\n   */\n  public function testUserTokens() {\n    // Enable user pictures.\n    \\Drupal::state()->set('user_pictures', 1);\n    \\Drupal::state()->set('user_picture_file_size', '');\n\n    // Set up the pictures directory.\n    $picture_path = 'public://' . \\Drupal::state()->get('user_picture_path', 'pictures');\n    if (!\\Drupal::service('file_system')->prepareDirectory($picture_path, FileSystemInterface::CREATE_DIRECTORY)) {\n      $this->fail('Could not create directory ' . $picture_path . '.');\n    }\n\n    // Add a user picture to the account.\n    $image = current($this->getTestFiles('image'));\n    $edit = ['files[user_picture_0]' => \\Drupal::service('file_system')->realpath($image->uri)];\n    $this->drupalGet('user/' . $this->account->id() . '/edit');\n    $this->submitForm($edit, 'Save');\n\n    $storage = \\Drupal::entityTypeManager()->getStorage('user');\n\n    // Load actual user data from database.\n    $storage->resetCache();\n    $this->account = $storage->load($this->account->id());\n    $this->assertNotEmpty($this->account->user_picture->target_id, 'User picture uploaded.');\n\n    $picture = [\n      '#theme' => 'user_picture',\n      '#account' => $this->account,\n    ];\n    /** @var \\Drupal\\Core\\Render\\RendererInterface $renderer */\n    $renderer = \\Drupal::service('renderer');\n    $user_tokens = [\n      'picture' => $renderer->renderPlain($picture),\n      'picture:fid' => $this->account->user_picture->target_id,\n      'picture:size-raw' => 125,\n      'ip-address' => NULL,\n      'roles' => implode(', ', $this->account->getRoles()),\n    ];\n    $this->assertTokens('user', ['user' => $this->account], $user_tokens);\n\n    // Remove the simpletest-created user role.\n    $roles = $this->account->getRoles();\n    $this->account->removeRole(end($roles));\n    $this->account->save();\n\n    // Remove the user picture field and reload the user.\n    FieldStorageConfig::loadByName('user', 'user_picture')->delete();\n    $storage->resetCache();\n    $this->account = $storage->load($this->account->id());\n\n    $user_tokens = [\n      'picture' => NULL,\n      'picture:fid' => NULL,\n      'ip-address' => NULL,\n      'roles' => 'authenticated',\n      'roles:keys' => AccountInterface::AUTHENTICATED_ROLE,\n    ];\n    $this->assertTokens('user', ['user' => $this->account], $user_tokens);\n\n    // The ip address token should work for the current user token type.\n    $tokens = [\n      'ip-address' => \\Drupal::request()->getClientIp(),\n    ];\n    $this->assertTokens('current-user', [], $tokens);\n\n    $anonymous = new AnonymousUserSession();\n    $tokens = [\n      'roles' => 'anonymous',\n      'roles:keys' => AccountInterface::ANONYMOUS_ROLE,\n    ];\n    $this->assertTokens('user', ['user' => $anonymous], $tokens);\n  }\n\n  /**\n   * Test user account settings.\n   */\n  public function testUserAccountSettings() {\n    $this->drupalGet('admin/config/people/accounts');\n    $this->assertSession()->pageTextContains('The list of available tokens that can be used in e-mails is provided below.');\n    $this->assertSession()->linkExists('Browse available tokens.');\n    $this->assertSession()->linkByHrefExists('token/tree');\n  }\n}\n"
    },
    {
        "path": "tests/src/Functional/TokenTestTrait.php",
        "contents": "<?php\n\nnamespace Drupal\\Tests\\token\\Functional;\n\nuse Drupal\\Core\\Entity\\EntityInterface;\nuse Drupal\\Core\\Language\\Language;\nuse Drupal\\Core\\Render\\BubbleableMetadata;\nuse Drupal\\Tests\\Traits\\Core\\PathAliasTestTrait;\n\n/**\n * Helper test trait with some added functions for testing.\n */\ntrait TokenTestTrait {\n\n  use PathAliasTestTrait;\n\n  function assertToken($type, array $data, $token, $expected, array $options = []) {\n    return $this->assertTokens($type, $data, [$token => $expected], $options);\n  }\n\n  function assertTokens($type, array $data, array $tokens, array $options = []) {\n    $input = $this->mapTokenNames($type, array_keys($tokens));\n    $bubbleable_metadata = new BubbleableMetadata();\n    $replacements = \\Drupal::token()->generate($type, $input, $data, $options, $bubbleable_metadata);\n    foreach ($tokens as $name => $expected) {\n      $token = $input[$name];\n      if (!isset($expected)) {\n        $this->assertArrayNotHasKey($token, $replacements, t(\"Token value for @token was not generated.\", ['@token' => $token]));\n      }\n      elseif (!isset($replacements[$token])) {\n        $this->fail(t(\"Token value for @token was not generated.\", ['@type' => $type, '@token' => $token]));\n      }\n      elseif (!empty($options['regex'])) {\n        $this->assertEquals(1, preg_match('/^' . $expected . '$/', $replacements[$token]), t(\"Token value for @token was '@actual', matching regular expression pattern '@expected'.\", ['@type' => $type, '@token' => $token, '@actual' => $replacements[$token], '@expected' => $expected]));\n      }\n      else {\n        $this->assertEquals($expected, $replacements[$token], t(\"Token value for @token was '@actual', expected value '@expected'.\", ['@type' => $type, '@token' => $token, '@actual' => $replacements[$token], '@expected' => $expected]));\n      }\n    }\n\n    return $replacements;\n  }\n\n  function mapTokenNames($type, array $tokens = []) {\n    $return = [];\n    foreach ($tokens as $token) {\n      $return[$token] = \"[$type:$token]\";\n    }\n    return $return;\n  }\n\n  function assertNoTokens($type, array $data, array $tokens, array $options = []) {\n    $input = $this->mapTokenNames($type, $tokens);\n    $bubbleable_metadata = new BubbleableMetadata();\n    $replacements = \\Drupal::token()->generate($type, $input, $data, $options, $bubbleable_metadata);\n    foreach ($tokens as $name) {\n      $token = $input[$name];\n      $this->assertTrue(!isset($replacements[$token]), t(\"Token value for @token was not generated.\", ['@type' => $type, '@token' => $token]));\n    }\n  }\n\n  function saveAlias($source, $alias, $language = Language::LANGCODE_NOT_SPECIFIED) {\n    return $this->createPathAlias($source, $alias, $language);\n  }\n\n  function saveEntityAlias($entity_type, EntityInterface $entity, $alias, $language = Language::LANGCODE_NOT_SPECIFIED) {\n    $uri = $entity->toUrl()->toArray();\n    return $this->saveAlias($uri['path'], $alias, $language);\n  }\n\n  /**\n   * Make a page request and test for token generation.\n   */\n  function assertPageTokens($url, array $tokens, array $data = [], array $options = []) {\n    if (empty($tokens)) {\n      return TRUE;\n    }\n\n    $token_page_tokens = [\n      'tokens' => $tokens,\n      'data' => $data,\n      'options' => $options,\n    ];\n    \\Drupal::state()->set('token_page_tokens', $token_page_tokens);\n\n    $options += ['url_options' => []];\n    $this->drupalGet($url, $options['url_options']);\n    $this->refreshVariables();\n    $result = \\Drupal::state()->get('token_page_tokens', []);\n\n    if (!isset($result['values']) || !is_array($result['values'])) {\n      return $this->fail('Failed to generate tokens.');\n    }\n\n    foreach ($tokens as $token => $expected) {\n      if (!isset($expected)) {\n        $this->assertTrue(!isset($result['values'][$token]) || $result['values'][$token] === $token, t(\"Token value for @token was not generated.\", ['@token' => $token]));\n      }\n      elseif (!isset($result['values'][$token])) {\n        $this->fail(t('Failed to generate token @token.', ['@token' => $token]));\n      }\n      else {\n        $this->assertSame($result['values'][$token], (string) $expected, t(\"Token value for @token was '@actual', expected value '@expected'.\", ['@token' => $token, '@actual' => $result['values'][$token], '@expected' => $expected]));\n      }\n    }\n  }\n\n}\n"
    },
    {
        "path": "tests/src/Functional/TokenFieldUiTest.php",
        "contents": "<?php\n\nnamespace Drupal\\Tests\\token\\Functional;\n\nuse Drupal\\field\\Entity\\FieldConfig;\nuse Drupal\\field\\Entity\\FieldStorageConfig;\nuse Drupal\\file\\Entity\\File;\nuse Drupal\\image\\Entity\\ImageStyle;\nuse Drupal\\node\\Entity\\Node;\nuse Drupal\\node\\Entity\\NodeType;\n\n/**\n * Tests field ui.\n *\n * @group token\n */\nclass TokenFieldUiTest extends TokenTestBase {\n\n  /**\n   * @var \\Drupal\\Core\\Session\\AccountInterface\n   */\n  protected $adminUser;\n\n  /**\n   * {@inheritdoc}\n   */\n  protected static $modules = ['field_ui', 'node', 'image'];\n\n  /**\n   * {@inheritdoc}\n   */\n  public function setUp(): void {\n    parent::setUp();\n    $this->adminUser = $this->drupalCreateUser(['bypass node access', 'administer content types', 'administer node fields']);\n    $this->drupalLogin($this->adminUser);\n\n    $node_type = NodeType::create([\n      'type' => 'article',\n      'name' => 'Article',\n      'description' => \"Use <em>articles</em> for time-sensitive content like news, press releases or blog posts.\",\n    ]);\n    $node_type->save();\n\n    FieldStorageConfig::create([\n      'field_name' => 'field_body',\n      'entity_type' => 'node',\n      'type' => 'text_with_summary',\n    ])->save();\n    FieldConfig::create([\n      'field_name' => 'field_body',\n      'label' => 'Body',\n      'entity_type' => 'node',\n      'bundle' => 'article',\n    ])->save();\n    FieldStorageConfig::create([\n      'field_name' => 'field_image',\n      'entity_type' => 'node',\n      'type' => 'image',\n    ])->save();\n    FieldConfig::create([\n      'field_name' => 'field_image',\n      'label' => 'Image',\n      'entity_type' => 'node',\n      'bundle' => 'article',\n    ])->save();\n    FieldStorageConfig::create([\n      'field_name' => 'field_image_2',\n      'entity_type' => 'node',\n      'type' => 'image',\n    ])->save();\n    FieldConfig::create([\n      'field_name' => 'field_image_2',\n      'label' => 'Image 2',\n      'entity_type' => 'node',\n      'bundle' => 'article',\n    ])->save();\n    FieldStorageConfig::create([\n      'field_name' => 'multivalued_field_image',\n      'entity_type' => 'node',\n      'type' => 'image',\n    ])->save();\n    FieldConfig::create([\n      'field_name' => 'multivalued_field_image',\n      'label' => 'Multivalued field image',\n      'entity_type' => 'node',\n      'bundle' => 'article',\n    ])->save();\n\n    \\Drupal::service('entity_display.repository')->getFormDisplay('node', 'article', 'default')\n      ->setComponent('field_body', [\n        'type' => 'text_textarea_with_summary',\n        'settings' => [\n          'rows' => '9',\n          'summary_rows' => '3',\n        ],\n        'weight' => 5,\n      ])\n      ->save();\n  }\n\n  public function testFileFieldUi() {\n    $this->drupalGet('admin/structure/types/manage/article/fields/node.article.field_image');\n\n    // Ensure the 'Browse available tokens' link is present and correct.\n    $this->assertSession()->linkExists('Browse available tokens.');\n    $this->assertSession()->linkByHrefExists('token/tree');\n\n    // Ensure that the default file directory value validates correctly.\n    $this->submitForm([], 'Save settings');\n    $this->assertSession()->pageTextContains('Saved Image configuration.');\n  }\n\n  public function testFieldDescriptionTokens() {\n    $edit = [\n      'description' => 'The site is called [site:name].',\n    ];\n    $this->drupalGet('admin/structure/types/manage/article/fields/node.article.field_body');\n    $this->submitForm($edit, 'Save settings');\n\n    $this->drupalGet('node/add/article');\n    $this->assertSession()->pageTextContains('The site is called Drupal.');\n  }\n\n  /**\n   * Test that tokens are correctly provided and replaced for the image fields.\n   */\n  public function testImageFieldTokens() {\n    // Generate 2 different test images.\n    $file_system = \\Drupal::service('file_system');\n    $file_system->copy(\\Drupal::root() . '/core/misc/druplicon.png', 'public://example1.png');\n    $file_system->copy(\\Drupal::root() . '/core/misc/loading.gif', 'public://example2.gif');\n\n    // Resize the test images so that they will be scaled down during token\n    // replacement.\n    $image1 = \\Drupal::service('image.factory')->get('public://example1.png');\n    $image1->resize(500, 500);\n    $image1->save();\n    $image2 = \\Drupal::service('image.factory')->get('public://example2.gif');\n    $image2->resize(500, 500);\n    $image2->save();\n\n    /** @var \\Drupal\\file\\Entity\\File $image1 */\n    $image1 = File::create(['uri' => 'public://example1.png']);\n    $image1->save();\n    /** @var \\Drupal\\file\\Entity\\File $image2 */\n    $image2 = File::create(['uri' => 'public://example2.gif']);\n    $image2->save();\n\n    $node = Node::create([\n      'title' => 'Test node title',\n      'type' => 'article',\n      'field_image' => [\n        [\n          'target_id' => $image1->id(),\n        ],\n      ],\n      'field_image_2' => [\n        [\n          'target_id' => $image2->id(),\n        ],\n      ],\n      'multivalued_field_image' => [\n        ['target_id' => $image1->id()],\n        ['target_id' => $image2->id()],\n      ],\n    ]);\n    $node->save();\n\n    // Obtain the file size and dimension of the images that will be scaled\n    // down during token replacement by applying the styles here.\n    $style_thumbnail = ImageStyle::load('thumbnail');\n    $style_thumbnail->createDerivative('public://example1.png', 'public://styles/thumbnail/public/example1-test.png');\n    $style_thumbnail->createDerivative('public://example2.gif', 'public://styles/thumbnail/public/example2-test.gif');\n    $image_1_thumbnail = \\Drupal::service('image.factory')->get('public://styles/thumbnail/public/example1-test.png');\n    $image_2_thumbnail = \\Drupal::service('image.factory')->get('public://styles/thumbnail/public/example2-test.gif');\n    $style_medium = ImageStyle::load('medium');\n    $style_medium->createDerivative('public://example1.png', 'public://styles/medium/public/example1-test.png');\n    $style_medium->createDerivative('public://example2.gif', 'public://styles/medium/public/example2-test.gif');\n    $image_1_medium = \\Drupal::service('image.factory')->get('public://styles/medium/public/example1-test.png');\n    $image_2_medium = \\Drupal::service('image.factory')->get('public://styles/medium/public/example2-test.gif');\n    $style_large = ImageStyle::load('large');\n    $style_large->createDerivative('public://example1.png', 'public://styles/large/public/example1-test.png');\n    $style_large->createDerivative('public://example2.gif', 'public://styles/large/public/example2-test.gif');\n    $image_1_large = \\Drupal::service('image.factory')->get('public://styles/large/public/example1-test.png');\n    $image_2_large = \\Drupal::service('image.factory')->get('public://styles/large/public/example2-test.gif');\n\n    // Delete the image derivatives, to make sure they are re-created.\n    unlink('public://styles/thumbnail/public/example1-test.png');\n    unlink('public://styles/medium/public/example1-test.png');\n    unlink('public://styles/large/public/example1-test.png');\n    unlink('public://styles/thumbnail/public/example2-test.gif');\n    unlink('public://styles/medium/public/example2-test.gif');\n    unlink('public://styles/large/public/example2-test.gif');\n\n    $style_mimetype_png = 'image/webp';\n    $style_mimetype_gif = 'image/webp';\n    if (version_compare(\\Drupal::VERSION, '10.3', '<')) {\n      $style_mimetype_png = 'image/png';\n      $style_mimetype_gif = 'image/gif';\n    }\n\n    $tokens = [\n      // field_image\n      'field_image:thumbnail:mimetype' => $style_mimetype_png,\n      'field_image:medium:mimetype' => $style_mimetype_png,\n      'field_image:large:mimetype' => $style_mimetype_png,\n      'field_image:thumbnail:filesize' => $image_1_thumbnail->getFileSize(),\n      'field_image:medium:filesize' => $image_1_medium->getFileSize(),\n      'field_image:large:filesize' => $image_1_large->getFileSize(),\n      'field_image:thumbnail:height' => '100',\n      'field_image:medium:height' => '220',\n      'field_image:large:height' => '480',\n      'field_image:thumbnail:width' => '100',\n      'field_image:medium:width' => '220',\n      'field_image:large:width' => '480',\n      'field_image:thumbnail:uri' => $style_thumbnail->buildUri('public://example1.png'),\n      'field_image:medium:uri' => $style_medium->buildUri('public://example1.png'),\n      'field_image:large:uri' => $style_large->buildUri('public://example1.png'),\n      'field_image:thumbnail:url' => $style_thumbnail->buildUrl('public://example1.png'),\n      'field_image:medium:url' => $style_medium->buildUrl('public://example1.png'),\n      'field_image:large:url' => $style_large->buildUrl('public://example1.png'),\n      'field_image:thumbnail' => $style_thumbnail->buildUrl('public://example1.png'),\n      'field_image:medium' => $style_medium->buildUrl('public://example1.png'),\n      'field_image:large' => $style_large->buildUrl('public://example1.png'),\n      // field_image_2\n      'field_image_2:thumbnail:mimetype' => $style_mimetype_gif,\n      'field_image_2:medium:mimetype' => $style_mimetype_gif,\n      'field_image_2:large:mimetype' => $style_mimetype_gif,\n      'field_image_2:thumbnail:filesize' => $image_2_thumbnail->getFileSize(),\n      'field_image_2:medium:filesize' => $image_2_medium->getFileSize(),\n      'field_image_2:large:filesize' => $image_2_large->getFileSize(),\n      'field_image_2:thumbnail:height' => '100',\n      'field_image_2:medium:height' => '220',\n      'field_image_2:large:height' => '480',\n      'field_image_2:thumbnail:width' => '100',\n      'field_image_2:medium:width' => '220',\n      'field_image_2:large:width' => '480',\n      'field_image_2:thumbnail:uri' => $style_thumbnail->buildUri('public://example2.gif'),\n      'field_image_2:medium:uri' => $style_medium->buildUri('public://example2.gif'),\n      'field_image_2:large:uri' => $style_large->buildUri('public://example2.gif'),\n      'field_image_2:thumbnail:url' => $style_thumbnail->buildUrl('public://example2.gif'),\n      'field_image_2:medium:url' => $style_medium->buildUrl('public://example2.gif'),\n      'field_image_2:large:url' => $style_large->buildUrl('public://example2.gif'),\n      'field_image_2:thumbnail' => $style_thumbnail->buildUrl('public://example2.gif'),\n      'field_image_2:medium' => $style_medium->buildUrl('public://example2.gif'),\n      'field_image_2:large' => $style_large->buildUrl('public://example2.gif'),\n      // multivalued_field_image:0, test for thumbnail image style only.\n      'multivalued_field_image:0:thumbnail:mimetype' => $style_mimetype_png,\n      'multivalued_field_image:0:thumbnail:filesize' => $image_1_thumbnail->getFileSize(),\n      'multivalued_field_image:0:thumbnail:height' => '100',\n      'multivalued_field_image:0:thumbnail:width' => '100',\n      'multivalued_field_image:0:thumbnail:uri' => $style_thumbnail->buildUri('public://example1.png'),\n      'multivalued_field_image:0:thumbnail:url' => $style_thumbnail->buildUrl('public://example1.png'),\n      'multivalued_field_image:0:thumbnail' => $style_thumbnail->buildUrl('public://example1.png'),\n      // multivalued_field_image:1, test for medium image style only.\n      'multivalued_field_image:1:medium:mimetype' => $style_mimetype_gif,\n      'multivalued_field_image:1:medium:filesize' => $image_2_medium->getFileSize(),\n      'multivalued_field_image:1:medium:height' => '220',\n      'multivalued_field_image:1:medium:width' => '220',\n      'multivalued_field_image:1:medium:uri' => $style_medium->buildUri('public://example2.gif'),\n      'multivalued_field_image:1:medium:url' => $style_medium->buildUrl('public://example2.gif'),\n      'multivalued_field_image:1:medium' => $style_medium->buildUrl('public://example2.gif'),\n    ];\n    $this->assertTokens('node', ['node' => $node], $tokens);\n\n    /** @var \\Drupal\\token\\Token $token_service */\n    $token_service = \\Drupal::service('token');\n\n    // Test one of the image style's token info for cardinality 1 image field.\n    $token_info = $token_service->getTokenInfo('node-field_image', 'thumbnail');\n    $this->assertEquals('Thumbnail (100×100)', $token_info['name']);\n    $this->assertEquals('Represents the image in the given image style.', $token_info['description']);\n\n    // Test one of the image style's token info for a multivalued image field.\n    $token_info = $token_service->getTokenInfo('node-multivalued_field_image', 'medium');\n    $this->assertEquals('Medium (220×220)', $token_info['name']);\n    $this->assertEquals('Represents the image in the given image style.', $token_info['description']);\n\n    // Test few of the image styles' properties token info.\n    $token_info = $token_service->getTokenInfo('image_with_image_style', 'mimetype');\n    $this->assertEquals('MIME type', $token_info['name']);\n    $this->assertEquals('The MIME type (image/png, image/bmp, etc.) of the image.', $token_info['description']);\n\n    $token_info = $token_service->getTokenInfo('image_with_image_style', 'filesize');\n    $this->assertEquals('File size', $token_info['name']);\n    $this->assertEquals('The file size of the image.', $token_info['description']);\n  }\n\n}\n"
    },
    {
        "path": "tests/src/Functional/TokenCurrentPageTest.php",
        "contents": "<?php\n\nnamespace Drupal\\Tests\\token\\Functional;\n\nuse Drupal\\Core\\Url;\n\n/**\n * Test the [current-page:*] tokens.\n *\n * @group token\n */\nclass TokenCurrentPageTest extends TokenTestBase {\n\n  /**\n   * {@inheritdoc}\n   */\n  protected static $modules = ['node'];\n\n  function testCurrentPageTokens() {\n    // Cache clear is necessary because the frontpage was already cached by an\n    // initial request.\n    $this->rebuildAll();\n    $tokens = [\n      '[current-page:title]' => 'Log in',\n      '[current-page:url]' => Url::fromRoute('user.login', [], ['absolute' => TRUE])->toString(),\n      '[current-page:url:absolute]' => Url::fromRoute('user.login', [], ['absolute' => TRUE])->toString(),\n      '[current-page:url:relative]' => Url::fromRoute('user.login')->toString(),\n      '[current-page:url:path]' => '/user/login',\n      '[current-page:url:args:value:0]' => 'user',\n      '[current-page:url:args:value:1]' => 'login',\n      '[current-page:url:args:value:2]' => NULL,\n      '[current-page:url:unaliased]' => Url::fromRoute('user.login', [], ['absolute' => TRUE, 'alias' => TRUE])->toString(),\n      '[current-page:page-number]' => 1,\n      '[current-page:query:foo]' => NULL,\n      '[current-page:query:bar]' => NULL,\n      // Deprecated tokens\n      '[current-page:arg:0]' => 'user',\n      '[current-page:arg:1]' => 'login',\n      '[current-page:arg:2]' => NULL,\n    ];\n    $this->assertPageTokens('user/login', $tokens);\n\n    $this->drupalCreateContentType(['type' => 'page']);\n    $node = $this->drupalCreateNode(['title' => 'Node title', 'path' => ['alias' => '/node-alias']]);\n    $tokens = [\n      '[current-page:title]' => 'Node title',\n      '[current-page:url]' => $node->toUrl('canonical', ['absolute' => TRUE])->toString(),\n      '[current-page:url:absolute]' => $node->toUrl('canonical', ['absolute' => TRUE])->toString(),\n      '[current-page:url:relative]' => $node->toUrl()->toString(),\n      '[current-page:url:alias]' => '/node-alias',\n      '[current-page:url:args:value:0]' => 'node-alias',\n      '[current-page:url:args:value:1]' => NULL,\n      '[current-page:url:unaliased]' => $node->toUrl('canonical', ['absolute' => TRUE, 'alias' => TRUE])->toString(),\n      '[current-page:url:unaliased:args:value:0]' => 'node',\n      '[current-page:url:unaliased:args:value:1]' => $node->id(),\n      '[current-page:url:unaliased:args:value:2]' => NULL,\n      '[current-page:page-number]' => 1,\n      '[current-page:query:foo]' => 'bar',\n      '[current-page:query:bar]' => NULL,\n      // Deprecated tokens\n      '[current-page:arg:0]' => 'node',\n      '[current-page:arg:1]' => 1,\n      '[current-page:arg:2]' => NULL,\n    ];\n    $this->assertPageTokens(\"/node/{$node->id()}\", $tokens, [], ['url_options' => ['query' => ['foo' => 'bar']]]);\n  }\n}\n"
    },
    {
        "path": "tests/src/Functional/UrlTest.php",
        "contents": "<?php\n\nnamespace Drupal\\Tests\\token\\Functional;\n\nuse Drupal\\block\\Entity\\Block;\nuse Drupal\\node\\Entity\\Node;\nuse Drupal\\node\\Entity\\NodeType;\nuse Drupal\\Tests\\BrowserTestBase;\nuse Drupal\\Tests\\system\\Functional\\Cache\\AssertPageCacheContextsAndTagsTrait;\n\n/**\n * Tests URL tokens.\n *\n * @group token\n */\nclass UrlTest extends BrowserTestBase {\n\n  use AssertPageCacheContextsAndTagsTrait;\n\n  /**\n   * The first testing node.\n   *\n   * @var \\Drupal\\node\\NodeInterface\n   */\n  protected $node1;\n\n  /**\n   * The second testing node.\n   *\n   * @var \\Drupal\\node\\NodeInterface\n   */\n  protected $node2;\n\n  /**\n   * {@inheritdoc}\n   */\n  protected static $modules = ['node', 'token', 'block'];\n\n  /**\n   * {@inheritdoc}\n   */\n  protected $defaultTheme = 'stark';\n\n  /**\n   * {@inheritdoc}\n   */\n  protected function setUp(): void {\n    parent::setUp();\n\n    $node_type = NodeType::create(['type' => 'article', 'name' => 'Article']);\n    $node_type->save();\n\n    $this->node1 = Node::create([\n      'type' => 'article',\n      'title' => 'Test Node 1',\n    ]);\n    $this->node1->save();\n\n    $this->node2 = Node::create([\n      'type' => 'article',\n      'title' => 'Test Node 2',\n    ]);\n    $this->node2->save();\n\n  }\n\n  /**\n   * Creates a block with token for title and tests cache contexts.\n   *\n   * @throws \\Behat\\Mink\\Exception\\ElementHtmlException\n   * @throws \\Drupal\\Core\\Entity\\EntityStorageException\n   */\n  public function testBlockUrlTokenReplacement() {\n\n    $node1_url = $this->node1->toUrl();\n    $node2_url = $this->node2->toUrl();\n\n    // Using a @dataprovider causes repeated database installations and takes a\n    // very long time.\n    $tests = [];\n    $tests[] = [\n      'token' => 'prefix_[current-page:url:path]_suffix',\n      'expected1' => 'prefix_/' . $node1_url->getInternalPath() . '_suffix',\n      'expected2' => 'prefix_/' . $node2_url->getInternalPath() . '_suffix',\n      // A path can only be generated from a routed path.\n      'expected3' => 'prefix_/_suffix',\n    ];\n    $tests[] = [\n      'token' => 'prefix_[current-page:url]_suffix',\n      'expected1' => 'prefix_' . $node1_url->setAbsolute()->toString() . '_suffix',\n      'expected2' => 'prefix_' . $node2_url->setAbsolute()->toString() . '_suffix',\n      'expected3' => 'prefix_' . $this->getAbsoluteUrl('does-not-exist') . '_suffix',\n    ];\n\n    // Place a standard block and use a token in the label.\n    $edit = [\n      'id' => 'token_url_test_block',\n      'label' => 'label',\n      'label_display' => TRUE,\n    ];\n    $this->placeBlock('system_powered_by_block', $edit);\n    $block = Block::load('token_url_test_block');\n\n    $assert_session = $this->assertSession();\n\n    foreach ($tests as $test) {\n      // Set the block label.\n      $block->getPlugin()->setConfigurationValue('label', $test['token']);\n      $block->save();\n\n      // Go to the first node page and test that the token is correct.\n      $this->drupalGet($node1_url);\n      $assert_session->elementContains('css', '#block-token-url-test-block', $test['expected1']);\n\n      // Go to the second node page and check that the block title has changed.\n      $this->drupalGet($node2_url);\n      $assert_session->elementContains('css', '#block-token-url-test-block', $test['expected2']);\n\n      // Test the current page url on a 404 page.\n      $this->drupalGet('does-not-exist');\n      $assert_session->statusCodeEquals(404);\n      $assert_session->elementContains('css', '#block-token-url-test-block', $test['expected3']);\n    }\n\n\n    // Can't do this test in the for loop above, it's too different.\n    $block->getPlugin()->setConfigurationValue('label', 'prefix_[current-page:query:unicorns]_suffix');\n    $block->save();\n\n    // Test the parameter token.\n    $this->drupalGet($node1_url->setOption('query', ['unicorns' => 'fluffy']));\n    $this->assertCacheContext('url.query_args');\n    $assert_session->elementContains('css', '#block-token-url-test-block', 'prefix_fluffy_suffix');\n\n    // Change the parameter on the same page.\n    $this->drupalGet($node1_url->setOption('query', ['unicorns' => 'dead']));\n    $assert_session->elementContains('css', '#block-token-url-test-block', 'prefix_dead_suffix');\n  }\n\n}\n"
    },
    {
        "path": "tests/src/Functional/TokenMenuUiContentModerationTest.php",
        "contents": "<?php\n\nnamespace Drupal\\Tests\\token\\Functional;\n\nuse Drupal\\Tests\\menu_ui\\Functional\\MenuUiContentModerationTest;\n\n/**\n * Tests Menu UI and Content Moderation integration.\n *\n * @group token\n */\nclass TokenMenuUiContentModerationTest extends MenuUiContentModerationTest {\n\n  /**\n   * {@inheritdoc}\n   */\n  protected static $modules = ['token'];\n\n}\n"
    },
    {
        "path": "tests/src/Functional/TokenMenuTest.php",
        "contents": "<?php\n\nnamespace Drupal\\Tests\\token\\Functional;\n\nuse Behat\\Mink\\Element\\NodeElement;\nuse Drupal\\Core\\Url;\nuse Drupal\\language\\Entity\\ConfigurableLanguage;\nuse Drupal\\menu_link_content\\Entity\\MenuLinkContent;\nuse Drupal\\node\\Entity\\Node;\nuse Drupal\\node\\Entity\\NodeType;\nuse Drupal\\system\\Entity\\Menu;\n\n/**\n * Tests menu tokens.\n *\n * @group token\n */\nclass TokenMenuTest extends TokenTestBase {\n\n  /**\n   * {@inheritdoc}\n   */\n  protected static $modules = [\n    'menu_ui',\n    'node',\n    'block',\n    'language',\n    'block_content',\n    'content_translation',\n  ];\n\n  function testMenuTokens() {\n\n    $admin = $this->drupalCreateUser(['administer menu', 'link to any page']);\n    $this->drupalLogin($admin);\n\n    // Make sure we have a body field on the node type.\n    $this->drupalCreateContentType(['type' => 'page']);\n    // Add a menu.\n    $menu = Menu::create([\n      'id' => 'main-menu',\n      'label' => 'Main menu',\n      'description' => 'The <em>Main</em> menu is used on many sites to show the major sections of the site, often in a top navigation bar.',\n    ]);\n    $menu->save();\n\n    // Place the menu block.\n    $this->drupalPlaceBlock('system_menu_block:main-menu');\n\n    // Add a root link.\n    /** @var \\Drupal\\menu_link_content\\Plugin\\Menu\\MenuLinkContent $root_link */\n    $root_link = MenuLinkContent::create([\n      'link' => ['uri' => 'internal:/admin'],\n      'title' => 'Administration',\n      'menu_name' => 'main-menu',\n    ]);\n    $root_link->save();\n\n    // Add another link with the root link as the parent.\n    /** @var \\Drupal\\menu_link_content\\Plugin\\Menu\\MenuLinkContent $parent_link */\n    $parent_link = MenuLinkContent::create([\n      'link' => ['uri' => 'internal:/admin/config'],\n      'title' => 'Configuration',\n      'menu_name' => 'main-menu',\n      'parent' => $root_link->getPluginId(),\n    ]);\n    $parent_link->save();\n\n    // Test menu link tokens.\n    $tokens = [\n      'id' => $parent_link->getPluginId(),\n      'title' => 'Configuration',\n      'menu' => 'Main menu',\n      'menu:name' => 'Main menu',\n      'menu:machine-name' => $menu->id(),\n      'menu:description' => 'The <em>Main</em> menu is used on many sites to show the major sections of the site, often in a top navigation bar.',\n      'menu:menu-link-count' => '2',\n      'menu:edit-url' => Url::fromRoute('entity.menu.edit_form', ['menu' => 'main-menu'], ['absolute' => TRUE])->toString(),\n      'url' => Url::fromRoute('system.admin_config', [], ['absolute' => TRUE])->toString(),\n      'url:absolute' => Url::fromRoute('system.admin_config', [], ['absolute' => TRUE])->toString(),\n      'url:relative' => Url::fromRoute('system.admin_config', [], ['absolute' => FALSE])->toString(),\n      'url:path' => '/admin/config',\n      'url:alias' => '/admin/config',\n      'edit-url' => Url::fromRoute('entity.menu_link_content.canonical', ['menu_link_content' => $parent_link->id()], ['absolute' => TRUE])->toString(),\n      'parent' => 'Administration',\n      'parent:id' => $root_link->getPluginId(),\n      'parent:title' => 'Administration',\n      'parent:menu' => 'Main menu',\n      'parent:parent' => NULL,\n      'parents' => 'Administration',\n      'parents:count' => 1,\n      'parents:keys' => $root_link->getPluginId(),\n      'root' => 'Administration',\n      'root:id' => $root_link->getPluginId(),\n      'root:parent' => NULL,\n      'root:root' => NULL,\n    ];\n    $this->assertTokens('menu-link', ['menu-link' => $parent_link], $tokens);\n\n    // Add a node.\n    $node = $this->drupalCreateNode();\n\n    // Allow main menu for this node type.\n    //$this->config('menu.entity.node.' . $node->getType())->set('available_menus', ['main-menu'])->save();\n\n    // Add a node menu link.\n    /** @var \\Drupal\\menu_link_content\\MenuLinkContentInterface $node_link */\n    $node_link = MenuLinkContent::create([\n      'link' => ['uri' => 'entity:node/' . $node->id()],\n      'title' => 'Node link',\n      'parent' => $parent_link->getPluginId(),\n      'menu_name' => 'main-menu',\n    ]);\n    $node_link->save();\n\n    // Test [node:menu] tokens.\n    $tokens = [\n      'menu-link' => 'Node link',\n      'menu-link:id' => $node_link->getPluginId(),\n      'menu-link:title' => 'Node link',\n      'menu-link:menu' => 'Main menu',\n      'menu-link:url' => $node->toUrl('canonical', ['absolute' => TRUE])->toString(),\n      'menu-link:url:path' => '/node/' . $node->id(),\n      'menu-link:edit-url' => $node_link->toUrl('edit-form', ['absolute' => TRUE])->toString(),\n      'menu-link:parent' => 'Configuration',\n      'menu-link:parent:id' => $parent_link->getPluginId(),\n      'menu-link:parents' => 'Administration, Configuration',\n      'menu-link:parents:count' => 2,\n      'menu-link:parents:keys' => $root_link->getPluginId() . ', ' . $parent_link->getPluginId(),\n      'menu-link:root' => 'Administration',\n      'menu-link:root:id' => $root_link->getPluginId(),\n    ];\n    $this->assertTokens('node', ['node' => $node], $tokens);\n\n    // Reload the node which will not have $node->menu defined and re-test.\n    $loaded_node = Node::load($node->id());\n    $this->assertTokens('node', ['node' => $loaded_node], $tokens);\n\n    // Regression test for http://drupal.org/node/1317926 to ensure the\n    // original node object is not changed when calling menu_node_prepare().\n    $this->assertTrue(!isset($loaded_node->menu), 'The $node->menu property was not modified during token replacement.', 'Regression');\n\n    // Now add a node with a menu-link from the UI and ensure it works.\n    $this->drupalLogin($this->drupalCreateUser([\n      'create page content',\n      'edit any page content',\n      'administer menu',\n      'administer nodes',\n      'administer content types',\n      'access administration pages',\n      'administer site configuration'\n    ]));\n    // Setup node type menu options.\n    $edit = [\n      'menu_options[main-menu]' => 1,\n      'menu_options[main]' => 1,\n      'menu_parent' => 'main-menu:',\n    ];\n    $this->drupalGet('admin/structure/types/manage/page');\n    $this->submitForm($edit, 'Save');\n\n    // Use a menu-link token in the body.\n    $this->drupalGet('node/add/page');\n    $this->submitForm([\n      // This should get replaced on save.\n      // @see token_module_test_node_presave()\n      'title[0][value]' => 'Node menu title test',\n      'body[0][value]' => 'This is a [node:menu-link:title] token to the menu link title',\n      'menu[enabled]' => 1,\n      'menu[title]' => 'Test preview',\n    ], 'Save');\n    $node = $this->drupalGetNodeByTitle('Node menu title test');\n    $this->assertEquals('This is a Test preview token to the menu link title', $node->body->value);\n\n    // Disable the menu link, save the node and verify that the menu link is\n    // no longer displayed.\n    $link = menu_ui_get_menu_link_defaults($node);\n    $this->drupalGet('admin/structure/menu/manage/main-menu');\n    $this->submitForm(['links[menu_plugin_id:' . $link['id'] . '][enabled]' => FALSE], 'Save');\n    $this->assertSession()->pageTextContains('Menu Main menu has been updated.');\n    $this->drupalGet('node/' . $node->id() . '/edit');\n    $this->submitForm([], 'Save');\n    $this->assertSession()->linkNotExists('Test preview');\n\n    // Now test a parent link and token.\n    $this->drupalGet('node/add/page');\n    // Make sure that the previous node save didn't result in two menu-links\n    // being created by the computed menu-link ER field.\n    // @see token_entity_base_field_info()\n    // @see token_node_menu_link_submit()\n    $selects = $this->cssSelect('select[name=\"menu[menu_parent]\"]');\n    $select = reset($selects);\n    $options = $select->findAll('css', 'option');\n    // Filter to items with title containing 'Test preview'.\n    $options = array_filter($options, function (NodeElement $element) {\n      return strpos($element->getText(), 'Test preview') !== FALSE;\n    });\n    $this->assertCount(1, $options);\n    $this->submitForm([\n      'title[0][value]' => 'Node menu title parent path test',\n      'body[0][value]' => 'This is a [node:menu-link:parent:url:path] token to the menu link parent',\n      'menu[enabled]' => 1,\n      'menu[title]' => 'Child link',\n      'menu[menu_parent]' => 'main-menu:' . $parent_link->getPluginId(),\n    ], 'Save');\n    $node = $this->drupalGetNodeByTitle('Node menu title parent path test');\n    $this->assertEquals('This is a /admin/config token to the menu link parent', $node->body->value);\n\n    // Now edit the node and update the parent and title.\n    $this->drupalGet('node/' . $node->id() . '/edit');\n    $this->submitForm([\n      'menu[menu_parent]' => 'main-menu:' . $node_link->getPluginId(),\n      'title[0][value]' => 'Node menu title edit parent path test',\n      'body[0][value]' => 'This is a [node:menu-link:parent:url:path] token to the menu link parent',\n    ], 'Save');\n    $node = $this->drupalGetNodeByTitle('Node menu title edit parent path test', TRUE);\n    $this->assertEquals(sprintf('This is a /node/%d token to the menu link parent', $loaded_node->id()), $node->body->value);\n\n    // Make sure that the previous node edit didn't result in two menu-links\n    // being created by the computed menu-link ER field.\n    // @see token_entity_base_field_info()\n    // @see token_node_menu_link_submit()\n    $this->drupalGet('node/add/page');\n    $selects = $this->cssSelect('select[name=\"menu[menu_parent]\"]');\n    $select = reset($selects);\n    $options = $select->findAll('css', 'option');\n    // Filter to items with title containing 'Test preview'.\n    $options = array_filter($options, function (NodeElement $item) {\n      return strpos($item->getText(), 'Child link') !== FALSE;\n    });\n    $this->assertCount(1, $options);\n\n    // Now add a new node with no menu.\n    $this->drupalGet('node/add/page');\n    $this->submitForm([\n      'title[0][value]' => 'Node menu adding menu later test',\n      'body[0][value]' => 'Going to add a menu link on edit',\n      'menu[enabled]' => 0,\n    ], 'Save');\n    $node = $this->drupalGetNodeByTitle('Node menu adding menu later test');\n    // Now edit it and add a menu item.\n    $this->drupalGet('node/' . $node->id() . '/edit');\n    $this->submitForm([\n      'title[0][value]' => 'Node menu adding menu later test',\n      'body[0][value]' => 'This is a [node:menu-link:parent:url:path] token to the menu link parent',\n      'menu[enabled]' => 1,\n      'menu[title]' => 'Child link',\n      'menu[menu_parent]' => 'main-menu:' . $parent_link->getPluginId(),\n    ], 'Save');\n    $node = $this->drupalGetNodeByTitle('Node menu adding menu later test', TRUE);\n    $this->assertEquals('This is a /admin/config token to the menu link parent', $node->body->value);\n    // And make sure the menu link exists with the right URI.\n    $link = menu_ui_get_menu_link_defaults($node);\n    $this->assertNotEmpty($link['entity_id']);\n    $query = \\Drupal::entityQuery('menu_link_content')\n      ->condition('link.uri', 'entity:node/' . $node->id())\n      ->accessCheck(TRUE)\n      ->sort('id', 'ASC')\n      ->range(0, 1);\n    $result = $query->execute();\n    $this->assertNotEmpty($result);\n\n    // Create a node with a menu link and create 2 menu links linking to this\n    // node after. Verify that the menu link provided by the node has priority.\n    $node_title = $this->randomMachineName();\n    $edit = [\n      'title[0][value]' => $node_title,\n      'menu[enabled]' => 1,\n      'menu[title]' => 'menu link provided by node',\n    ];\n    $this->drupalGet('node/add/page');\n    $this->submitForm($edit, 'Save');\n    $this->assertSession()->pageTextContains('page ' . $node_title . ' has been created');\n    $node = $this->drupalGetNodeByTitle($node_title);\n\n    $menu_ui_link1 = MenuLinkContent::create([\n      'link' => ['uri' => 'entity:node/' . $node->id()],\n      'title' => 'menu link 1 provided by menu ui',\n      'menu_name' => 'main-menu',\n    ]);\n    $menu_ui_link1->save();\n\n    $menu_ui_link2 = MenuLinkContent::create([\n      'link' => ['uri' => 'entity:node/' . $node->id()],\n      'title' => 'menu link 2 provided by menu ui',\n      'menu_name' => 'main-menu',\n    ]);\n    $menu_ui_link2->save();\n\n    $tokens = [\n      'menu-link' => 'menu link provided by node',\n      'menu-link:title' => 'menu link provided by node',\n    ];\n    $this->assertTokens('node', ['node' => $node], $tokens);\n  }\n\n  /**\n   * Tests that the module doesn't affect integrity of the menu, when\n   * translating them and that menu links tokens are correct.\n   */\n  function testMultilingualMenu() {\n    // Place the menu block.\n    $this->drupalPlaceBlock('system_menu_block:main');\n\n    // Add a second language.\n    $language = ConfigurableLanguage::create([\n      'id' => 'de',\n      'label' => 'German',\n    ]);\n    $language->save();\n\n    // Create the article content type.\n    $node_type = NodeType::create([\n      'type' => 'article',\n      'name' => 'Article',\n    ]);\n    $node_type->save();\n\n    $permissions = [\n      'access administration pages',\n      'administer content translation',\n      'administer content types',\n      'administer languages',\n      'create content translations',\n      'create article content',\n      'edit any article content',\n      'translate any entity',\n      'administer menu',\n    ];\n    $this->drupalLogin($this->drupalCreateUser($permissions));\n\n    // Enable translation for articles and menu links.\n    $this->drupalGet('admin/config/regional/content-language');\n    $edit = [\n      'entity_types[node]' => TRUE,\n      'entity_types[menu_link_content]' => TRUE,\n      'settings[node][article][translatable]' => TRUE,\n      'settings[node][article][fields][title]' => TRUE,\n      'settings[menu_link_content][menu_link_content][translatable]' => TRUE,\n    ];\n    $this->submitForm($edit, 'Save configuration');\n    $this->assertSession()->pageTextContains('Settings successfully updated.');\n\n    // Create an english node with an english menu.\n    $this->drupalGet('/node/add/article');\n    $edit = [\n      'title[0][value]' => 'English test node with menu',\n      'menu[enabled]' => TRUE,\n      'menu[title]' => 'English menu title',\n    ];\n    $this->drupalGet('/node/add/article');\n    $this->submitForm($edit, 'Save');\n    $this->assertSession()->pageTextContains('English test node with menu has been created.');\n\n    // Add a german translation.\n    $this->drupalGet('node/1/translations');\n    $this->clickLink('Add');\n    $edit = [\n      'title[0][value]' => 'German test node with menu',\n      'menu[enabled]' => TRUE,\n      'menu[title]' => 'German menu title',\n    ];\n    $this->submitForm($edit, 'Save (this translation)');\n    $this->assertSession()->pageTextContains('German test node with menu has been updated.');\n\n    // Verify that the menu links are correct.\n    $this->drupalGet('node/1');\n    $this->assertSession()->linkExists('English menu title');\n    $this->drupalGet('de/node/1');\n    $this->assertSession()->linkExists('German menu title');\n\n    // Verify that tokens are correct.\n    $node = Node::load(1);\n    $this->assertTokens('node', ['node' => $node], ['menu-link' => 'English menu title']);\n    $this->assertTokens('node', ['node' => $node], [\n      'menu-link' => 'German menu title',\n      'menu-link:title' => 'German menu title',\n    ], ['langcode' => 'de']);\n\n    // Get the menu link and create a child menu link to assert parent and root\n    // tokens.\n    $url = $node->toUrl();\n    /** @var \\Drupal\\Core\\Menu\\MenuLinkManagerInterface $menu_link_manager */\n    $menu_link_manager = \\Drupal::service('plugin.manager.menu.link');\n    $links = $menu_link_manager->loadLinksByRoute($url->getRouteName(), $url->getRouteParameters());\n    $link = reset($links);\n\n    $base_options = [\n      'provider' => 'menu_test',\n      'menu_name' => 'menu_test',\n    ];\n    $child_1 = $base_options + [\n        'title' => 'child_1 title EN',\n        'link' => ['uri' => 'internal:/menu-test/hierarchy/parent/child_1'],\n        'parent' => $link->getPluginId(),\n        'langcode' => 'en',\n      ];\n    $child_1 = MenuLinkContent::create($child_1);\n    $child_1->save();\n\n    // Add the german translation.\n    $child_1->addTranslation('de', ['title' => 'child_1 title DE'] + $child_1->toArray());\n    $child_1->save();\n\n    $this->assertTokens('menu-link', ['menu-link' => $child_1], [\n      'title' => 'child_1 title EN',\n      'parents' => 'English menu title',\n      'root' => 'English menu title',\n    ]);\n    $this->assertTokens('menu-link', ['menu-link' => $child_1], [\n      'title' => 'child_1 title DE',\n      'parents' => 'German menu title',\n      'root' => 'German menu title',\n    ], ['langcode' => 'de']);\n  }\n\n  /**\n   * Tests menu link parents token.\n   */\n  public function testMenuLinkParentsToken() {\n    // Create a menu with a simple link hierarchy :\n    // - parent\n    //   - child-1\n    //      - child-1-1\n    Menu::create([\n      'id' => 'menu_test',\n      'label' => 'Test menu',\n    ])->save();\n    $base_options = [\n      'provider' => 'menu_test',\n      'menu_name' => 'menu_test',\n    ];\n    $parent = $base_options + [\n        'title' => 'parent title',\n        'link' => ['uri' => 'internal:/menu-test/hierarchy/parent'],\n    ];\n    $parent = MenuLinkContent::create($parent);\n    $parent->save();\n    $child_1 = $base_options + [\n        'title' => 'child_1 title',\n        'link' => ['uri' => 'internal:/menu-test/hierarchy/parent/child_1'],\n        'parent' => $parent->getPluginId(),\n    ];\n    $child_1 = MenuLinkContent::create($child_1);\n    $child_1->save();\n    $child_1_1 = $base_options + [\n        'title' => 'child_1_1 title',\n        'link' => ['uri' => 'internal:/menu-test/hierarchy/parent/child_1/child_1_1'],\n        'parent' => $child_1->getPluginId(),\n    ];\n    $child_1_1 = MenuLinkContent::create($child_1_1);\n    $child_1_1->save();\n\n    $this->assertTokens('menu-link', ['menu-link' => $child_1_1], ['parents' => 'parent title, child_1 title']);\n\n    // Change the parent of child_1_1 to 'parent' at the entity level.\n    $child_1_1->parent->value = $parent->getPluginId();\n    $child_1_1->save();\n\n    $this->assertTokens('menu-link', ['menu-link' => $child_1_1], ['parents' => 'parent title']);\n\n    // Change the parent of child_1_1 to 'main', at the entity level.\n    $child_1_1->parent->value = '';\n    $child_1_1->save();\n\n    // The token shouldn't have been generated; the menu link has no parent.\n    $this->assertNoTokens('menu-link', ['menu-link' => $child_1_1], ['parents']);\n  }\n\n  /**\n   * Tests that no menu link is generated when the node gets previewed.\n   */\n  public function testPreviewMenuLink() {\n    $this->drupalCreateContentType(['type' => 'article']);\n    $permissions = [\n      'access administration pages',\n      'administer content types',\n      'create article content',\n      'edit any article content',\n      'administer menu',\n    ];\n    $this->drupalLogin($this->drupalCreateUser($permissions));\n    // Create an english node with an english menu.\n    $this->drupalGet('/node/add/article');\n    $edit = [\n      'title[0][value]' => 'English test node with menu',\n      'menu[enabled]' => TRUE,\n      'menu[title]' => 'English menu title',\n    ];\n    $this->drupalGet('node/add/article');\n    $this->submitForm($edit, 'Preview');\n    $menu_links = \\Drupal::entityTypeManager()->getStorage('menu_link_content')->loadByProperties(['menu_name' => 'main']);\n    $this->assertEmpty($menu_links);\n  }\n\n}\n"
    },
    {
        "path": "tests/src/Functional/TokenBlockTest.php",
        "contents": "<?php\n\nnamespace Drupal\\Tests\\token\\Functional;\n\nuse Drupal\\block_content\\Entity\\BlockContent;\nuse Drupal\\block_content\\Entity\\BlockContentType;\n\n/**\n * Tests block tokens.\n *\n * @group token\n */\nclass TokenBlockTest extends TokenTestBase {\n\n  /**\n   * {@inheritdoc}\n   */\n  protected static $modules = ['block', 'node', 'views', 'block_content'];\n\n  /**\n   * Admin user.\n   *\n   * @var \\Drupal\\user\\UserInterface\n   */\n  protected $adminUser;\n\n  /**\n   * {@inheritdoc}\n   */\n  public function setUp(): void {\n    parent::setUp();\n    $this->adminUser = $this->drupalCreateUser(['access content', 'administer blocks']);\n    $this->drupalLogin($this->adminUser);\n  }\n\n  /**\n   * {@inheritdoc}\n   */\n  public function testBlockTitleTokens(): void {\n    $label = 'tokenblock';\n    $bundle = BlockContentType::create([\n      'id' => $label,\n      'label' => $label,\n      'revision' => FALSE\n    ]);\n    $bundle->save();\n\n    $block_content = BlockContent::create([\n      'type' => $label,\n      'label' => '[current-page:title] block title',\n      'info' => 'Test token title block',\n      'body[value]' => 'This is the test token title block.',\n    ]);\n    $block_content->save();\n\n    $block = $this->drupalPlaceBlock('block_content:' . $block_content->uuid(), [\n      'label' => '[user:name]',\n    ]);\n    $this->drupalGet($block->toUrl());\n    // Ensure that the link to available tokens is present and correctly\n    // positioned.\n    $this->assertSession()->linkExists('Browse available tokens.');\n    $this->assertSession()->pageTextContains('This field supports tokens. Browse available tokens.');\n    $this->submitForm([], 'Save block');\n    // Ensure token validation is working on the block.\n    $this->assertSession()->pageTextContains('Title is using the following invalid tokens: [user:name].');\n\n    // Create the block for real now with a valid title.\n    $settings = $block->get('settings');\n    $settings['label'] = '[current-page:title] block title';\n    $block->set('settings', $settings);\n    $block->save();\n\n    // Ensure that tokens are not double-escaped when output as a block title.\n    $this->drupalCreateContentType(['type' => 'page']);\n    $node = $this->drupalCreateNode(['title' => \"Site's first node\"]);\n    $this->drupalGet('node/' . $node->id());\n    // The apostraphe should only be escaped once.\n    $this->assertSession()->responseContains(\"Site&#039;s first node block title\");\n  }\n}\n"
    },
    {
        "path": "tests/src/Functional/Tree/TreeTest.php",
        "contents": "<?php\n\nnamespace Drupal\\Tests\\token\\Functional\\Tree;\n\nuse Drupal\\Component\\Serialization\\Json;\nuse Drupal\\Tests\\token\\Functional\\TokenTestBase;\n\n/**\n * Tests token tree page.\n *\n * @group token\n */\nclass TreeTest extends TokenTestBase {\n\n  use TokenTreeTestTrait;\n\n  /**\n   * @var \\Drupal\\Core\\Session\\AccountInterface\n   */\n  protected $account;\n\n  /**\n   * {@inheritdoc}\n   */\n  protected static $modules = ['node'];\n\n  public function setUp(): void {\n    parent::setUp();\n\n    $this->account = $this->drupalCreateUser(['administer account settings']);\n    $this->drupalLogin($this->account);\n  }\n\n  /**\n   * Test various tokens that are possible on the site.\n   */\n  public function testAllTokens() {\n    $this->drupalGet($this->getTokenTreeUrl(['token_types' => 'all']));\n\n    $this->assertTokenGroup('Current date');\n    $this->assertTokenGroup('Site information');\n\n    $this->assertTokenInTree('[current-date:html_date]', 'current-date');\n    $this->assertTokenInTree('[current-date:html_week]', 'current-date');\n    $this->assertTokenInTree('[date:html_date]', 'date');\n    $this->assertTokenInTree('[date:html_week]', 'date');\n\n    $this->assertTokenInTree('[current-user:account-name]', 'current-user');\n    $this->assertTokenInTree('[user:account-name]', 'user');\n\n    $this->assertTokenInTree('[current-page:url:unaliased]', 'current-page--url');\n    $this->assertTokenInTree('[current-page:url:unaliased:args]', 'current-page--url--unaliased');\n    $this->assertTokenInTree('[user:original:account-name]', 'user--original');\n  }\n\n  /**\n   * Test various tokens that are possible on the site.\n   */\n  public function testGlobalTokens() {\n    $this->drupalGet($this->getTokenTreeUrl());\n\n    $this->assertTokenGroup('Current date');\n    $this->assertTokenGroup('Site information');\n\n    // Assert that non-global tokens are not listed.\n    $this->assertTokenNotInTree('[user:account-name]', 'user');\n    $this->assertTokenNotInTree('[user:original:account-name]', 'user--original');\n\n    // Assert some of the global tokens, just to be sure.\n    $this->assertTokenInTree('[current-date:html_date]', 'current-date');\n    $this->assertTokenInTree('[current-date:html_week]', 'current-date');\n\n    $this->assertTokenInTree('[current-user:account-name]', 'current-user');\n\n    $this->assertTokenInTree('[current-page:url:unaliased]', 'current-page--url');\n    $this->assertTokenInTree('[current-page:url:unaliased:args]', 'current-page--url--unaliased');\n  }\n\n  /**\n   * Tests if the token browser displays the user tokens.\n   */\n  public function testUserTokens() {\n    $this->drupalGet($this->getTokenTreeUrl(['token_types' => ['user']]));\n\n    $this->assertTokenGroup('Users');\n\n    $this->assertTokenInTree('[user:account-name]', 'user');\n    $this->assertTokenInTree('[user:original:account-name]', 'user--original');\n\n    // Assert some of the restricted tokens to ensure they are not shown.\n    $this->assertTokenNotInTree('[user:one-time-login-url]', 'user');\n    $this->assertTokenNotInTree('[user:original:cancel-url]', 'user--original');\n\n    // Request with show_restricted set to TRUE to show restricted tokens and\n    // check for them.\n    $this->drupalGet($this->getTokenTreeUrl(['token_types' => ['user'], 'show_restricted' => TRUE]));\n    $this->assertEquals('MISS', $this->getSession()->getResponseHeader('x-drupal-dynamic-cache'), 'Cache was not hit');\n    $this->assertTokenInTree('[user:one-time-login-url]', 'user');\n    $this->assertTokenInTree('[user:original:cancel-url]', 'user--original');\n  }\n\n  /**\n   * Tests if the token browser displays the node tokens.\n   */\n  public function testNodeTokens() {\n    $this->drupalGet($this->getTokenTreeUrl(['token_types' => ['node']]));\n\n    $this->assertTokenGroup('Nodes');\n\n    $this->assertTokenInTree('[node:body]', 'node');\n    $this->assertTokenInTree('[node:author:original:account-name]', 'node--author--original');\n  }\n\n  /**\n   * Get the URL for the token tree based on the specified options.\n   *\n   * The token tree route's URL requires CSRF and cannot be generated in the\n   * test code. The CSRF token generated using the test runner's session is\n   * different from the session inside the test environment. This is why the\n   * link has to be generated inside the environment.\n   *\n   * This function calls a page in token_module_test module which generates the\n   * link and the token. This then replaces the options query parameter with the\n   * specified options.\n   *\n   * The page also uses a title callback to set title to a render array, which\n   * allows us to test if [current-page:title] works properly.\n   *\n   * @param array $options\n   *   The options for the token tree browser.\n   *\n   * @return string\n   *   The complete URL of the token tree browser with the CSRF token.\n   */\n  protected function getTokenTreeUrl($options = []) {\n    $this->drupalGet('token_module_test/browse');\n    $this->assertSession()->titleEquals('Available Tokens | Drupal');\n    $links = $this->xpath('//a[contains(@href, :href)]/@href', [':href' => 'token/tree']);\n    $link = $this->getAbsoluteUrl(current($links)->getText());\n    if (!empty($options)) {\n      $options = Json::encode($options);\n      $link = str_replace('options=%5B%5D', 'options=' . urlencode($options), $link);\n    }\n    return $link;\n  }\n}\n"
    },
    {
        "path": "tests/src/Functional/Tree/HelpPageTest.php",
        "contents": "<?php\n\nnamespace Drupal\\Tests\\token\\Functional\\Tree;\n\nuse Drupal\\Tests\\token\\Functional\\TokenTestBase;\n\n/**\n * Tests token tree on help page.\n *\n * @group token\n */\nclass HelpPageTest extends TokenTestBase {\n\n  use TokenTreeTestTrait;\n\n  /**\n   * @var \\Drupal\\Core\\Session\\AccountInterface\n   */\n  protected $account;\n\n  /**\n   * {@inheritdoc}\n   */\n  protected static $modules = ['help'];\n\n  public function setUp(): void {\n    parent::setUp();\n\n    // On Drupal 10.2 there is new permission to access help pages.\n    $permissions = ['access help pages'];\n    if (version_compare(\\Drupal::VERSION, '10.2', '<')) {\n      $permissions = ['access administration pages'];\n    }\n    $this->account = $this->drupalCreateUser($permissions);\n    $this->drupalLogin($this->account);\n  }\n\n  /**\n   * Tests the token browser on the token help page.\n   */\n  public function testHelpPageTree() {\n    $this->drupalGet('admin/help/token');\n    $this->assertSession()->pageTextContains('The list of the currently available tokens on this site are shown below.');\n\n    $this->assertTokenGroup('Current date');\n    $this->assertTokenGroup('Site information');\n\n    $this->assertTokenInTree('[current-date:html_date]', 'current-date');\n    $this->assertTokenInTree('[current-date:html_week]', 'current-date');\n    $this->assertTokenInTree('[date:html_date]', 'date');\n    $this->assertTokenInTree('[date:html_week]', 'date');\n\n    $this->assertTokenInTree('[current-user:account-name]', 'current-user');\n    $this->assertTokenInTree('[user:account-name]', 'user');\n\n    $this->assertTokenInTree('[current-page:url:unaliased]', 'current-page--url');\n    $this->assertTokenInTree('[current-page:url:unaliased:args]', 'current-page--url--unaliased');\n    $this->assertTokenInTree('[user:original:account-name]', 'user--original');\n\n    // Assert some of the restricted tokens to ensure they are shown.\n    $this->assertTokenInTree('[user:one-time-login-url]', 'user');\n    $this->assertTokenInTree('[user:original:cancel-url]', 'user--original');\n\n    // The Array token is marked as nested, so it should not show up as a top\n    // level token, only nested under another token. For instance, user:roles\n    // is of type Array and tokens of type Array have 'nested' setting true.\n    $this->assertTokenNotGroup('Array');\n    $this->assertTokenNotGroup('user:roles');\n    $this->assertTokenInTree('[user:roles]', 'user');\n  }\n\n}\n"
    },
    {
        "path": "tests/src/Functional/Tree/TokenTreeTestTrait.php",
        "contents": "<?php\n\nnamespace Drupal\\Tests\\token\\Functional\\Tree;\n\nuse Behat\\Mink\\Element\\NodeElement;\n\n/**\n * Helper trait to assert tokens in token tree browser.\n */\ntrait TokenTreeTestTrait {\n\n  /**\n   * Get an array of token groups from the last retrieved page.\n   *\n   * @return array\n   *   Array of token group names.\n   */\n  protected function getTokenGroups() {\n    $groups = $this->xpath('//tr[contains(@class, \"token-group\")]/td[1]');\n    return array_map(function (NodeElement $item) {\n      return (string) $item->getText();\n    }, $groups);\n  }\n\n  /**\n   * Check to see if the specified token group is present in the token browser.\n   *\n   * @param string $token_group\n   *   The name of the token group.\n   * @param string $message\n   *   (optional) A message to display with the assertion.\n   */\n  protected function assertTokenGroup($token_group, $message = '') {\n    $groups = $this->getTokenGroups();\n\n    if (!$message) {\n      $message = \"Token group $token_group found.\";\n    }\n\n    $this->assertContains($token_group, $groups, $message);\n  }\n\n  /**\n   * Check to see if the specified token group is not present in the token\n   * browser.\n   *\n   * @param string $token_group\n   *   The name of the token group.\n   * @param string $message\n   *   (optional) A message to display with the assertion.\n   */\n  protected function assertTokenNotGroup($token_group, $message = '') {\n    $groups = $this->getTokenGroups();\n\n    if (!$message) {\n      $message = \"Token group $token_group not found.\";\n    }\n\n    $this->assertNotContains($token_group, $groups, $message);\n  }\n\n  /**\n   * Check to see if the specified token is present in the token browser.\n   *\n   * @param $token\n   *   The token name with the surrounding square brackets [].\n   * @param string $parent\n   *   (optional) The parent CSS identifier of this token.\n   * @param string $message\n   *   (optional) A message to display with the assertion.\n   */\n  protected function assertTokenInTree($token, $parent = '', $message = '') {\n    $xpath = $this->getXpathForTokenInTree($token, $parent);\n\n    if (!$message) {\n      $message = \"Token $token found.\";\n    }\n\n    $this->assertCount(1, $this->xpath($xpath), $message);\n  }\n\n  /**\n   * Check to see if the specified token is present in the token browser.\n   *\n   * @param $token\n   *   The token name with the surrounding square brackets [].\n   * @param string $parent\n   *   (optional) The parent CSS identifier of this token.\n   * @param string $message\n   *   (optional) A message to display with the assertion.\n   */\n  protected function assertTokenNotInTree($token, $parent = '', $message = '') {\n    $xpath = $this->getXpathForTokenInTree($token, $parent);\n\n    if (!$message) {\n      $message = \"Token $token not found.\";\n    }\n\n    $this->assertCount(0, $this->xpath($xpath), $message);\n  }\n\n  /**\n   * Get xpath to check for token in tree.\n   *\n   * @param $token\n   *   The token name with the surrounding square brackets [].\n   * @param string $parent\n   *   (optional) The parent CSS identifier of this token.\n   *\n   * @return string\n   *   The xpath to check for the token and parent.\n   */\n  protected function getXpathForTokenInTree($token, $parent = '') {\n    $xpath = \"//tr\";\n    if ($parent) {\n      $xpath .= '[@data-tt-parent-id=\"token-' . $parent . '\"]';\n    }\n    $xpath .= '/td[contains(@class, \"token-key\") and text() = \"' . $token . '\"]';\n    return $xpath;\n  }\n}\n"
    },
    {
        "path": "tests/src/Kernel/MockLanguageManager.php",
        "contents": "<?php\n\nnamespace Drupal\\Tests\\token\\Kernel;\n\nuse Drupal\\Core\\Language\\LanguageInterface;\nuse Drupal\\language\\ConfigurableLanguageManager;\n\n/**\n * A language manager that can be easily overridden for testing purposes.\n */\nclass MockLanguageManager extends ConfigurableLanguageManager {\n\n  /**\n   * List of current languages used in the test.\n   *\n   * @var \\Drupal\\Core\\Language\\LanguageInterface[]\n   */\n  protected $currentLanguages;\n\n  /**\n   * {@inheritdoc}\n   */\n  public function getCurrentLanguage($type = LanguageInterface::TYPE_INTERFACE) {\n    if (isset($this->currentLanguages[$type])) {\n      return $this->currentLanguages[$type];\n    }\n    return parent::getCurrentLanguage($type);\n  }\n\n  /**\n   * Sets the current language of the given type to use during tests.\n   *\n   * @param string $type\n   *   The language type.\n   * @param \\Drupal\\Core\\Language\\LanguageInterface $language\n   *   The language.\n   */\n  public function setCurrentLanguage($type, LanguageInterface $language) {\n    $this->currentLanguages[$type] = $language;\n  }\n\n}\n"
    },
    {
        "path": "tests/src/Kernel/ViewsTest.php",
        "contents": "<?php\n\nnamespace Drupal\\Tests\\token\\Kernel;\n\nuse Drupal\\views\\Tests\\ViewTestData;\nuse Drupal\\views\\Views;\n\n/**\n * Test the views tokens.\n *\n * @group token\n */\nclass ViewsTest extends TokenKernelTestBase {\n\n  /**\n   * {@inheritdoc}\n   */\n  protected static $modules = ['views', 'block'];\n\n  /**\n   * Views used by this test.\n   *\n   * @var array\n   */\n  public static $testViews = ['token_views_test'];\n\n  /**\n   * {@inheritdoc}\n   */\n  protected function setUp(): void {\n    parent::setUp();\n    $this->installEntitySchema('user');\n    ViewTestData::createTestViews(get_class($this), ['token_module_test']);\n  }\n\n  /**\n   * Tests path token replacements generated from a view without a path.\n   */\n  public function testTokenReplacementNoPath() {\n    $token_handler = \\Drupal::token();\n    $view = Views::getView('token_views_test');\n    $view->setDisplay('block_1');\n    $view->execute();\n\n    $this->assertSame('', $token_handler->replace('[view:url]', ['view' => $view]), 'Token [view:url] is empty for views without path.');\n  }\n\n}\n"
    },
    {
        "path": "tests/src/Kernel/RandomTest.php",
        "contents": "<?php\n\nnamespace Drupal\\Tests\\token\\Kernel;\n\n/**\n * Tests random tokens.\n *\n * @group token\n */\nclass RandomTest extends TokenKernelTestBase {\n\n  function testRandomTokens() {\n    $tokens = [\n      'number' => '[0-9]{1,}',\n      'hash:md5' => '[0-9a-f]{32}',\n      'hash:sha1' => '[0-9a-f]{40}',\n      'hash:sha256' => '[0-9a-f]{64}',\n      'hash:invalid-algo' => NULL,\n    ];\n\n    $first_set = $this->assertTokens('random', [], $tokens, ['regex' => TRUE]);\n    $second_set = $this->assertTokens('random', [], $tokens, ['regex' => TRUE]);\n    foreach ($first_set as $token => $value) {\n      $this->assertNotSame($first_set[$token], $second_set[$token]);\n    }\n  }\n\n}\n"
    },
    {
        "path": "tests/src/Kernel/UnitTest.php",
        "contents": "<?php\n\nnamespace Drupal\\Tests\\token\\Kernel;\n\n/**\n * Test basic, low-level token functions.\n *\n * @group token\n */\nclass UnitTest extends TokenKernelTestBase {\n\n  /**\n   * @var \\Drupal\\token\\Token\n   */\n  protected $tokenService;\n\n  /**\n   * {@inheritdoc}\n   */\n  protected static $modules = ['file', 'node'];\n\n  /**\n   * {@inheritdoc}\n   */\n  public function setUp(): void {\n    parent::setUp();\n    $this->tokenService = \\Drupal::token();\n  }\n\n  /**\n   * Test invalid tokens.\n   */\n  public function testGetInvalidTokens() {\n    $tests = [];\n    $tests[] = [\n      'valid tokens' => [\n        '[node:title]',\n        '[node:created:short]',\n        '[node:created:custom:invalid]',\n        '[node:created:custom:mm-YYYY]',\n        '[node:colons:in:name]',\n        '[site:name]',\n        '[site:slogan]',\n        '[current-date:short]',\n        '[current-user:uid]',\n        '[current-user:ip-address]',\n      ],\n      'invalid tokens' => [\n        '[node:title:invalid]',\n        '[node:created:invalid]',\n        '[node:created:short:invalid]',\n        '[node:colons:in:name:invalid]',\n        '[invalid:title]',\n        '[site:invalid]',\n        '[user:ip-address]',\n        '[user:uid]',\n        '[comment:cid]',\n        // Deprecated tokens\n        '[node:tnid]',\n        '[node:type]',\n        '[node:type-name]',\n        '[date:short]',\n      ],\n      'types' => ['node'],\n    ];\n    $tests[] = [\n      'valid tokens' => [\n        '[node:title]',\n        '[node:created:short]',\n        '[node:created:custom:invalid]',\n        '[node:created:custom:mm-YYYY]',\n        '[node:colons:in:name]',\n        '[site:name]',\n        '[site:slogan]',\n        '[user:uid]',\n        '[current-date:short]',\n        '[current-user:uid]',\n      ],\n      'invalid tokens' => [\n        '[node:title:invalid]',\n        '[node:created:invalid]',\n        '[node:created:short:invalid]',\n        '[node:colons:in:name:invalid]',\n        '[invalid:title]',\n        '[site:invalid]',\n        '[user:ip-address]',\n        '[comment:cid]',\n        // Deprecated tokens\n        '[node:tnid]',\n        '[node:type]',\n        '[node:type-name]',\n      ],\n      'types' => ['all'],\n    ];\n\n    foreach ($tests as $test) {\n      $tokens = array_merge($test['valid tokens'], $test['invalid tokens']);\n      shuffle($tokens);\n\n      $invalid_tokens = $this->tokenService->getInvalidTokensByContext(implode(' ', $tokens), $test['types']);\n\n      sort($invalid_tokens);\n      sort($test['invalid tokens']);\n      $this->assertEquals($test['invalid tokens'], $invalid_tokens, 'Invalid tokens detected properly: ' . implode(', ', $invalid_tokens));\n    }\n  }\n\n  /**\n   * Test that tokens are generated only for content entities.\n   */\n  public function testContentEntityOnlyTokens() {\n    // Verify that type and token info for a config entity is not generated.\n    $this->assertNull($this->tokenService->getTokenInfo('user_role', 'original'));\n    $this->assertNull($this->tokenService->getTokenInfo('user_role', 'url'));\n    $this->assertNull($this->tokenService->getTypeInfo('user_role'));\n  }\n\n}\n"
    },
    {
        "path": "tests/src/Kernel/CommentTest.php",
        "contents": "<?php\n\nnamespace Drupal\\Tests\\token\\Kernel;\n\nuse Drupal\\comment\\Entity\\Comment;\nuse Drupal\\comment\\Tests\\CommentTestTrait;\nuse Drupal\\Core\\Url;\nuse Drupal\\node\\Entity\\Node;\nuse Drupal\\node\\Entity\\NodeType;\n\n/**\n * Tests comment tokens.\n *\n * @group token\n */\nclass CommentTest extends TokenKernelTestBase {\n\n  use CommentTestTrait;\n\n  /**\n   * {@inheritdoc}\n   */\n  protected static $modules = [\n    'node',\n    'comment',\n    'field',\n    'text',\n  ];\n\n  /**\n   * {@inheritdoc}\n   */\n  protected function setUp(): void {\n    parent::setUp();\n\n    $this->installEntitySchema('node');\n    $this->installEntitySchema('user');\n    $this->installEntitySchema('comment');\n    $this->installSchema('comment', ['comment_entity_statistics']);\n\n    $node_type = NodeType::create(['type' => 'page', 'name' => 'Page']);\n    $node_type->save();\n\n    $this->installConfig(['comment']);\n\n    $this->addDefaultCommentField('node', 'page');\n  }\n\n  /**\n   *\n   */\n  public function testCommentTokens() {\n    $node = Node::create([\n      'type' => 'page',\n      'title' => $this->randomMachineName(),\n    ]);\n    $node->save();\n\n    $parent_comment = Comment::create([\n      'entity_id' => $node->id(),\n      'entity_type' => 'node',\n      'field_name' => 'comment',\n      'name' => 'anonymous user',\n      'mail' => 'anonymous@example.com',\n      'subject' => $this->randomMachineName(),\n      'body' => $this->randomMachineName(),\n    ]);\n    $parent_comment->save();\n\n    // Fix http://example.com/index.php/comment/1 fails 'url:path' test.\n    $parent_comment_path = $parent_comment->toUrl()->toString();\n\n    $tokens = [\n      'url' => $parent_comment->toUrl('canonical', ['fragment' => \"comment-{$parent_comment->id()}\"])->setAbsolute()->toString(),\n      'url:absolute' => $parent_comment->toUrl('canonical', ['fragment' => \"comment-{$parent_comment->id()}\"])->setAbsolute()->toString(),\n      'url:relative' => $parent_comment->toUrl('canonical', ['fragment' => \"comment-{$parent_comment->id()}\"])->toString(),\n      'url:path' => $parent_comment_path,\n      'parent:url:absolute' => NULL,\n    ];\n    $this->assertTokens('comment', ['comment' => $parent_comment], $tokens);\n\n    $comment = Comment::create([\n      'entity_id' => $node->id(),\n      'pid' => $parent_comment->id(),\n      'entity_type' => 'node',\n      'field_name' => 'comment',\n      'name' => 'anonymous user',\n      'mail' => 'anonymous@example.com',\n      'subject' => $this->randomMachineName(),\n      'body' => $this->randomMachineName(),\n    ]);\n    $comment->save();\n\n    // Fix http://example.com/index.php/comment/1 fails 'url:path' test.\n    $comment_path = Url::fromRoute('entity.comment.canonical', ['comment' => $comment->id()])->toString();\n\n    $tokens = [\n      'url' => $comment->toUrl('canonical', ['fragment' => \"comment-{$comment->id()}\"])->setAbsolute()->toString(),\n      'url:absolute' => $comment->toUrl('canonical', ['fragment' => \"comment-{$comment->id()}\"])->setAbsolute()->toString(),\n      'url:relative' => $comment->toUrl('canonical', ['fragment' => \"comment-{$comment->id()}\"])->toString(),\n      'url:path' => $comment_path,\n      'parent:url:absolute' => $parent_comment->toUrl('canonical', ['fragment' => \"comment-{$parent_comment->id()}\"])->setAbsolute()->toString(),\n    ];\n    $this->assertTokens('comment', ['comment' => $comment], $tokens);\n  }\n\n}\n"
    },
    {
        "path": "tests/src/Kernel/FileTest.php",
        "contents": "<?php\n\nnamespace Drupal\\Tests\\token\\Kernel;\n\nuse Drupal\\file\\Entity\\File;\n/**\n * Tests file tokens.\n *\n * @group token\n */\nclass FileTest extends TokenKernelTestBase {\n\n  /**\n   * {@inheritdoc}\n   */\n  protected static $modules = ['file'];\n\n  /**\n   * {@inheritdoc}\n   */\n  public function setUp(): void {\n    parent::setUp();\n    $this->installEntitySchema('file');\n  }\n\n  function testFileTokens() {\n    // Create a test file object.\n    $file = File::create([\n      'fid' => 1,\n      'filename' => 'test.png',\n      'filesize' => 100,\n      'uri' => 'public://images/test.png',\n      'filemime' => 'image/png',\n    ]);\n\n    $tokens = [\n      'basename' => 'test.png',\n      'extension' => 'png',\n      'size-raw' => 100,\n    ];\n    $this->assertTokens('file', ['file' => $file], $tokens);\n\n    // Test a file with no extension and a fake name.\n    $file->filename = 'Test PNG image';\n    $file->uri = 'public://images/test';\n\n    $tokens = [\n      'basename' => 'test',\n      'extension' => '',\n      'size-raw' => 100,\n    ];\n    $this->assertTokens('file', ['file' => $file], $tokens);\n  }\n\n}\n"
    },
    {
        "path": "tests/src/Kernel/TokenKernelTestBase.php",
        "contents": "<?php\n\nnamespace Drupal\\Tests\\token\\Kernel;\n\nuse Drupal\\KernelTests\\KernelTestBase;\nuse Drupal\\Tests\\token\\Functional\\TokenTestTrait;\n\n/**\n * Helper test class with some added functions for testing.\n */\nabstract class TokenKernelTestBase extends KernelTestBase {\n\n  use TokenTestTrait;\n\n  /**\n   * {@inheritdoc}\n   */\n  protected static $modules = [\n    'path',\n    'token',\n    'token_module_test',\n    'system',\n    'user',\n    'path_alias',\n  ];\n\n  /**\n   * {@inheritdoc}\n   */\n  protected function setUp(): void {\n    parent::setUp();\n\n    $this->installEntitySchema('path_alias');\n    \\Drupal::service('router.builder')->rebuild();\n    $this->installConfig(['system']);\n  }\n\n}\n"
    },
    {
        "path": "tests/src/Kernel/ValidateD7MigrationStateTest.php",
        "contents": "<?php\n\nnamespace Drupal\\Tests\\token\\Kernel;\n\nuse Drupal\\Tests\\migrate_drupal\\Kernel\\d7\\MigrateDrupal7TestBase;\nuse Drupal\\Tests\\migrate_drupal\\Traits\\ValidateMigrationStateTestTrait;\n\n/**\n * Tests that the token test has a declared D7 migration status.\n *\n * ValidateMigrationStateTestTrait::testMigrationState() will succeed if the\n * modules enabled in \\Drupal\\Tests\\KernelTestBase::bootKernel() have a valid\n * migration status (i.e.: finished or not_finished); but will fail if they do\n * not have a declared migration status.\n *\n * @group token\n */\nclass ValidateD7MigrationStateTest extends MigrateDrupal7TestBase {\n  use ValidateMigrationStateTestTrait;\n\n  /**\n   * {@inheritdoc}\n   */\n  protected static $modules = ['token'];\n\n}\n"
    },
    {
        "path": "tests/src/Kernel/KernelTestBase.php",
        "contents": "<?php\n\nnamespace Drupal\\Tests\\token\\Kernel;\n\n@\\trigger_error('The ' . __NAMESPACE__ . '\\KernelTestBase class is deprecated in token:8.x-1.14 and is removed from token:2.0.0. Use \\Drupal\\Tests\\token\\Kernel\\TokenKernelTestBase instead. See https://www.drupal.org/node/3440940', E_USER_DEPRECATED);\n\n/**\n * Helper test class with some added functions for testing.\n *\n * @deprecated in token:8.x-1.14 and is removed from token:2.0.0. Use\n *   \\Drupal\\Tests\\token\\Kernel\\TokenKernelTestBase instead.\n *\n * @see https://www.drupal.org/node/3440940\n */\nabstract class KernelTestBase extends TokenKernelTestBase {\n}\n"
    },
    {
        "path": "tests/src/Kernel/EntityTest.php",
        "contents": "<?php\n\nnamespace Drupal\\Tests\\token\\Kernel;\n\nuse Drupal\\node\\Entity\\Node;\nuse Drupal\\taxonomy\\Entity\\Term;\nuse Drupal\\taxonomy\\Entity\\Vocabulary;\nuse Drupal\\taxonomy\\VocabularyInterface;\n\n/**\n * Tests entity tokens.\n *\n * @group token\n */\nclass EntityTest extends TokenKernelTestBase {\n\n  /**\n   * {@inheritdoc}\n   */\n  protected static $modules = ['node', 'taxonomy', 'text'];\n\n  /**\n   * Vocabulary for testing chained token support.\n   *\n   * @var \\Drupal\\taxonomy\\VocabularyInterface\n   */\n  protected $vocabulary;\n\n  /**\n   * {@inheritdoc}\n   */\n  public function setUp(): void {\n    parent::setUp();\n\n    // Create the default tags vocabulary.\n    $this->vocabulary = Vocabulary::create([\n      'name' => 'Tags',\n      'vid' => 'tags',\n    ]);\n    $this->vocabulary->save();\n\n    $this->installEntitySchema('taxonomy_term');\n    $this->installEntitySchema('user');\n    $this->installEntitySchema('node');\n  }\n\n  function testEntityMapping() {\n    /** @var \\Drupal\\token\\TokenEntityMapperInterface $mapper */\n    $mapper = \\Drupal::service('token.entity_mapper');\n    $this->assertSame('node', $mapper->getEntityTypeForTokenType('node'));\n    $this->assertSame('taxonomy_term', $mapper->getEntityTypeForTokenType('term'));\n    $this->assertSame('taxonomy_vocabulary', $mapper->getEntityTypeForTokenType('vocabulary'));\n    $this->assertSame(FALSE, $mapper->getEntityTypeForTokenType('invalid'));\n    $this->assertSame('invalid', $mapper->getEntityTypeForTokenType('invalid', TRUE));\n    $this->assertSame('node', $mapper->getTokenTypeForEntityType('node'));\n    $this->assertSame('term', $mapper->getTokenTypeForEntityType('taxonomy_term'));\n    $this->assertSame('vocabulary', $mapper->getTokenTypeForEntityType('taxonomy_vocabulary'));\n    $this->assertSame(FALSE, $mapper->getTokenTypeForEntityType('invalid'));\n    $this->assertSame('invalid', $mapper->getTokenTypeForEntityType('invalid', TRUE));\n\n    // Test that when we send the mis-matched entity type into\n    // Drupal\\Core\\Utility\\Token::replace() that we still get the tokens\n    // replaced.\n    $vocabulary = Vocabulary::load('tags');\n    $term = $this->addTerm($vocabulary);\n    $this->assertSame($vocabulary->label(), \\Drupal::token()->replace('[vocabulary:name]', ['taxonomy_vocabulary' => $vocabulary]));\n    $this->assertSame($term->label() . $vocabulary->label(), \\Drupal::token()->replace('[term:name][term:vocabulary:name]', ['taxonomy_term' => $term]));\n  }\n\n  function addTerm(VocabularyInterface $vocabulary, array $term = []) {\n    $term += [\n      'name' => mb_strtolower($this->randomMachineName(5)),\n      'vid' => $vocabulary->id(),\n    ];\n    $term = Term::create($term);\n    $term->save();\n    return $term;\n  }\n\n  /**\n   * Test the [entity:original:*] tokens.\n   */\n  function testEntityOriginal() {\n    $node = Node::create(['type' => 'page', 'title' => 'Original title']);\n    $node->save();\n\n    $tokens = [\n      'nid' => $node->id(),\n      'title' => 'Original title',\n      'original' => NULL,\n      'original:nid' => NULL,\n    ];\n    $this->assertTokens('node', ['node' => $node], $tokens);\n\n    // Emulate the original entity property that would be available from\n    // node_save() and change the title for the node.\n    $node->original = \\Drupal::entityTypeManager()->getStorage('node')->loadUnchanged($node->id());\n    $node->title = 'New title';\n\n    $tokens = [\n      'nid' => $node->id(),\n      'title' => 'New title',\n      'original' => 'Original title',\n      'original:nid' => $node->id(),\n    ];\n    $this->assertTokens('node', ['node' => $node], $tokens);\n  }\n\n}\n"
    },
    {
        "path": "tests/src/Kernel/DateTest.php",
        "contents": "<?php\n\nnamespace Drupal\\Tests\\token\\Kernel;\n\n/**\n * Tests date tokens.\n *\n * @group token\n */\nclass DateTest extends TokenKernelTestBase {\n\n  /**\n   * {@inheritdoc}\n   */\n  protected static $modules = [];\n\n  /**\n   * {@inheritdoc}\n   */\n  protected function setUp(): void {\n    parent::setUp();\n    $this->installConfig(['system', 'token_module_test']);\n  }\n\n  function testDateTokens() {\n    $tokens = [\n      'token_module_test' => '1984',\n      'invalid_format' => NULL,\n    ];\n\n    $this->assertTokens('date', ['date' => 453859200], $tokens);\n  }\n\n}\n"
    },
    {
        "path": "tests/src/Kernel/LanguageTest.php",
        "contents": "<?php\n\nnamespace Drupal\\Tests\\token\\Kernel;\n\nuse Drupal\\Core\\DependencyInjection\\ContainerBuilder;\nuse Drupal\\Core\\Language\\Language;\nuse Drupal\\Core\\Language\\LanguageInterface;\nuse Drupal\\Core\\Render\\BubbleableMetadata;\nuse Drupal\\language\\Entity\\ConfigurableLanguage;\n\n/**\n * Tests language tokens.\n *\n * @group token\n */\nclass LanguageTest extends TokenKernelTestBase {\n\n  /**\n   * {@inheritdoc}\n   */\n  protected static $modules = [\n    'language',\n    'token',\n  ];\n\n  /**\n   * Language codes of languages to enable during the test.\n   *\n   * @var array\n   */\n  protected $langcodes = ['bg', 'hu', 'nl', 'pt-pt'];\n\n  /**\n   * An array of languages used during the test, keyed by language code.\n   *\n   * @var \\Drupal\\language\\Entity\\ConfigurableLanguage[]\n   */\n  protected $languages = [];\n\n  /**\n   * Language prefixes used during the test.\n   *\n   * @var array\n   */\n  protected $language_prefixes = [];\n\n  /**\n   * Language domains used during the test.\n   *\n   * @var array\n   */\n  protected $language_domains = [];\n\n  /**\n   * The token replacement service.\n   *\n   * @var \\Drupal\\Core\\Utility\\Token\n   */\n  protected $token;\n\n  /**\n   * The mock language manager service.\n   *\n   * @var \\Drupal\\Tests\\token\\Kernel\\MockLanguageManager\n   */\n  protected $languageManager;\n\n  /**\n   * {@inheritdoc}\n   */\n  public function register(ContainerBuilder $container) {\n    parent::register($container);\n\n    // Use Portuguese as the default language during the test. We're not using\n    // English so we can detect if the default language is correctly honored.\n    $language = Language::$defaultValues;\n    $language['id'] = 'pt-pt';\n    $language['name'] = 'Portuguese, Portugal';\n    $container->setParameter('language.default_values', $language);\n    $this->container\n      ->register('language.default', 'Drupal\\Core\\Language\\LanguageDefault')\n      ->addArgument('%language.default_values%');\n  }\n\n  /**\n   * {@inheritdoc}\n   */\n  protected function setUp(): void {\n    parent::setUp();\n\n    $this->token = $this->container->get('token');\n\n    // Use a version of the language manager in which the various languages can\n    // be easily overridden during the test. We need to do this here instead of\n    // in ::register() since the container is being altered by\n    // LanguageServiceProvider::alter() after the services have been registered.\n    $this->languageManager = new MockLanguageManager(\n      $this->container->get('language.default'),\n      $this->container->get('config.factory'),\n      $this->container->get('module_handler'),\n      $this->container->get('language.config_factory_override'),\n      $this->container->get('request_stack')\n    );\n    $this->container->set('language_manager', $this->languageManager);\n\n    foreach ($this->langcodes as $langcode) {\n      // Enable test languages.\n      $this->languages[$langcode] = ConfigurableLanguage::createFromLangcode($langcode);\n      $this->languages[$langcode]->save();\n\n      // Populate language prefixes and domains to use in the test.\n      $this->language_prefixes[$langcode] = \"$langcode-prefix\";\n      $this->language_domains[$langcode] = $langcode . '.example.com';\n    }\n\n    // Set language negotiation prefixes and domains to values that are uniquely\n    // identifiable in the test.\n    $language_negotiation_config = $this->config('language.negotiation');\n    $language_negotiation_config->set('url.prefixes', $this->language_prefixes);\n    $language_negotiation_config->set('url.domains', $this->language_domains);\n    $language_negotiation_config->save();\n  }\n\n  /**\n   * Tests the language tokens.\n   *\n   * @dataProvider languageTokenReplacementDataProvider\n   */\n  public function testLanguageTokenReplacement($token, $langcode, $expected_result) {\n    $bubbleable_metadata = new BubbleableMetadata();\n    $options = $langcode ? ['langcode' => $langcode] : [];\n    // The part of the token name between the last `:` and the closing bracket\n    // is the machine name of the token.\n    preg_match('/\\[.+:(.+)\\]/', $token, $matches);\n    $name = $matches[1];\n    $replacements = $this->token->generate('language', [$name => $token], [], $options, $bubbleable_metadata);\n    $this->assertEquals($expected_result, $replacements[$token]);\n  }\n\n  /**\n   * Tests retrieving the interface and content language from the current page.\n   *\n   * @dataProvider currentPageLanguageTokenReplacementDataProvider\n   */\n  public function testCurrentPageLanguageTokenReplacement($token, $langcode, $expected_result) {\n    // Set the interface language to Dutch.\n    $this->languageManager->setCurrentLanguage(LanguageInterface::TYPE_INTERFACE, $this->languages['nl']);\n    // Set the content language to Hungarian.\n    $this->languageManager->setCurrentLanguage(LanguageInterface::TYPE_CONTENT, $this->languages['hu']);\n\n    $options = $langcode ? ['langcode' => $langcode] : [];\n    $result = $this->token->replace($token, [], $options);\n    $this->assertEquals($expected_result, $result);\n  }\n\n  /**\n   * Provides test data for ::testLanguageTokenReplacement().\n   *\n   * @return array\n   *   An array of test cases. Each test case is an array with the following\n   *   values:\n   *   - The token to test.\n   *   - An optional language code to pass as an option.\n   *   - The expected result of the token replacement.\n   *\n   * @see testLanguageTokenReplacement()\n   */\n  public function languageTokenReplacementDataProvider() {\n    return [\n      [\n        // Test the replacement of the name of the site default language.\n        '[language:name]',\n        // We are not overriding the language by passing a language code as an\n        // option. This means that the default language should be used which has\n        // been set to Portuguese.\n        NULL,\n        // The expected result.\n        'Portuguese, Portugal',\n      ],\n      // Test the replacement of the other properties of the default language.\n      [\n        '[language:langcode]',\n        NULL,\n        'pt-pt',\n      ],\n      [\n        '[language:direction]',\n        NULL,\n        'ltr',\n      ],\n      [\n        '[language:domain]',\n        NULL,\n        'pt-pt.example.com',\n      ],\n      [\n        '[language:prefix]',\n        NULL,\n        'pt-pt-prefix',\n      ],\n      // Now repeat the entire test but override the language to use by passing\n      // Bulgarian as an option.\n      [\n        '[language:name]',\n        'bg',\n        'Bulgarian',\n      ],\n      [\n        '[language:langcode]',\n        'bg',\n        'bg',\n      ],\n      [\n        '[language:direction]',\n        'bg',\n        'ltr',\n      ],\n      [\n        '[language:domain]',\n        'bg',\n        'bg.example.com',\n      ],\n      [\n        '[language:prefix]',\n        'bg',\n        'bg-prefix',\n      ],\n    ];\n  }\n\n  /**\n   * Provides test data for ::testCurrentPageLanguageTokenReplacement().\n   *\n   * @return array\n   *   An array of test cases. Each test case is an array with the following\n   *   values:\n   *   - The token to test.\n   *   - An optional language code to pass as an option.\n   *   - The expected result of the token replacement.\n   *\n   * @see testCurrentPageLanguageTokenReplacement()\n   */\n  public function currentPageLanguageTokenReplacementDataProvider() {\n    return [\n      [\n        // Test the replacement of the language name token, taken from the\n        // interface language of the current page.\n        '[current-page:interface-language:name]',\n        // We are not overriding the language by passing a language code as an\n        // option. This means that the language should be taken from the\n        // interface language which has been set to Dutch.\n        NULL,\n        // The expected result.\n        'Dutch',\n      ],\n      // Test the token name in the content language.\n      [\n        '[current-page:content-language:name]',\n        NULL,\n        'Hungarian',\n      ],\n      // Test the other tokens both for the content and interface languages.\n      [\n        '[current-page:interface-language:langcode]',\n        NULL,\n        'nl',\n      ],\n      [\n        '[current-page:content-language:langcode]',\n        NULL,\n        'hu',\n      ],\n      [\n        '[current-page:interface-language:direction]',\n        NULL,\n        'ltr',\n      ],\n      [\n        '[current-page:content-language:direction]',\n        NULL,\n        'ltr',\n      ],\n      [\n        '[current-page:interface-language:domain]',\n        NULL,\n        'nl.example.com',\n      ],\n      [\n        '[current-page:content-language:domain]',\n        NULL,\n        'hu.example.com',\n      ],\n      [\n        '[current-page:interface-language:prefix]',\n        NULL,\n        'nl-prefix',\n      ],\n      [\n        '[current-page:content-language:prefix]',\n        NULL,\n        'hu-prefix',\n      ],\n      // Now repeat the entire test with Bulgarian passed as an option. This\n      // should not affect the results, the language should be sourced from the\n      // current page.\n      [\n        // Test the replacement of the language name token, taken from the\n        // interface language of the current page.\n        '[current-page:interface-language:name]',\n        // We are not overriding the language by passing a language code as an\n        // option. This means that the language should be taken from the\n        // interface language which has been set to Dutch.\n        'bg',\n        // The expected result.\n        'Dutch',\n      ],\n      // Test the token name in the content language.\n      [\n        '[current-page:content-language:name]',\n        'bg',\n        'Hungarian',\n      ],\n      // Test the other tokens both for the content and interface languages.\n      [\n        '[current-page:interface-language:langcode]',\n        'bg',\n        'nl',\n      ],\n      [\n        '[current-page:content-language:langcode]',\n        'bg',\n        'hu',\n      ],\n      [\n        '[current-page:interface-language:direction]',\n        'bg',\n        'ltr',\n      ],\n      [\n        '[current-page:content-language:direction]',\n        'bg',\n        'ltr',\n      ],\n      [\n        '[current-page:interface-language:domain]',\n        'bg',\n        'nl.example.com',\n      ],\n      [\n        '[current-page:content-language:domain]',\n        'bg',\n        'hu.example.com',\n      ],\n      [\n        '[current-page:interface-language:prefix]',\n        'bg',\n        'nl-prefix',\n      ],\n      [\n        '[current-page:content-language:prefix]',\n        'bg',\n        'hu-prefix',\n      ],\n    ];\n  }\n\n}\n"
    },
    {
        "path": "tests/src/Kernel/BookTest.php",
        "contents": "<?php\n\nnamespace Drupal\\Tests\\token\\Kernel;\n\nuse Drupal\\Core\\Url;\nuse Drupal\\node\\Entity\\Node;\n\n/**\n * Test the book tokens.\n *\n * @group token\n */\nclass BookTest extends TokenKernelTestBase {\n\n  /**\n   * {@inheritdoc}\n   */\n  protected static $modules = [\n    'user',\n    'field',\n    'filter',\n    'text',\n    'node',\n    'book',\n  ];\n\n  /**\n   * {@inheritdoc}\n   */\n  protected function setUp(): void {\n    parent::setUp();\n\n    $this->installEntitySchema('user');\n    $this->installEntitySchema('node');\n    $this->installSchema('book', ['book']);\n    $this->installSchema('node', ['node_access']);\n    $this->installConfig(['node', 'book', 'field']);\n  }\n\n  /**\n   *\n   */\n  public function testBookTokens() {\n    $book = Node::create([\n      'type' => 'book',\n      'title' => 'Book Main Page',\n      'book' => ['bid' => 'new'],\n    ]);\n    $book->save();\n\n    $page1 = Node::create([\n      'type' => 'book',\n      'title' => '1st Page',\n      'book' => ['bid' => $book->id(), 'pid' => $book->id()],\n    ]);\n    $page1->save();\n\n    $page2 = Node::create([\n      'type' => 'book',\n      'title' => '2nd Page',\n      'book' => ['bid' => $book->id(), 'pid' => $page1->id()],\n    ]);\n    $page2->save();\n\n    $book_title = $book->getTitle();\n\n    $tokens = [\n      'nid' => $book->id(),\n      'title' => $book_title,\n      'book:title' => $book_title,\n      'book:root' => $book_title,\n      'book:root:nid' => $book->id(),\n      'book:root:title' => $book_title,\n      'book:root:url' => Url::fromRoute('entity.node.canonical', ['node' => $book->id()], ['absolute' => TRUE])->toString(),\n      'book:root:content-type' => 'Book page',\n      'book:parent' => NULL,\n      'book:parents' => NULL,\n    ];\n    $this->assertTokens('node', ['node' => $book], $tokens);\n\n    $tokens = [\n      'nid' => $page1->id(),\n      'title' => $page1->getTitle(),\n      'book:title' => $book_title,\n      'book:root' => $book_title,\n      'book:root:nid' => $book->id(),\n      'book:root:title' => $book_title,\n      'book:root:url' => Url::fromRoute('entity.node.canonical', ['node' => $book->id()], ['absolute' => TRUE])->toString(),\n      'book:root:content-type' => 'Book page',\n      'book:parent:nid' => $book->id(),\n      'book:parent:title' => $book_title,\n      'book:parent:url' => Url::fromRoute('entity.node.canonical', ['node' => $book->id()], ['absolute' => TRUE])->toString(),\n      'book:parents:count' => 1,\n      'book:parents:join:/' => $book_title,\n    ];\n    $this->assertTokens('node', ['node' => $page1], $tokens);\n\n    $tokens = [\n      'nid' => $page2->id(),\n      'title' => $page2->getTitle(),\n      'book:title' => $book_title,\n      'book:root' => $book_title,\n      'book:root:nid' => $book->id(),\n      'book:root:title' => $book_title,\n      'book:root:url' => Url::fromRoute('entity.node.canonical', ['node' => $book->id()], ['absolute' => TRUE])->toString(),\n      'book:root:content-type' => 'Book page',\n      'book:parent:nid' => $page1->id(),\n      'book:parent:title' => $page1->getTitle(),\n      'book:parent:url' => Url::fromRoute('entity.node.canonical', ['node' => $page1->id()], ['absolute' => TRUE])->toString(),\n      'book:parents:count' => 2,\n      'book:parents:join:/' => $book_title . '/' . $page1->getTitle(),\n    ];\n    $this->assertTokens('node', ['node' => $page2], $tokens);\n  }\n\n}\n"
    },
    {
        "path": "tests/src/Kernel/UrlTest.php",
        "contents": "<?php\n\nnamespace Drupal\\Tests\\token\\Kernel;\n\nuse Drupal\\Core\\Url;\nuse Symfony\\Component\\HttpFoundation\\Request;\n\n/**\n * Test generic url token replacements.\n *\n * @group token\n */\nclass UrlTest extends TokenKernelTestBase {\n\n  /**\n   * The token service.\n   *\n   * @var \\Drupal\\Core\\Utility\\Token\n   */\n  protected $token;\n\n  /**\n   * The current request stack.\n   *\n   * @var \\Symfony\\Component\\HttpFoundation\\RequestStack\n   */\n  protected $requestStack;\n\n  /**\n   * The current route match.\n   *\n   * @var \\Drupal\\Core\\Routing\\CurrentRouteMatch\n   */\n  protected $currentRouteMatch;\n\n  /**\n   * {@inheritdoc}\n   */\n  protected function setUp(): void {\n    parent::setUp();\n    $this->token = $this->container->get('token');\n    $this->requestStack = $this->container->get('request_stack');\n    $this->currentRouteMatch = $this->container->get('current_route_match');\n  }\n\n  /**\n   * Test the url token replacements for current requests.\n   *\n   * The method ::expectedCurrentRequestUrlResults() is not declared\n   * as a regular data provider, because it might use services from\n   * the global Drupal container, which is not initialized yet during\n   * the invocation of data providers.\n   */\n  public function testCurrentRequestUrls() {\n    foreach ($this->expectedCurrentRequestUrlResults() as $data_set) {\n      list ($request, $text, $data, $options, $expected_output) = $data_set;\n      // Set the request as the current one.\n      $this->requestStack->pop();\n      $this->requestStack->push($request);\n      $this->currentRouteMatch->resetRouteMatch();\n\n      $this->assertEquals($expected_output, $this->token->replace($text, $data, $options));\n    }\n  }\n\n  /**\n   * Provides a list of results to expect for ::testRequestUrls().\n   *\n   * Each data set of this array holds the following order:\n   *   - The request object to test for.\n   *   - The input text as string.\n   *   - The token data as array.\n   *   - Further options for the token replacement as array.\n   *   - The output to expect after token replacement.\n   *\n   * @return array\n   *   The list of results to expect.\n   */\n  public function expectedCurrentRequestUrlResults() {\n    return [\n      [Request::createFromGlobals(), '[current-page:url]', [], [], Url::createFromRequest(Request::createFromGlobals())->setAbsolute()->toString()],\n      [Request::create('/should-not-exist'), '[current-page:url:path]', [], [], '/'],\n      [Request::create('/https://drupal.org/'), '[current-page:url:absolute]', [], [], '[current-page:url:absolute]'],\n      [Request::create('/https://drupal.org/'), '[current-page:url:absolute]', [], ['clear' => TRUE], ''],\n    ];\n  }\n\n}\n"
    },
    {
        "path": "tests/src/Kernel/FieldTest.php",
        "contents": "<?php\n\nnamespace Drupal\\Tests\\token\\Kernel;\n\nuse Drupal\\Component\\Utility\\Html;\nuse Drupal\\Component\\Utility\\Unicode;\nuse Drupal\\contact\\Entity\\ContactForm;\nuse Drupal\\contact\\Entity\\Message;\nuse Drupal\\Core\\Entity\\Entity\\EntityViewMode;\nuse Drupal\\Core\\Field\\FieldStorageDefinitionInterface;\nuse Drupal\\Core\\Render\\Markup;\nuse Drupal\\datetime\\Plugin\\Field\\FieldType\\DateTimeItem;\nuse Drupal\\datetime_range\\Plugin\\Field\\FieldType\\DateRangeItem;\nuse Drupal\\field\\Entity\\FieldConfig;\nuse Drupal\\field\\Entity\\FieldStorageConfig;\nuse Drupal\\filter\\Entity\\FilterFormat;\nuse Drupal\\language\\Entity\\ConfigurableLanguage;\nuse Drupal\\node\\Entity\\Node;\nuse Drupal\\node\\Entity\\NodeType;\nuse Drupal\\Tests\\taxonomy\\Traits\\TaxonomyTestTrait;\n\n/**\n * Tests field tokens.\n *\n * @group token\n */\nclass FieldTest extends TokenKernelTestBase {\n\n  use TaxonomyTestTrait;\n\n  /**\n   * @var \\Drupal\\filter\\FilterFormatInterface\n   */\n  protected $testFormat;\n\n\n  /**\n   * Vocabulary for testing chained token support.\n   *\n   * @var \\Drupal\\taxonomy\\VocabularyInterface\n   */\n  protected $vocabulary;\n\n  /**\n   * The field used in this test class.\n   *\n   * @var \\Drupal\\field\\Entity\\FieldConfig\n   */\n  protected $field;\n\n  /**\n   * {@inheritdoc}\n   */\n  protected static $modules = [\n    'node',\n    'text',\n    'field',\n    'filter',\n    'contact',\n    'options',\n    'taxonomy',\n    'language',\n    'datetime',\n    'datetime_range',\n  ];\n\n  /**\n   * {@inheritdoc}\n   */\n  public function setUp(): void {\n    parent::setUp();\n\n    $this->installEntitySchema('user');\n    $this->installEntitySchema('node');\n    $this->installEntitySchema('taxonomy_term');\n\n    // Create the article content type with a text field.\n    $node_type = NodeType::create([\n      'type' => 'article',\n    ]);\n    $node_type->save();\n\n    $field_storage = FieldStorageConfig::create([\n      'field_name' => 'test_field',\n      'entity_type' => 'node',\n      'type' => 'text',\n    ]);\n    $field_storage->save();\n\n    $field = FieldConfig::create([\n      'field_name' => 'test_field',\n      'entity_type' => 'node',\n      'bundle' => 'article',\n      'label' => 'Test field',\n    ]);\n    $field->save();\n\n    // Create a reference field with the same name on user.\n    $field_storage = FieldStorageConfig::create([\n      'field_name' => 'test_field',\n      'entity_type' => 'user',\n      'type' => 'entity_reference',\n    ]);\n    $field_storage->save();\n\n    $field = FieldConfig::create([\n      'field_name' => 'test_field',\n      'entity_type' => 'user',\n      'bundle' => 'user',\n      'label' => 'Test field',\n    ]);\n    $field->save();\n\n    $this->testFormat = FilterFormat::create([\n      'format' => 'test',\n      'name' => 'Test format',\n      'weight' => 1,\n      'filters' => [\n        'filter_html_escape' => ['status' => TRUE],\n      ],\n    ]);\n    $this->testFormat->save();\n\n    // Create a multi-value list_string field.\n    $field_storage = FieldStorageConfig::create([\n      'field_name' => 'test_list',\n      'entity_type' => 'node',\n      'type' => 'list_string',\n      'cardinality' => 2,\n      'settings' => [\n        'allowed_values' => [\n          'key1' => 'value1',\n          'key2' => 'value2',\n        ],\n      ],\n    ]);\n    $field_storage->save();\n\n    $this->field = FieldConfig::create([\n      'field_name' => 'test_list',\n      'entity_type' => 'node',\n      'bundle' => 'article',\n    ])->save();\n\n    // Add an untranslatable node reference field.\n    FieldStorageConfig::create([\n      'field_name' => 'test_reference',\n      'type' => 'entity_reference',\n      'entity_type' => 'node',\n      'settings' => [\n        'target_type' => 'node',\n      ],\n      'translatable' => FALSE,\n    ])->save();\n    FieldConfig::create([\n      'field_name' => 'test_reference',\n      'entity_type' => 'node',\n      'bundle' => 'article',\n      'label' => 'Test reference',\n    ])->save();\n\n    // Add an untranslatable taxonomy term reference field.\n    $this->vocabulary = $this->createVocabulary();\n\n    FieldStorageConfig::create([\n      'field_name' => 'test_term_reference',\n      'type' => 'entity_reference',\n      'entity_type' => 'node',\n      'settings' => [\n        'target_type' => 'taxonomy_term',\n      ],\n      'translatable' => FALSE,\n    ])->save();\n    FieldConfig::create([\n      'field_name' => 'test_term_reference',\n      'entity_type' => 'node',\n      'bundle' => 'article',\n      'label' => 'Test term reference',\n      'settings' => [\n        'handler' => 'default:taxonomy_term',\n        'handler_settings' => [\n          'target_bundles' => [\n            $this->vocabulary->id() => $this->vocabulary->id(),\n          ],\n        ],\n      ],\n    ])->save();\n\n    // Add a field to terms of the created vocabulary.\n    $storage = FieldStorageConfig::create([\n      'field_name' => 'term_field',\n      'entity_type' => 'taxonomy_term',\n      'type' => 'text',\n    ]);\n    $storage->save();\n    $field = FieldConfig::create([\n      'field_name' => 'term_field',\n      'entity_type' => 'taxonomy_term',\n      'bundle' => $this->vocabulary->id(),\n    ]);\n    $field->save();\n\n    // Add a second language.\n    $language = ConfigurableLanguage::create([\n      'id' => 'de',\n      'label' => 'German',\n    ]);\n    $language->save();\n\n    // Add a datetime field.\n    $field_datetime_storage = FieldStorageConfig::create([\n      'field_name' => 'field_datetime',\n      'type' => 'datetime',\n      'entity_type' => 'node',\n      'settings' => ['datetime_type' => DateTimeItem::DATETIME_TYPE_DATETIME],\n      'cardinality' => FieldStorageDefinitionInterface::CARDINALITY_UNLIMITED,\n    ]);\n    $field_datetime_storage->save();\n    $field_datetime = FieldConfig::create([\n      'field_storage' => $field_datetime_storage,\n      'bundle' => 'article',\n    ]);\n    $field_datetime->save();\n\n    // Add a daterange field.\n    $field_daterange_storage = FieldStorageConfig::create([\n      'field_name' => 'field_daterange',\n      'type' => 'daterange',\n      'entity_type' => 'node',\n      'settings' => ['datetime_type' => DateRangeItem::DATETIME_TYPE_DATETIME],\n      'cardinality' => FieldStorageDefinitionInterface::CARDINALITY_UNLIMITED,\n    ]);\n    $field_daterange_storage->save();\n    $field_daterange = FieldConfig::create([\n      'field_storage' => $field_daterange_storage,\n      'bundle' => 'article',\n    ]);\n    $field_daterange->save();\n\n    // Add a timestamp field.\n    $field_timestamp_storage = FieldStorageConfig::create([\n      'field_name' => 'field_timestamp',\n      'type' => 'timestamp',\n      'entity_type' => 'node',\n      'cardinality' => FieldStorageDefinitionInterface::CARDINALITY_UNLIMITED,\n    ]);\n    $field_timestamp_storage->save();\n    $field_timestamp = FieldConfig::create([\n      'field_storage' => $field_timestamp_storage,\n      'bundle' => 'article',\n    ]);\n    $field_timestamp->save();\n  }\n\n  /**\n   * Tests [entity:field_name] tokens.\n   */\n  public function testEntityFieldTokens() {\n    // Create a node with a value in its fields and test its tokens.\n    $entity = Node::create([\n      'title' => 'Test node title',\n      'type' => 'article',\n      'test_field' => [\n        'value' => 'foo',\n        'format' => $this->testFormat->id(),\n      ],\n      'test_list' => [\n        'value1',\n        'value2',\n      ],\n    ]);\n    $entity->save();\n    $this->assertTokens('node', ['node' => $entity], [\n      'test_field' => Markup::create('foo'),\n      'test_field:0' => Markup::create('foo'),\n      'test_field:0:value' => 'foo',\n      'test_field:value' => 'foo',\n      'test_field:0:format' => $this->testFormat->id(),\n      'test_field:format' => $this->testFormat->id(),\n      'test_list:0' => Markup::create('value1'),\n      'test_list:1' => Markup::create('value2'),\n      'test_list:0:value' => Markup::create('value1'),\n      'test_list:value' => Markup::create('value1'),\n      'test_list:1:value' => Markup::create('value2'),\n    ]);\n\n    // Verify that no third token was generated for the list_string field.\n    $this->assertNoTokens('node', ['node' => $entity], [\n      'test_list:2',\n      'test_list:2:value',\n    ]);\n\n    // Test the test_list token metadata.\n    $tokenService = \\Drupal::service('token');\n    $token_info = $tokenService->getTokenInfo('node', 'test_list');\n    $this->assertEquals('test_list', $token_info['name']);\n    $this->assertEquals('token', $token_info['module']);\n    $this->assertEquals('list<node-test_list>', $token_info['type']);\n    $typeInfo = $tokenService->getTypeInfo('list<node-test_list>');\n    $this->assertEquals('List of test_list values', $typeInfo['name']);\n    $this->assertEquals('list<node-test_list>', $typeInfo['type']);\n\n    // Create a node type that does not have test_field field.\n    $node_type = NodeType::create([\n      'type' => 'page',\n    ]);\n    $node_type->save();\n\n    $node_without_test_field = Node::create([\n      'title' => 'Node without test_field',\n      'type' => 'page',\n    ]);\n    $node_without_test_field->save();\n\n    // Ensure that trying to generate tokens for a non-existing field does not\n    // throw an exception.\n    $this->assertNoTokens('node', ['node' => $node_without_test_field], ['test_field']);\n\n    // Create a node without a value in the text field and test its token.\n    $entity = Node::create([\n      'title' => 'Test node title',\n      'type' => 'article',\n    ]);\n    $entity->save();\n\n    $this->assertNoTokens('node', ['node' => $entity], [\n      'test_field',\n    ]);\n  }\n\n  /**\n   * Tests the token metadata for a field token.\n   */\n  public function testFieldTokenInfo() {\n    /** @var \\Drupal\\token\\Token $tokenService */\n    $tokenService = \\Drupal::service('token');\n\n    // Test the token info of the text field of the artcle content type.\n    $token_info = $tokenService->getTokenInfo('node', 'test_field');\n    $this->assertEquals('Test field', $token_info['name'], 'The token info name is correct.');\n    $this->assertEquals('Text (formatted) field.', $token_info['description'], 'The token info description is correct.');\n    $this->assertEquals('token', $token_info['module'], 'The token info module is correct.');\n\n    // Now create two more content types that share the field but the last\n    // of them sets a different label. This should show an alternative label\n    // at the token info.\n    $node_type = NodeType::create([\n      'type' => 'article2',\n    ]);\n    $node_type->save();\n    $field = FieldConfig::create([\n      'field_name' => 'test_field',\n      'entity_type' => 'node',\n      'bundle' => 'article2',\n      'label' => 'Test field',\n    ]);\n    $field->save();\n\n    $node_type = NodeType::create([\n      'type' => 'article3',\n    ]);\n    $node_type->save();\n    $field = FieldConfig::create([\n      'field_name' => 'test_field',\n      'entity_type' => 'node',\n      'bundle' => 'article3',\n      'label' => 'Different test field',\n    ]);\n    $field->save();\n\n    $token_info = $tokenService->getTokenInfo('node', 'test_field');\n    $this->assertEquals('Test field', $token_info['name'], 'The token info name is correct.');\n    $this->assertEquals('Text (formatted) field. Also known as <em class=\"placeholder\">Different test field</em>.', (string) $token_info['description'], 'When a field is used in several bundles with different labels, this is noted at the token info description.');\n    $this->assertEquals('token', $token_info['module'], 'The token info module is correct.');\n    $this->assertEquals('node-test_field', $token_info['type'], 'The field property token info type is correct.');\n\n    // Test field property token info.\n    $token_info = $tokenService->getTokenInfo('node-test_field', 'value');\n    $this->assertEquals('Text', $token_info['name'], 'The field property token info name is correct.');\n    // This particular field property description happens to be empty.\n    $this->assertEquals('', (string) $token_info['description'], 'The field property token info description is correct.');\n    $this->assertEquals('token', $token_info['module'], 'The field property token info module is correct.');\n  }\n\n  /**\n   * Test tokens on node with the token view mode overriding default formatters.\n   */\n  public function testTokenViewMode() {\n    $value = 'A really long string that should be trimmed by the special formatter on token view we are going to have.';\n\n    // The formatter we are going to use will eventually call Unicode::strlen.\n    // This expects that the Unicode has already been explicitly checked, which\n    // happens in DrupalKernel. But since that doesn't run in kernel tests, we\n    // explicitly call this here.\n    Unicode::check();\n\n    // Create a node with a value in the text field and test its token.\n    $entity = Node::create([\n      'title' => 'Test node title',\n      'type' => 'article',\n      'test_field' => [\n        'value' => $value,\n        'format' => $this->testFormat->id(),\n      ],\n    ]);\n    $entity->save();\n\n    $this->assertTokens('node', ['node' => $entity], [\n      'test_field' => Markup::create($value),\n    ]);\n\n    // Now, create a token view mode which sets a different format for\n    // test_field. When replacing tokens, this formatter should be picked over\n    // the default formatter for the field type.\n    // @see field_tokens().\n    $view_mode = EntityViewMode::create([\n      'id' => 'node.token',\n      'targetEntityType' => 'node',\n    ]);\n    $view_mode->save();\n    $entity_display = \\Drupal::service('entity_display.repository')->getViewDisplay('node', 'article', 'token');\n    $entity_display->setComponent('test_field', [\n      'type' => 'text_trimmed',\n      'settings' => [\n        'trim_length' => 50,\n      ],\n    ]);\n    $entity_display->save();\n\n    $this->assertTokens('node', ['node' => $entity], [\n      'test_field' => Markup::create(substr($value, 0, 50)),\n    ]);\n  }\n\n  /**\n   * Test that tokens are properly created for an entity's base fields.\n   */\n  public function testBaseFieldTokens() {\n    // Create a new contact_message entity and verify that tokens are generated\n    // for its base fields. The contact_message entity type is used because it\n    // provides no tokens by default.\n    $contact_form = ContactForm::create([\n      'id' => 'form_id',\n    ]);\n    $contact_form->save();\n\n    $entity = Message::create([\n      'contact_form' => 'form_id',\n      'uuid' => '123',\n      'langcode' => 'en',\n      'name' => 'Test name',\n      'mail' => 'Test mail',\n      'subject' => 'Test subject',\n      'message' => 'Test message',\n      'copy' => FALSE,\n    ]);\n    $entity->save();\n    $this->assertTokens('contact_message', ['contact_message' => $entity], [\n      'uuid' => Markup::create('123'),\n      'langcode' => Markup::create('English'),\n      'name' => Markup::create('Test name'),\n      'mail' => Markup::create('Test mail'),\n      'subject' => Markup::create('Test subject'),\n      'message' => Markup::create('Test message'),\n      'copy' => 'Off',\n    ]);\n\n    // Test the metadata of one of the tokens.\n    $tokenService = \\Drupal::service('token');\n    $token_info = $tokenService->getTokenInfo('contact_message', 'subject');\n    $this->assertEquals($token_info['name'], 'Subject');\n    $this->assertEquals($token_info['description'], 'Text (plain) field.');\n    $this->assertEquals($token_info['module'], 'token');\n\n    // Verify that node entity type doesn't have a uid token.\n    $this->assertNull($tokenService->getTokenInfo('node', 'uid'));\n  }\n\n  /**\n   * Tests chaining entity reference tokens.\n   */\n  public function testEntityReferenceTokens() {\n    $reference = Node::create([\n      'title' => 'Test node to reference',\n      'type' => 'article',\n      'test_field' => [\n        'value' => 'foo',\n        'format' => $this->testFormat->id(),\n      ],\n    ]);\n    $reference->save();\n    $term_reference_field_value = $this->randomString();\n    $term_reference = $this->createTerm($this->vocabulary, [\n      'name' => 'Term to reference',\n      'term_field' => [\n        'value' => $term_reference_field_value,\n        'format' => $this->testFormat->id(),\n      ],\n    ]);\n    $entity = Node::create([\n      'title' => 'Test entity reference',\n      'type' => 'article',\n      'test_reference' => ['target_id' => $reference->id()],\n      'test_term_reference' => ['target_id' => $term_reference->id()],\n    ]);\n    $entity->save();\n\n    $this->assertTokens('node', ['node' => $entity], [\n      'test_reference:entity:title' => Markup::create('Test node to reference'),\n      'test_reference:entity:test_field' => Markup::create('foo'),\n      'test_term_reference:entity:term_field' => Html::escape($term_reference_field_value),\n      'test_reference:target_id' => $reference->id(),\n      'test_term_reference:target_id' => $term_reference->id(),\n      'test_term_reference:entity:url:path' => '/' . $term_reference->toUrl('canonical')->getInternalPath(),\n      // Expects the entity's label to be returned for :entity tokens.\n      'test_reference:entity' => $reference->label(),\n      'test_term_reference:entity' => $term_reference->label(),\n    ]);\n\n    // Test some non existent tokens.\n    $this->assertNoTokens('node', ['node' => $entity], [\n      'test_reference:1:title',\n      'test_reference:entity:does_not_exist',\n      'test_reference:does_not:exist',\n      'test_term_reference:does_not_exist',\n      'test_term_reference:does:not:exist',\n      'test_term_reference:does_not_exist:0',\n      'non_existing_field:entity:title',\n    ]);\n\n    /** @var \\Drupal\\token\\Token $token_service */\n    $token_service = \\Drupal::service('token');\n\n    $token_info = $token_service->getTokenInfo('node', 'test_reference');\n    $this->assertEquals('Test reference', $token_info['name']);\n    $this->assertEquals('Entity reference field.', (string) $token_info['description']);\n    $this->assertEquals('token', $token_info['module']);\n    $this->assertEquals('node-test_reference', $token_info['type']);\n\n    // Test target_id field property token info.\n    $token_info = $token_service->getTokenInfo('node-test_reference', 'target_id');\n    $this->assertEquals('Content ID', $token_info['name']);\n    $this->assertEquals('token', $token_info['module']);\n    $this->assertEquals('token', $token_info['module']);\n\n    // Test entity field property token info.\n    $token_info = $token_service->getTokenInfo('node-test_reference', 'entity');\n    $this->assertEquals('Content', $token_info['name']);\n    $this->assertEquals('The referenced entity', $token_info['description']);\n    $this->assertEquals('token', $token_info['module']);\n    $this->assertEquals('node', $token_info['type']);\n\n    // Test entity field property token info of the term reference.\n    $token_info = $token_service->getTokenInfo('node-test_term_reference', 'entity');\n    $this->assertEquals('Taxonomy term', $token_info['name']);\n    $this->assertEquals('The referenced entity', $token_info['description']);\n    $this->assertEquals('token', $token_info['module']);\n    $this->assertEquals('term', $token_info['type']);\n\n  }\n\n  /**\n   * Tests support for cardinality > 1 for entity reference tokens.\n   */\n  public function testEntityReferenceTokensCardinality() {\n    /** @var \\Drupal\\field\\FieldStorageConfigInterface $storage */\n    $storage = FieldStorageConfig::load('node.test_term_reference');\n    $storage->setCardinality(FieldStorageDefinitionInterface::CARDINALITY_UNLIMITED);\n    $storage->save();\n\n    // Add a few terms.\n    $terms = [];\n    $terms_value = [];\n    foreach (range(1, 3) as $i) {\n      $terms_value[$i] = $this->randomString();\n      $terms[$i] = $this->createTerm($this->vocabulary, [\n        'name' => $this->randomString(),\n        'term_field' => [\n          'value' => $terms_value[$i],\n          'format' => $this->testFormat->id(),\n        ],\n      ]);\n    }\n\n    $entity = Node::create([\n      'title' => 'Test multivalue chained tokens',\n      'type' => 'article',\n      'test_term_reference' => [\n        ['target_id' => $terms[1]->id()],\n        ['target_id' => $terms[2]->id()],\n        ['target_id' => $terms[3]->id()],\n      ],\n    ]);\n    $entity->save();\n\n    $this->assertTokens('node', ['node' => $entity], [\n      'test_term_reference:0:entity:term_field' => Html::escape($terms[1]->term_field->value),\n      'test_term_reference:1:entity:term_field' => Html::escape($terms[2]->term_field->value),\n      'test_term_reference:2:entity:term_field' => Html::escape($terms[3]->term_field->value),\n      'test_term_reference:0:target_id' => $terms[1]->id(),\n      'test_term_reference:1:target_id' => $terms[2]->id(),\n      'test_term_reference:2:target_id' => $terms[3]->id(),\n      // Expects the entity's label to be returned for :entity tokens.\n      'test_term_reference:0:entity' => $terms[1]->label(),\n      'test_term_reference:1:entity' => $terms[2]->label(),\n      'test_term_reference:2:entity' => $terms[3]->label(),\n      // To make sure tokens without an explicit delta can also be replaced in\n      // the same token replacement call.\n      'test_term_reference:entity:term_field' => Html::escape($terms[1]->term_field->value),\n      'test_term_reference:target_id' => $terms[1]->id(),\n    ]);\n\n    // Test some non existent tokens.\n    $this->assertNoTokens('node', ['node' => $entity], [\n      'test_term_reference:3:term_field',\n      'test_term_reference:0:does_not_exist',\n      'test_term_reference:1:does:not:exist',\n      'test_term_reference:1:2:does_not_exist',\n    ]);\n  }\n\n  /**\n   * Test tokens for multilingual fields and entities.\n   */\n  public function testMultilingualFields() {\n    // Create an english term and add a german translation for it.\n    $term = $this->createTerm($this->vocabulary, [\n      'name' => 'english-test-term',\n      'langcode' => 'en',\n      'term_field' => [\n        'value' => 'english-term-field-value',\n        'format' => $this->testFormat->id(),\n      ],\n    ]);\n    $term->addTranslation('de', [\n      'name' => 'german-test-term',\n      'term_field' => [\n        'value' => 'german-term-field-value',\n        'format' => $this->testFormat->id(),\n      ],\n    ])->save();\n    $german_term = $term->getTranslation('de');\n\n    // Create an english node, add a german translation for it and add the\n    // english term to the english node's entity reference field and the\n    // german term to the german's entity reference field.\n    $node = Node::create([\n      'title' => 'english-node-title',\n      'type' => 'article',\n      'test_term_reference' => [\n        'target_id' => $term->id(),\n      ],\n      'test_field' => [\n        'value' => 'test-english-field',\n        'format' => $this->testFormat->id(),\n      ],\n    ]);\n    $node->addTranslation('de', [\n      'title' => 'german-node-title',\n      'test_term_reference' => [\n        'target_id' => $german_term->id(),\n      ],\n      'test_field' => [\n        'value' => 'test-german-field',\n        'format' => $this->testFormat->id(),\n      ],\n    ])->save();\n\n    // Verify the :title token of the english node and the :name token of the\n    // english term it refers to. Also verify the value of the term's field.\n    $this->assertTokens('node', ['node' => $node], [\n      'title' => 'english-node-title',\n      'test_term_reference:entity:name' => 'english-test-term',\n      'test_term_reference:entity:term_field:value' => 'english-term-field-value',\n      'test_term_reference:entity:term_field' => 'english-term-field-value',\n      'test_field' => 'test-english-field',\n      'test_field:value' => 'test-english-field',\n    ]);\n\n    // Same test for the german node and its german term.\n    $german_node = $node->getTranslation('de');\n    $this->assertTokens('node', ['node' => $german_node], [\n      'title' => 'german-node-title',\n      'test_term_reference:entity:name' => 'german-test-term',\n      'test_term_reference:entity:term_field:value' => 'german-term-field-value',\n      'test_term_reference:entity:term_field' => 'german-term-field-value',\n      'test_field' => 'test-german-field',\n      'test_field:value' => 'test-german-field',\n    ]);\n\n    // If the langcode is specified, it should have priority over the node's\n    // active language.\n    $tokens = [\n      'test_field' => 'test-german-field',\n      'test_field:value' => 'test-german-field',\n      'test_term_reference:entity:term_field' => 'german-term-field-value',\n      'test_term_reference:entity:term_field:value' => 'german-term-field-value',\n    ];\n    $this->assertTokens('node', ['node' => $node], $tokens, ['langcode' => 'de']);\n  }\n\n  /**\n   * Tests support for a datetime fields.\n   */\n  public function testDatetimeFieldTokens() {\n\n    $node = Node::create([\n      'title' => 'Node for datetime field',\n      'type' => 'article',\n    ]);\n\n    $node->set('field_datetime', ['1925-09-28T00:00:00', '1930-10-28T00:00:00'])->save();\n    $this->assertTokens('node', ['node' => $node], [\n      'field_datetime:date:custom:Y' => '1925',\n      'field_datetime:date:html_month' => '1925-09',\n      'field_datetime:date' => $node->get('field_datetime')->date->getTimestamp(),\n      'field_datetime:0:date:custom:Y' => '1925',\n      'field_datetime:0:date:html_month' => '1925-09',\n      'field_datetime:0:date' => $node->get('field_datetime')->date->getTimestamp(),\n      'field_datetime:1:date:custom:Y' => '1930',\n      'field_datetime:1:date:html_month' => '1930-10',\n      'field_datetime:1:date' => $node->get('field_datetime')->get(1)->date->getTimestamp(),\n    ]);\n  }\n\n  /**\n   * Tests support for a daterange fields.\n   */\n  public function testDatetimeRangeFieldTokens() {\n\n    /** @var \\Drupal\\node\\NodeInterface $node */\n    $node = Node::create([\n      'title' => 'Node for daterange field',\n      'type' => 'article',\n    ]);\n\n    $node->get('field_daterange')->value = '2013-12-22T00:00:00';\n    $node->get('field_daterange')->end_value = '2016-08-26T00:00:00';\n    $node->get('field_daterange')->appendItem([\n      'value' => '2014-08-22T00:00:00',\n      'end_value' => '2017-12-20T00:00:00',\n    ]);\n    $node->get('field_daterange')->value = '2013-12-22T00:00:00';\n    $node->get('field_daterange')->end_value = '2016-08-26T00:00:00';\n    $node->save();\n    $this->assertTokens('node', ['node' => $node], [\n      'field_daterange:start_date:html_month' => '2013-12',\n      'field_daterange:start_date:custom:Y' => '2013',\n      'field_daterange:end_date:custom:Y' => '2016',\n      'field_daterange:start_date' => $node->get('field_daterange')->start_date->getTimestamp(),\n      'field_daterange:0:start_date:html_month' => '2013-12',\n      'field_daterange:0:start_date:custom:Y' => '2013',\n      'field_daterange:0:end_date:custom:Y' => '2016',\n      'field_daterange:0:start_date' => $node->get('field_daterange')->start_date->getTimestamp(),\n      'field_daterange:1:start_date:html_month' => '2014-08',\n      'field_daterange:1:start_date:custom:Y' => '2014',\n      'field_daterange:1:end_date:custom:Y' => '2017',\n      'field_daterange:1:end_date' => $node->get('field_daterange')->get(1)->end_date->getTimestamp(),\n    ]);\n  }\n\n  /**\n   * Tests support for a timestamp fields.\n   */\n  public function testTimestampFieldTokens() {\n\n    $node = Node::create([\n      'title' => 'Node for timestamp field',\n      'type' => 'article',\n    ]);\n\n    $node->set('field_timestamp', ['1277540209', '1532593009'])->save();\n    $this->assertTokens('node', ['node' => $node], [\n      'field_timestamp:date:custom:Y' => '2010',\n      'field_timestamp:date:html_month' => '2010-06',\n      'field_timestamp:date' => $node->get('field_timestamp')->value,\n      'field_timestamp:0:date:custom:Y' => '2010',\n      'field_timestamp:0:date:html_month' => '2010-06',\n      'field_timestamp:0:date' => $node->get('field_timestamp')->value,\n      'field_timestamp:1:date:custom:Y' => '2018',\n      'field_timestamp:1:date:html_month' => '2018-07',\n      'field_timestamp:1:date' => $node->get('field_timestamp')->get(1)->value,\n    ]);\n  }\n\n}\n"
    },
    {
        "path": "tests/src/Kernel/ArrayTest.php",
        "contents": "<?php\n\nnamespace Drupal\\Tests\\token\\Kernel;\n\n/**\n * Tests array tokens.\n *\n * @group token\n */\nclass ArrayTest extends TokenKernelTestBase {\n\n  function testArrayTokens() {\n    // Test a simple array.\n    $array = [0 => 'a', 1 => 'b', 2 => 'c', 4 => 'd'];\n    $tokens = [\n      'first' => 'a',\n      'last' => 'd',\n      'value:0' => 'a',\n      'value:2' => 'c',\n      'count' => 4,\n      'keys' => '0, 1, 2, 4',\n      'keys:value:3' => '4',\n      'keys:join' => '0124',\n      'reversed' => 'd, c, b, a',\n      'reversed:keys' => '4, 2, 1, 0',\n      'join:/' => 'a/b/c/d',\n      'join' => 'abcd',\n      'join:, ' => 'a, b, c, d',\n      'join: ' => 'a b c d',\n    ];\n    $this->assertTokens('array', ['array' => $array], $tokens);\n\n    // Test a mixed simple and render array.\n    // 2 => c, 0 => a, 4 => d, 1 => b\n    $array = [\n      '#property' => 'value',\n      0 => 'a',\n      1 => ['#markup' => 'b', '#weight' => 0.01],\n      2 => ['#markup' => 'c', '#weight' => -10],\n      4 => ['#markup' => 'd', '#weight' => 0],\n    ];\n    $tokens = [\n      'first' => 'c',\n      'last' => 'b',\n      'value:0' => 'a',\n      'value:2' => 'c',\n      'count' => 4,\n      'keys' => '2, 0, 4, 1',\n      'keys:value:3' => '1',\n      'keys:join' => '2041',\n      'reversed' => 'b, d, a, c',\n      'reversed:keys' => '1, 4, 0, 2',\n      'join:/' => 'c/a/d/b',\n      'join' => 'cadb',\n      'join:, ' => 'c, a, d, b',\n      'join: ' => 'c a d b',\n    ];\n    $this->assertTokens('array', ['array' => $array], $tokens);\n  }\n\n}\n"
    },
    {
        "path": "tests/src/Kernel/NodeTest.php",
        "contents": "<?php\n\nnamespace Drupal\\Tests\\token\\Kernel;\n\nuse Drupal\\Core\\Url;\nuse Drupal\\node\\Entity\\Node;\nuse Drupal\\node\\Entity\\NodeType;\n\n/**\n * Test the node and content type tokens.\n *\n * @group token\n */\nclass NodeTest extends TokenKernelTestBase {\n\n  /**\n   * {@inheritdoc}\n   */\n  protected static $modules = ['node', 'field', 'text'];\n\n  /**\n   * {@inheritdoc}\n   */\n  protected function setUp(): void {\n    parent::setUp();\n\n    $this->installEntitySchema('user');\n    $this->installEntitySchema('node');\n\n    $node_type = NodeType::create([\n      'type' => 'page',\n      'name' => 'Basic page',\n      'description' => \"Use <em>basic pages</em> for your static content, such as an 'About us' page.\",\n    ]);\n    $node_type->save();\n    $node_type = NodeType::create([\n      'type' => 'article',\n      'name' => 'Article',\n      'description' => \"Use <em>articles</em> for time-sensitive content like news, press releases or blog posts.\",\n    ]);\n    $node_type->save();\n  }\n\n  /**\n   *\n   */\n  public function testNodeTokens() {\n    $page = Node::create([\n      'type' => 'page',\n      'title' => 'Source Title',\n      'revision_log' => $this->randomMachineName(),\n      'path' => ['alias' => '/content/source-node'],\n    ]);\n    $page->save();\n    $tokens = [\n      'log' => $page->revision_log->value,\n      'url:path' => '/content/source-node',\n      'url:absolute' => Url::fromRoute('entity.node.canonical', ['node' => $page->id()], ['absolute' => TRUE])->toString(),\n      'url:relative' => Url::fromRoute('entity.node.canonical', ['node' => $page->id()], ['absolute' => FALSE])->toString(),\n      'url:unaliased:path' => \"/node/{$page->id()}\",\n      'content-type' => 'Basic page',\n      'content-type:name' => 'Basic page',\n      'content-type:machine-name' => 'page',\n      'content-type:description' => \"Use <em>basic pages</em> for your static content, such as an 'About us' page.\",\n      'content-type:node-count' => 1,\n      'content-type:edit-url' => Url::fromRoute('entity.node_type.edit_form', ['node_type' => 'page'], ['absolute' => TRUE])->toString(),\n      'source:title' => 'Source Title',\n      // Deprecated tokens.\n      'type' => 'page',\n      'type-name' => 'Basic page',\n      'url:alias' => '/content/source-node',\n      'language:name' => 'English',\n    ];\n    $this->assertTokens('node', ['node' => $page], $tokens);\n\n    $article = Node::create([\n      'type' => 'article',\n      'title' => 'Source Title',\n    ]);\n    $article->save();\n    $tokens = [\n      'log' => '',\n      'url:path' => \"/node/{$article->id()}\",\n      'url:absolute' => Url::fromRoute('entity.node.canonical', ['node' => $article->id()], ['absolute' => TRUE])->toString(),\n      'url:relative' => Url::fromRoute('entity.node.canonical', ['node' => $article->id()], ['absolute' => FALSE])->toString(),\n      'url:unaliased:path' => \"/node/{$article->id()}\",\n      'content-type' => 'Article',\n      'content-type:name' => 'Article',\n      'content-type:machine-name' => 'article',\n      'content-type:description' => \"Use <em>articles</em> for time-sensitive content like news, press releases or blog posts.\",\n      'content-type:node-count' => 1,\n      'content-type:edit-url' => Url::fromRoute('entity.node_type.edit_form', ['node_type' => 'article'], ['absolute' => TRUE])->toString(),\n      'source:title' => 'Source Title',\n      // Deprecated tokens.\n      'type' => 'article',\n      'type-name' => 'Article',\n      'url:alias' => \"/node/{$article->id()}\",\n      'language:name' => 'English',\n    ];\n    $this->assertTokens('node', ['node' => $article], $tokens);\n  }\n\n}\n"
    },
    {
        "path": "tests/src/Kernel/ValidateD6MigrationStateTest.php",
        "contents": "<?php\n\nnamespace Drupal\\Tests\\token\\Kernel;\n\nuse Drupal\\Tests\\migrate_drupal\\Kernel\\d6\\MigrateDrupal6TestBase;\nuse Drupal\\Tests\\migrate_drupal\\Traits\\ValidateMigrationStateTestTrait;\n\n/**\n * Tests that the token test has a declared D6 migration status.\n *\n * ValidateMigrationStateTestTrait::testMigrationState() will succeed if the\n * modules enabled in \\Drupal\\Tests\\KernelTestBase::bootKernel() have a valid\n * migration status (i.e.: finished or not_finished); but will fail if they do\n * not have a declared migration status.\n *\n * @group token\n */\nclass ValidateD6MigrationStateTest extends MigrateDrupal6TestBase {\n  use ValidateMigrationStateTestTrait;\n\n  /**\n   * {@inheritdoc}\n   */\n  protected static $modules = ['token'];\n\n}\n"
    },
    {
        "path": "tests/src/Kernel/TaxonomyTest.php",
        "contents": "<?php\n\nnamespace Drupal\\Tests\\token\\Kernel;\n\nuse Drupal\\Core\\Url;\nuse Drupal\\language\\Entity\\ConfigurableLanguage;\nuse Drupal\\taxonomy\\Entity\\Term;\nuse Drupal\\taxonomy\\Entity\\Vocabulary;\n\n/**\n * Tests taxonomy tokens.\n *\n * @group token\n */\nclass TaxonomyTest extends TokenKernelTestBase {\n\n  protected $vocab;\n\n  /**\n   * {@inheritdoc}\n   */\n  protected static $modules = ['taxonomy', 'text', 'language'];\n\n  /**\n   * {@inheritdoc}\n   */\n  public function setUp(): void {\n    parent::setUp();\n\n    $this->installEntitySchema('taxonomy_term');\n\n    // Create the default tags vocabulary.\n    $vocabulary = Vocabulary::create([\n      'name' => 'Tags',\n      'vid' => 'tags',\n    ]);\n    $vocabulary->save();\n    $this->vocab = $vocabulary;\n  }\n\n  /**\n   * Test the additional taxonomy term tokens.\n   */\n  public function testTaxonomyTokens() {\n    $root_term = $this->addTerm($this->vocab, ['name' => 'Root term', 'path' => ['alias' => '/root-term']]);\n    $tokens = [\n      'url' => Url::fromRoute('entity.taxonomy_term.canonical', ['taxonomy_term' => $root_term->id()], ['absolute' => TRUE])->toString(),\n      'url:absolute' => Url::fromRoute('entity.taxonomy_term.canonical', ['taxonomy_term' => $root_term->id()], ['absolute' => TRUE])->toString(),\n      'url:relative' => Url::fromRoute('entity.taxonomy_term.canonical', ['taxonomy_term' => $root_term->id()], ['absolute' => FALSE])->toString(),\n      'url:path' => '/root-term',\n      'url:unaliased:path' => \"/taxonomy/term/{$root_term->id()}\",\n      'edit-url' => Url::fromRoute('entity.taxonomy_term.edit_form', ['taxonomy_term' => $root_term->id()], ['absolute' => TRUE])->toString(),\n      'parents' => NULL,\n      'parents:count' => NULL,\n      'parents:keys' => NULL,\n      'root' => NULL,\n      // Deprecated tokens.\n      'url:alias' => '/root-term',\n    ];\n    $this->assertTokens('term', ['term' => $root_term], $tokens);\n\n    $parent_term = $this->addTerm($this->vocab, ['name' => 'Parent term', 'parent' => $root_term->id()]);\n    $tokens = [\n      'url' => Url::fromRoute('entity.taxonomy_term.canonical', ['taxonomy_term' => $parent_term->id()], ['absolute' => TRUE])->toString(),\n      'url:absolute' => Url::fromRoute('entity.taxonomy_term.canonical', ['taxonomy_term' => $parent_term->id()], ['absolute' => TRUE])->toString(),\n      'url:relative' => Url::fromRoute('entity.taxonomy_term.canonical', ['taxonomy_term' => $parent_term->id()], ['absolute' => FALSE])->toString(),\n      'url:path' => \"/taxonomy/term/{$parent_term->id()}\",\n      'url:unaliased:path' => \"/taxonomy/term/{$parent_term->id()}\",\n      'edit-url' => Url::fromRoute('entity.taxonomy_term.edit_form', ['taxonomy_term' => $parent_term->id()], ['absolute' => TRUE])->toString(),\n      'parents' => 'Root term',\n      'parents:count' => 1,\n      'parents:keys' => $root_term->id(),\n      'root' => $root_term->label(),\n      'root:tid' => $root_term->id(),\n      // Deprecated tokens.\n      'url:alias' => \"/taxonomy/term/{$parent_term->id()}\",\n    ];\n    $this->assertTokens('term', ['term' => $parent_term], $tokens);\n\n    $term = $this->addTerm($this->vocab, ['name' => 'Test term', 'parent' => $parent_term->id()]);\n    $tokens = [\n      'parents' => 'Root term, Parent term',\n      'parents:count' => 2,\n      'parents:keys' => implode(', ', [$root_term->id(), $parent_term->id()]),\n    ];\n    $this->assertTokens('term', ['term' => $term], $tokens);\n  }\n\n  /**\n   * Test the additional vocabulary tokens.\n   */\n  public function testVocabularyTokens() {\n    $vocabulary = $this->vocab;\n    $tokens = [\n      'machine-name' => 'tags',\n      'edit-url' => Url::fromRoute('entity.taxonomy_vocabulary.edit_form', ['taxonomy_vocabulary' => $vocabulary->id()], ['absolute' => TRUE])->toString(),\n    ];\n    $this->assertTokens('vocabulary', ['vocabulary' => $vocabulary], $tokens);\n  }\n\n  /**\n   *\n   */\n  public function addVocabulary(array $vocabulary = []) {\n    $vocabulary += [\n      'name' => mb_strtolower($this->randomMachineName(5)),\n      'nodes' => ['article' => 'article'],\n    ];\n    $vocabulary = Vocabulary::create($vocabulary)->save();\n    return $vocabulary;\n  }\n\n  /**\n   *\n   */\n  public function addTerm($vocabulary, array $term = []) {\n    $term += [\n      'name' => mb_strtolower($this->randomMachineName(5)),\n      'vid' => $vocabulary->id(),\n    ];\n    $term = Term::create($term);\n    $term->save();\n    return $term;\n  }\n\n  /**\n   * Test the multilingual terms.\n   */\n  public function testMultilingualTerms() {\n    // Add a second language.\n    $language = ConfigurableLanguage::createFromLangcode('de');\n    $language->save();\n\n    // Create an english parent term and add a german translation for it.\n    $parent_term = $this->addTerm($this->vocab, [\n      'name' => 'english-parent-term',\n      'langcode' => 'en',\n    ]);\n    $parent_term->addTranslation('de', [\n      'name' => 'german-parent-term',\n    ])->save();\n\n    // Check translation source tokens.\n    $this->assertTokens('term', ['term' => $parent_term], ['source:name' => 'english-parent-term']);\n    $this->assertTokens('term', ['term' => $parent_term], ['source:name' => 'english-parent-term'], ['langcode' => 'de']);\n\n    // Create a term related to the parent term.\n    $child_term = $this->addTerm($this->vocab, [\n      'name' => 'english-child-term',\n      'langcode' => 'en',\n      'parent' => $parent_term->id(),\n    ]);\n    $child_term->addTranslation('de', [\n      'name' => 'german-child-term',\n    ])->save();\n\n    // Expect the parent term to be in the specified language.\n    $this->assertTokens('term', ['term' => $child_term], ['parents' => 'german-parent-term'], ['langcode' => 'de']);\n    $this->assertTokens('term', ['term' => $child_term], ['root' => 'german-parent-term'], ['langcode' => 'de']);\n  }\n\n}\n"
    },
    {
        "path": "templates/token-tree-link.html.twig",
        "contents": "{#\n/**\n * @file\n * Default theme implementation for the token tree link.\n *\n * Available variables:\n * - url: The URL to the token tree page.\n * - text: The text to be displayed in the link.\n * - attributes: Attributes for the anchor tag.\n * - link: The complete link.\n *\n * @see template_preprocess_token_tree_link()\n *\n * @ingroup themeable\n */\n#}\n{% if link -%}\n  {{ link }}\n{%- endif %}\n"
    },
    {
        "path": ".git/config",
        "contents": "[core]\n\trepositoryformatversion = 0\n\tfilemode = true\n\tbare = false\n\tlogallrefupdates = true\n\tignorecase = true\n[remote \"origin\"]\n\turl = https://git.drupalcode.org/project/token.git\n\tfetch = +refs/heads/*:refs/remotes/origin/*\n[branch \"8.x-1.x\"]\n\tremote = origin\n\tmerge = refs/heads/8.x-1.x\n"
    },
    {
        "path": ".git/HEAD",
        "contents": "ref: refs/heads/8.x-1.x\n"
    },
    {
        "path": ".git/description",
        "contents": "Unnamed repository; edit this file 'description' to name the repository.\n"
    },
    {
        "path": ".git/packed-refs",
        "contents": "# pack-refs with: peeled fully-peeled sorted \n31806be68943b6d44636577685b823b7f4f82508 refs/remotes/origin/4.7.x-1.x\n62fc0ea6b4c11f20094aa797f08e126d890786f1 refs/remotes/origin/5.x-1.x\n8b88af7a8fb26c6ed5041d2ba81465afd1f78d8e refs/remotes/origin/6.x-1.x\nfbcc95aec308e4057aabb4c9cfc4e19fb5c03fa2 refs/remotes/origin/691078-field-tokens\n52b0ecef967288409c530c88f2a415832e712ba6 refs/remotes/origin/7.x-1.x\nce0ed143597475351fa610514cc1d529b4019e5e refs/remotes/origin/8.x-1.x\na2d2622f891636882c5aea3d077f721e6deb9bec refs/remotes/origin/master\nf8171f5974cc5f8a2c6b4644ecdd324b6b303a52 refs/tags/4.7.x-1.4\n1cece6ace5cb59c445db93bd4ad3e88db809dfc5 refs/tags/4.7.x-1.5\n385f059556ddc8ddf44a3c3a00feb06fd9e036c4 refs/tags/5.x-1.0\n36bf145e5810a951c3cccb50d467a9fa70bb8dc7 refs/tags/5.x-1.1\nad0db920cbc1b3e3f81b49a76f703a787e00b306 refs/tags/5.x-1.10\n5c46d185064f45c00006fa6600d30ba64e104509 refs/tags/5.x-1.11\n60473dbf7a0ef0906ecf922f433b26f930b017f2 refs/tags/5.x-1.12\n40d90603b5f638c28f00b01ce54b5268ffbaacb6 refs/tags/5.x-1.13\nff7e171fb19b937480b51254ed96fc74e4949d70 refs/tags/5.x-1.14\n644960fd46f3a2247a028ac01078a445a11db55a refs/tags/5.x-1.15\ne6a87dafba8b16c37afba14002017b4b108a2a95 refs/tags/5.x-1.2\n9b54697358656e3a7357eb2f1225310ff245b1eb refs/tags/5.x-1.3\nfa566ea16f4d7ebed280469c8818cc31d77044fa refs/tags/5.x-1.4\n099632603c8a3245bbdfc5c184da83987ca40013 refs/tags/5.x-1.5\ne1bed7d141dc5b8ff0b41a81237f5061f49e03e5 refs/tags/5.x-1.6\nff78f39145728bb63e41590c9209c83ebf86d98e refs/tags/5.x-1.7\n8cde447b9ec5e8f062585e49fda0000c117ce537 refs/tags/5.x-1.8\n0e81a0eeb07afbef2ac1308ccbfc1f481d333cce refs/tags/5.x-1.9\nc65853cd73b4b30aa35575af5ca9009af21463c8 refs/tags/6.x-1.10\nb1abbf114abeb89cae474dcc6695c4dba57dcb8d refs/tags/6.x-1.11\nd451e1348b5ccaab3e5a57251444c3468ff822c5 refs/tags/6.x-1.12\nafb9fe2701aef8d0189a9dfd6b22f95e093f2c08 refs/tags/6.x-1.13\nc21b5379d2f05d86cfe2ba468acc622aa82ecd91 refs/tags/6.x-1.14\nf351e17b1c8b168d1151bac280ab6b10b46019ca refs/tags/6.x-1.15\n755da683a011bc4bc35f11c9e6e188df2987f843 refs/tags/6.x-1.16\na7cdf54588231b938bbce48a92c9065bf8192ad1 refs/tags/6.x-1.17\na10367bc7e6e1f4b6031ba753d4744d3547d6149 refs/tags/6.x-1.18\n8b88af7a8fb26c6ed5041d2ba81465afd1f78d8e refs/tags/6.x-1.19\n27f65a72a9bbe5dab04bdd903e744a6af627d356 refs/tags/7.x-1.0\ne101f4e941c21279a6046b4e550575af59fa4efb refs/tags/7.x-1.0-alpha1\n0b3d5ed41e301dab058d6dbadb799548b963726b refs/tags/7.x-1.0-alpha2\n24170bfb62c62ebaa946a877f7f159db0207c989 refs/tags/7.x-1.0-alpha3\n49b6df31f8396c2f656cb88f6bf5557eb4209b9d refs/tags/7.x-1.0-beta1\n5155456bf8a4a198ea7538c7093ead42ce3f1ce6 refs/tags/7.x-1.0-beta2\nd3d91ddb008d89aa19fd1e21ddacd271871a8f43 refs/tags/7.x-1.0-beta3\n7f722d24aa5bb95f151d6106efc3c71e220c2b5f refs/tags/7.x-1.0-beta4\n6cfd59b04de8d5372e3c3363b50eb80001c421e9 refs/tags/7.x-1.0-beta5\n48370d9a59c531085086c5a7fb1890c787861fe9 refs/tags/7.x-1.0-beta6\n12eb46575e042eac94bbfb75c4ef5ce359b339bc refs/tags/7.x-1.0-beta7\n8f89f245a332ecf69c6d9d777164946399b3b68a refs/tags/7.x-1.0-rc1\na2c55a9944d3765041cba311a0bd745178f9aa62 refs/tags/7.x-1.1\nfb05b225ee0c93835f4a998996a94d53594b51e8 refs/tags/7.x-1.2\n963569d1f28b2627ba7511b4cadd7fed40bde75f refs/tags/7.x-1.3\nc5b20e07ed91fa5e6ed036a45be8be5a924378dc refs/tags/7.x-1.4\n72f3d1723fb5b2071a54d24fccad1f333c86c4fa refs/tags/7.x-1.5\n6019b9e657cfe6a919e8e717c52e4e07bd94dab0 refs/tags/7.x-1.6\n6fa49e98a450f6df34f9e1ab9abea1721b105085 refs/tags/7.x-1.7\ndcd99785260f9b868f285ea15b024ca10e7c74d6 refs/tags/7.x-1.8\n52b0ecef967288409c530c88f2a415832e712ba6 refs/tags/7.x-1.9\ned6cc7b037b462cc76dafde7910d57b5a7010559 refs/tags/8.x-1.0\n744aafa22afeb5abdbd300179ae7299263f20c5a refs/tags/8.x-1.0-alpha1\n918d0d5e8e8ee7f446d3e068cb6aa2d7c61ee625 refs/tags/8.x-1.0-alpha2\n1c68e82525fda1bd12021502da81b929b9ae5c02 refs/tags/8.x-1.0-beta1\n724ccaa7a60f1aa7e8883e82de737115b0f73a3f refs/tags/8.x-1.0-beta2\na3b68ccb7c5657a8138c999731dca293ed7991a8 refs/tags/8.x-1.0-rc1\n083fed6158fdd866a7f138f622ae7325a8cbccec refs/tags/8.x-1.1\n8ab7673f9d70f41e0a6fbc86e4b4ec56437a859e refs/tags/8.x-1.10\nbef22ecf09b9b9993312f212ac9b1f765755ad61 refs/tags/8.x-1.11\n92a1e9b9b22743438b66f144425a13bb0f2b1b7a refs/tags/8.x-1.12\nc4a7fd43313746e8662ef44b3e5b4b6397e2b44a refs/tags/8.x-1.13\n2a8d7e209036bf4083e989ab6b6342e56563dd44 refs/tags/8.x-1.14\n2a04a029d36c6e78075cf1c4e102af5303f03531 refs/tags/8.x-1.2\n70c20dbdcd370cd0610468069a3e29ba4921496e refs/tags/8.x-1.3\n203352b1528fbca53f03c2db7592ba44344549d0 refs/tags/8.x-1.4\n7c0c8cd9a3858dcdabfee7b903ebda58cee0b804 refs/tags/8.x-1.5\na3d050199c67345a2283809deeb4746128616c9a refs/tags/8.x-1.6\n31c0225b011de3d1def7ae6295c018463a43359c refs/tags/8.x-1.7\n492f68400e4d92a84cb249efb2a9df3aebcd3e17 refs/tags/8.x-1.8\n6b2701ed6cd3bb1e7595b413dcf0bb838d35202a refs/tags/8.x-1.9\n"
    },
    {
        "path": ".git/info/exclude",
        "contents": "# git ls-files --others --exclude-from=.git/info/exclude\n# Lines that start with '#' are comments.\n# For a project mostly in C, the following would be a good set of\n# exclude patterns (uncomment them if you want to use them):\n# *.[oa]\n# *~\n"
    },
    {
        "path": ".git/logs/HEAD",
        "contents": "0000000000000000000000000000000000000000 ce0ed143597475351fa610514cc1d529b4019e5e Mriyam Tamuli <mbtamuli@gmail.com> 1715924636 +0000\tclone: from https://git.drupalcode.org/project/token.git\n"
    },
    {
        "path": ".git/logs/refs/heads/8.x-1.x",
        "contents": "0000000000000000000000000000000000000000 ce0ed143597475351fa610514cc1d529b4019e5e Mriyam Tamuli <mbtamuli@gmail.com> 1715924636 +0000\tclone: from https://git.drupalcode.org/project/token.git\n"
    },
    {
        "path": ".git/logs/refs/remotes/origin/HEAD",
        "contents": "0000000000000000000000000000000000000000 ce0ed143597475351fa610514cc1d529b4019e5e Mriyam Tamuli <mbtamuli@gmail.com> 1715924636 +0000\tclone: from https://git.drupalcode.org/project/token.git\n"
    },
    {
        "path": ".git/hooks/commit-msg.sample",
        "contents": "#!/bin/sh\n#\n# An example hook script to check the commit log message.\n# Called by \"git commit\" with one argument, the name of the file\n# that has the commit message.  The hook should exit with non-zero\n# status after issuing an appropriate message if it wants to stop the\n# commit.  The hook is allowed to edit the commit message file.\n#\n# To enable this hook, rename this file to \"commit-msg\".\n\n# Uncomment the below to add a Signed-off-by line to the message.\n# Doing this in a hook is a bad idea in general, but the prepare-commit-msg\n# hook is more suited to it.\n#\n# SOB=$(git var GIT_AUTHOR_IDENT | sed -n 's/^\\(.*>\\).*$/Signed-off-by: \\1/p')\n# grep -qs \"^$SOB\" \"$1\" || echo \"$SOB\" >> \"$1\"\n\n# This example catches duplicate Signed-off-by lines.\n\ntest \"\" = \"$(grep '^Signed-off-by: ' \"$1\" |\n\t sort | uniq -c | sed -e '/^[ \t]*1[ \t]/d')\" || {\n\techo >&2 Duplicate Signed-off-by lines.\n\texit 1\n}\n"
    },
    {
        "path": ".git/hooks/pre-rebase.sample",
        "contents": "#!/bin/sh\n#\n# Copyright (c) 2006, 2008 Junio C Hamano\n#\n# The \"pre-rebase\" hook is run just before \"git rebase\" starts doing\n# its job, and can prevent the command from running by exiting with\n# non-zero status.\n#\n# The hook is called with the following parameters:\n#\n# $1 -- the upstream the series was forked from.\n# $2 -- the branch being rebased (or empty when rebasing the current branch).\n#\n# This sample shows how to prevent topic branches that are already\n# merged to 'next' branch from getting rebased, because allowing it\n# would result in rebasing already published history.\n\npublish=next\nbasebranch=\"$1\"\nif test \"$#\" = 2\nthen\n\ttopic=\"refs/heads/$2\"\nelse\n\ttopic=`git symbolic-ref HEAD` ||\n\texit 0 ;# we do not interrupt rebasing detached HEAD\nfi\n\ncase \"$topic\" in\nrefs/heads/??/*)\n\t;;\n*)\n\texit 0 ;# we do not interrupt others.\n\t;;\nesac\n\n# Now we are dealing with a topic branch being rebased\n# on top of master.  Is it OK to rebase it?\n\n# Does the topic really exist?\ngit show-ref -q \"$topic\" || {\n\techo >&2 \"No such branch $topic\"\n\texit 1\n}\n\n# Is topic fully merged to master?\nnot_in_master=`git rev-list --pretty=oneline ^master \"$topic\"`\nif test -z \"$not_in_master\"\nthen\n\techo >&2 \"$topic is fully merged to master; better remove it.\"\n\texit 1 ;# we could allow it, but there is no point.\nfi\n\n# Is topic ever merged to next?  If so you should not be rebasing it.\nonly_next_1=`git rev-list ^master \"^$topic\" ${publish} | sort`\nonly_next_2=`git rev-list ^master           ${publish} | sort`\nif test \"$only_next_1\" = \"$only_next_2\"\nthen\n\tnot_in_topic=`git rev-list \"^$topic\" master`\n\tif test -z \"$not_in_topic\"\n\tthen\n\t\techo >&2 \"$topic is already up to date with master\"\n\t\texit 1 ;# we could allow it, but there is no point.\n\telse\n\t\texit 0\n\tfi\nelse\n\tnot_in_next=`git rev-list --pretty=oneline ^${publish} \"$topic\"`\n\t/usr/bin/perl -e '\n\t\tmy $topic = $ARGV[0];\n\t\tmy $msg = \"* $topic has commits already merged to public branch:\\n\";\n\t\tmy (%not_in_next) = map {\n\t\t\t/^([0-9a-f]+) /;\n\t\t\t($1 => 1);\n\t\t} split(/\\n/, $ARGV[1]);\n\t\tfor my $elem (map {\n\t\t\t\t/^([0-9a-f]+) (.*)$/;\n\t\t\t\t[$1 => $2];\n\t\t\t} split(/\\n/, $ARGV[2])) {\n\t\t\tif (!exists $not_in_next{$elem->[0]}) {\n\t\t\t\tif ($msg) {\n\t\t\t\t\tprint STDERR $msg;\n\t\t\t\t\tundef $msg;\n\t\t\t\t}\n\t\t\t\tprint STDERR \" $elem->[1]\\n\";\n\t\t\t}\n\t\t}\n\t' \"$topic\" \"$not_in_next\" \"$not_in_master\"\n\texit 1\nfi\n\n<<\\DOC_END\n\nThis sample hook safeguards topic branches that have been\npublished from being rewound.\n\nThe workflow assumed here is:\n\n * Once a topic branch forks from \"master\", \"master\" is never\n   merged into it again (either directly or indirectly).\n\n * Once a topic branch is fully cooked and merged into \"master\",\n   it is deleted.  If you need to build on top of it to correct\n   earlier mistakes, a new topic branch is created by forking at\n   the tip of the \"master\".  This is not strictly necessary, but\n   it makes it easier to keep your history simple.\n\n * Whenever you need to test or publish your changes to topic\n   branches, merge them into \"next\" branch.\n\nThe script, being an example, hardcodes the publish branch name\nto be \"next\", but it is trivial to make it configurable via\n$GIT_DIR/config mechanism.\n\nWith this workflow, you would want to know:\n\n(1) ... if a topic branch has ever been merged to \"next\".  Young\n    topic branches can have stupid mistakes you would rather\n    clean up before publishing, and things that have not been\n    merged into other branches can be easily rebased without\n    affecting other people.  But once it is published, you would\n    not want to rewind it.\n\n(2) ... if a topic branch has been fully merged to \"master\".\n    Then you can delete it.  More importantly, you should not\n    build on top of it -- other people may already want to\n    change things related to the topic as patches against your\n    \"master\", so if you need further changes, it is better to\n    fork the topic (perhaps with the same name) afresh from the\n    tip of \"master\".\n\nLet's look at this example:\n\n\t\t   o---o---o---o---o---o---o---o---o---o \"next\"\n\t\t  /       /           /           /\n\t\t /   a---a---b A     /           /\n\t\t/   /               /           /\n\t       /   /   c---c---c---c B         /\n\t      /   /   /             \\         /\n\t     /   /   /   b---b C     \\       /\n\t    /   /   /   /             \\     /\n    ---o---o---o---o---o---o---o---o---o---o---o \"master\"\n\n\nA, B and C are topic branches.\n\n * A has one fix since it was merged up to \"next\".\n\n * B has finished.  It has been fully merged up to \"master\" and \"next\",\n   and is ready to be deleted.\n\n * C has not merged to \"next\" at all.\n\nWe would want to allow C to be rebased, refuse A, and encourage\nB to be deleted.\n\nTo compute (1):\n\n\tgit rev-list ^master ^topic next\n\tgit rev-list ^master        next\n\n\tif these match, topic has not merged in next at all.\n\nTo compute (2):\n\n\tgit rev-list master..topic\n\n\tif this is empty, it is fully merged to \"master\".\n\nDOC_END\n"
    },
    {
        "path": ".git/hooks/sendemail-validate.sample",
        "contents": "#!/bin/sh\n\n# An example hook script to validate a patch (and/or patch series) before\n# sending it via email.\n#\n# The hook should exit with non-zero status after issuing an appropriate\n# message if it wants to prevent the email(s) from being sent.\n#\n# To enable this hook, rename this file to \"sendemail-validate\".\n#\n# By default, it will only check that the patch(es) can be applied on top of\n# the default upstream branch without conflicts in a secondary worktree. After\n# validation (successful or not) of the last patch of a series, the worktree\n# will be deleted.\n#\n# The following config variables can be set to change the default remote and\n# remote ref that are used to apply the patches against:\n#\n#   sendemail.validateRemote (default: origin)\n#   sendemail.validateRemoteRef (default: HEAD)\n#\n# Replace the TODO placeholders with appropriate checks according to your\n# needs.\n\nvalidate_cover_letter () {\n\tfile=\"$1\"\n\t# TODO: Replace with appropriate checks (e.g. spell checking).\n\ttrue\n}\n\nvalidate_patch () {\n\tfile=\"$1\"\n\t# Ensure that the patch applies without conflicts.\n\tgit am -3 \"$file\" || return\n\t# TODO: Replace with appropriate checks for this patch\n\t# (e.g. checkpatch.pl).\n\ttrue\n}\n\nvalidate_series () {\n\t# TODO: Replace with appropriate checks for the whole series\n\t# (e.g. quick build, coding style checks, etc.).\n\ttrue\n}\n\n# main -------------------------------------------------------------------------\n\nif test \"$GIT_SENDEMAIL_FILE_COUNTER\" = 1\nthen\n\tremote=$(git config --default origin --get sendemail.validateRemote) &&\n\tref=$(git config --default HEAD --get sendemail.validateRemoteRef) &&\n\tworktree=$(mktemp --tmpdir -d sendemail-validate.XXXXXXX) &&\n\tgit worktree add -fd --checkout \"$worktree\" \"refs/remotes/$remote/$ref\" &&\n\tgit config --replace-all sendemail.validateWorktree \"$worktree\"\nelse\n\tworktree=$(git config --get sendemail.validateWorktree)\nfi || {\n\techo \"sendemail-validate: error: failed to prepare worktree\" >&2\n\texit 1\n}\n\nunset GIT_DIR GIT_WORK_TREE\ncd \"$worktree\" &&\n\nif grep -q \"^diff --git \" \"$1\"\nthen\n\tvalidate_patch \"$1\"\nelse\n\tvalidate_cover_letter \"$1\"\nfi &&\n\nif test \"$GIT_SENDEMAIL_FILE_COUNTER\" = \"$GIT_SENDEMAIL_FILE_TOTAL\"\nthen\n\tgit config --unset-all sendemail.validateWorktree &&\n\ttrap 'git worktree remove -ff \"$worktree\"' EXIT &&\n\tvalidate_series\nfi\n"
    },
    {
        "path": ".git/hooks/pre-commit.sample",
        "contents": "#!/bin/sh\n#\n# An example hook script to verify what is about to be committed.\n# Called by \"git commit\" with no arguments.  The hook should\n# exit with non-zero status after issuing an appropriate message if\n# it wants to stop the commit.\n#\n# To enable this hook, rename this file to \"pre-commit\".\n\nif git rev-parse --verify HEAD >/dev/null 2>&1\nthen\n\tagainst=HEAD\nelse\n\t# Initial commit: diff against an empty tree object\n\tagainst=$(git hash-object -t tree /dev/null)\nfi\n\n# If you want to allow non-ASCII filenames set this variable to true.\nallownonascii=$(git config --type=bool hooks.allownonascii)\n\n# Redirect output to stderr.\nexec 1>&2\n\n# Cross platform projects tend to avoid non-ASCII filenames; prevent\n# them from being added to the repository. We exploit the fact that the\n# printable range starts at the space character and ends with tilde.\nif [ \"$allownonascii\" != \"true\" ] &&\n\t# Note that the use of brackets around a tr range is ok here, (it's\n\t# even required, for portability to Solaris 10's /usr/bin/tr), since\n\t# the square bracket bytes happen to fall in the designated range.\n\ttest $(git diff-index --cached --name-only --diff-filter=A -z $against |\n\t  LC_ALL=C tr -d '[ -~]\\0' | wc -c) != 0\nthen\n\tcat <<\\EOF\nError: Attempt to add a non-ASCII file name.\n\nThis can cause problems if you want to work with people on other platforms.\n\nTo be portable it is advisable to rename the file.\n\nIf you know what you are doing you can disable this check using:\n\n  git config hooks.allownonascii true\nEOF\n\texit 1\nfi\n\n# If there are whitespace errors, print the offending file names and fail.\nexec git diff-index --check --cached $against --\n"
    },
    {
        "path": ".git/hooks/applypatch-msg.sample",
        "contents": "#!/bin/sh\n#\n# An example hook script to check the commit log message taken by\n# applypatch from an e-mail message.\n#\n# The hook should exit with non-zero status after issuing an\n# appropriate message if it wants to stop the commit.  The hook is\n# allowed to edit the commit message file.\n#\n# To enable this hook, rename this file to \"applypatch-msg\".\n\n. git-sh-setup\ncommitmsg=\"$(git rev-parse --git-path hooks/commit-msg)\"\ntest -x \"$commitmsg\" && exec \"$commitmsg\" ${1+\"$@\"}\n:\n"
    },
    {
        "path": ".git/hooks/fsmonitor-watchman.sample",
        "contents": "#!/usr/bin/perl\n\nuse strict;\nuse warnings;\nuse IPC::Open2;\n\n# An example hook script to integrate Watchman\n# (https://facebook.github.io/watchman/) with git to speed up detecting\n# new and modified files.\n#\n# The hook is passed a version (currently 2) and last update token\n# formatted as a string and outputs to stdout a new update token and\n# all files that have been modified since the update token. Paths must\n# be relative to the root of the working tree and separated by a single NUL.\n#\n# To enable this hook, rename this file to \"query-watchman\" and set\n# 'git config core.fsmonitor .git/hooks/query-watchman'\n#\nmy ($version, $last_update_token) = @ARGV;\n\n# Uncomment for debugging\n# print STDERR \"$0 $version $last_update_token\\n\";\n\n# Check the hook interface version\nif ($version ne 2) {\n\tdie \"Unsupported query-fsmonitor hook version '$version'.\\n\" .\n\t    \"Falling back to scanning...\\n\";\n}\n\nmy $git_work_tree = get_working_dir();\n\nmy $retry = 1;\n\nmy $json_pkg;\neval {\n\trequire JSON::XS;\n\t$json_pkg = \"JSON::XS\";\n\t1;\n} or do {\n\trequire JSON::PP;\n\t$json_pkg = \"JSON::PP\";\n};\n\nlaunch_watchman();\n\nsub launch_watchman {\n\tmy $o = watchman_query();\n\tif (is_work_tree_watched($o)) {\n\t\toutput_result($o->{clock}, @{$o->{files}});\n\t}\n}\n\nsub output_result {\n\tmy ($clockid, @files) = @_;\n\n\t# Uncomment for debugging watchman output\n\t# open (my $fh, \">\", \".git/watchman-output.out\");\n\t# binmode $fh, \":utf8\";\n\t# print $fh \"$clockid\\n@files\\n\";\n\t# close $fh;\n\n\tbinmode STDOUT, \":utf8\";\n\tprint $clockid;\n\tprint \"\\0\";\n\tlocal $, = \"\\0\";\n\tprint @files;\n}\n\nsub watchman_clock {\n\tmy $response = qx/watchman clock \"$git_work_tree\"/;\n\tdie \"Failed to get clock id on '$git_work_tree'.\\n\" .\n\t\t\"Falling back to scanning...\\n\" if $? != 0;\n\n\treturn $json_pkg->new->utf8->decode($response);\n}\n\nsub watchman_query {\n\tmy $pid = open2(\\*CHLD_OUT, \\*CHLD_IN, 'watchman -j --no-pretty')\n\tor die \"open2() failed: $!\\n\" .\n\t\"Falling back to scanning...\\n\";\n\n\t# In the query expression below we're asking for names of files that\n\t# changed since $last_update_token but not from the .git folder.\n\t#\n\t# To accomplish this, we're using the \"since\" generator to use the\n\t# recency index to select candidate nodes and \"fields\" to limit the\n\t# output to file names only. Then we're using the \"expression\" term to\n\t# further constrain the results.\n\tmy $last_update_line = \"\";\n\tif (substr($last_update_token, 0, 1) eq \"c\") {\n\t\t$last_update_token = \"\\\"$last_update_token\\\"\";\n\t\t$last_update_line = qq[\\n\"since\": $last_update_token,];\n\t}\n\tmy $query = <<\"\tEND\";\n\t\t[\"query\", \"$git_work_tree\", {$last_update_line\n\t\t\t\"fields\": [\"name\"],\n\t\t\t\"expression\": [\"not\", [\"dirname\", \".git\"]]\n\t\t}]\n\tEND\n\n\t# Uncomment for debugging the watchman query\n\t# open (my $fh, \">\", \".git/watchman-query.json\");\n\t# print $fh $query;\n\t# close $fh;\n\n\tprint CHLD_IN $query;\n\tclose CHLD_IN;\n\tmy $response = do {local $/; <CHLD_OUT>};\n\n\t# Uncomment for debugging the watch response\n\t# open ($fh, \">\", \".git/watchman-response.json\");\n\t# print $fh $response;\n\t# close $fh;\n\n\tdie \"Watchman: command returned no output.\\n\" .\n\t\"Falling back to scanning...\\n\" if $response eq \"\";\n\tdie \"Watchman: command returned invalid output: $response\\n\" .\n\t\"Falling back to scanning...\\n\" unless $response =~ /^\\{/;\n\n\treturn $json_pkg->new->utf8->decode($response);\n}\n\nsub is_work_tree_watched {\n\tmy ($output) = @_;\n\tmy $error = $output->{error};\n\tif ($retry > 0 and $error and $error =~ m/unable to resolve root .* directory (.*) is not watched/) {\n\t\t$retry--;\n\t\tmy $response = qx/watchman watch \"$git_work_tree\"/;\n\t\tdie \"Failed to make watchman watch '$git_work_tree'.\\n\" .\n\t\t    \"Falling back to scanning...\\n\" if $? != 0;\n\t\t$output = $json_pkg->new->utf8->decode($response);\n\t\t$error = $output->{error};\n\t\tdie \"Watchman: $error.\\n\" .\n\t\t\"Falling back to scanning...\\n\" if $error;\n\n\t\t# Uncomment for debugging watchman output\n\t\t# open (my $fh, \">\", \".git/watchman-output.out\");\n\t\t# close $fh;\n\n\t\t# Watchman will always return all files on the first query so\n\t\t# return the fast \"everything is dirty\" flag to git and do the\n\t\t# Watchman query just to get it over with now so we won't pay\n\t\t# the cost in git to look up each individual file.\n\t\tmy $o = watchman_clock();\n\t\t$error = $output->{error};\n\n\t\tdie \"Watchman: $error.\\n\" .\n\t\t\"Falling back to scanning...\\n\" if $error;\n\n\t\toutput_result($o->{clock}, (\"/\"));\n\t\t$last_update_token = $o->{clock};\n\n\t\teval { launch_watchman() };\n\t\treturn 0;\n\t}\n\n\tdie \"Watchman: $error.\\n\" .\n\t\"Falling back to scanning...\\n\" if $error;\n\n\treturn 1;\n}\n\nsub get_working_dir {\n\tmy $working_dir;\n\tif ($^O =~ 'msys' || $^O =~ 'cygwin') {\n\t\t$working_dir = Win32::GetCwd();\n\t\t$working_dir =~ tr/\\\\/\\//;\n\t} else {\n\t\trequire Cwd;\n\t\t$working_dir = Cwd::cwd();\n\t}\n\n\treturn $working_dir;\n}\n"
    },
    {
        "path": ".git/hooks/pre-receive.sample",
        "contents": "#!/bin/sh\n#\n# An example hook script to make use of push options.\n# The example simply echoes all push options that start with 'echoback='\n# and rejects all pushes when the \"reject\" push option is used.\n#\n# To enable this hook, rename this file to \"pre-receive\".\n\nif test -n \"$GIT_PUSH_OPTION_COUNT\"\nthen\n\ti=0\n\twhile test \"$i\" -lt \"$GIT_PUSH_OPTION_COUNT\"\n\tdo\n\t\teval \"value=\\$GIT_PUSH_OPTION_$i\"\n\t\tcase \"$value\" in\n\t\techoback=*)\n\t\t\techo \"echo from the pre-receive-hook: ${value#*=}\" >&2\n\t\t\t;;\n\t\treject)\n\t\t\texit 1\n\t\tesac\n\t\ti=$((i + 1))\n\tdone\nfi\n"
    },
    {
        "path": ".git/hooks/prepare-commit-msg.sample",
        "contents": "#!/bin/sh\n#\n# An example hook script to prepare the commit log message.\n# Called by \"git commit\" with the name of the file that has the\n# commit message, followed by the description of the commit\n# message's source.  The hook's purpose is to edit the commit\n# message file.  If the hook fails with a non-zero status,\n# the commit is aborted.\n#\n# To enable this hook, rename this file to \"prepare-commit-msg\".\n\n# This hook includes three examples. The first one removes the\n# \"# Please enter the commit message...\" help message.\n#\n# The second includes the output of \"git diff --name-status -r\"\n# into the message, just before the \"git status\" output.  It is\n# commented because it doesn't cope with --amend or with squashed\n# commits.\n#\n# The third example adds a Signed-off-by line to the message, that can\n# still be edited.  This is rarely a good idea.\n\nCOMMIT_MSG_FILE=$1\nCOMMIT_SOURCE=$2\nSHA1=$3\n\n/usr/bin/perl -i.bak -ne 'print unless(m/^. Please enter the commit message/..m/^#$/)' \"$COMMIT_MSG_FILE\"\n\n# case \"$COMMIT_SOURCE,$SHA1\" in\n#  ,|template,)\n#    /usr/bin/perl -i.bak -pe '\n#       print \"\\n\" . `git diff --cached --name-status -r`\n# \t if /^#/ && $first++ == 0' \"$COMMIT_MSG_FILE\" ;;\n#  *) ;;\n# esac\n\n# SOB=$(git var GIT_COMMITTER_IDENT | sed -n 's/^\\(.*>\\).*$/Signed-off-by: \\1/p')\n# git interpret-trailers --in-place --trailer \"$SOB\" \"$COMMIT_MSG_FILE\"\n# if test -z \"$COMMIT_SOURCE\"\n# then\n#   /usr/bin/perl -i.bak -pe 'print \"\\n\" if !$first_line++' \"$COMMIT_MSG_FILE\"\n# fi\n"
    },
    {
        "path": ".git/hooks/post-update.sample",
        "contents": "#!/bin/sh\n#\n# An example hook script to prepare a packed repository for use over\n# dumb transports.\n#\n# To enable this hook, rename this file to \"post-update\".\n\nexec git update-server-info\n"
    },
    {
        "path": ".git/hooks/pre-merge-commit.sample",
        "contents": "#!/bin/sh\n#\n# An example hook script to verify what is about to be committed.\n# Called by \"git merge\" with no arguments.  The hook should\n# exit with non-zero status after issuing an appropriate message to\n# stderr if it wants to stop the merge commit.\n#\n# To enable this hook, rename this file to \"pre-merge-commit\".\n\n. git-sh-setup\ntest -x \"$GIT_DIR/hooks/pre-commit\" &&\n        exec \"$GIT_DIR/hooks/pre-commit\"\n:\n"
    },
    {
        "path": ".git/hooks/pre-applypatch.sample",
        "contents": "#!/bin/sh\n#\n# An example hook script to verify what is about to be committed\n# by applypatch from an e-mail message.\n#\n# The hook should exit with non-zero status after issuing an\n# appropriate message if it wants to stop the commit.\n#\n# To enable this hook, rename this file to \"pre-applypatch\".\n\n. git-sh-setup\nprecommit=\"$(git rev-parse --git-path hooks/pre-commit)\"\ntest -x \"$precommit\" && exec \"$precommit\" ${1+\"$@\"}\n:\n"
    },
    {
        "path": ".git/hooks/pre-push.sample",
        "contents": "#!/bin/sh\n\n# An example hook script to verify what is about to be pushed.  Called by \"git\n# push\" after it has checked the remote status, but before anything has been\n# pushed.  If this script exits with a non-zero status nothing will be pushed.\n#\n# This hook is called with the following parameters:\n#\n# $1 -- Name of the remote to which the push is being done\n# $2 -- URL to which the push is being done\n#\n# If pushing without using a named remote those arguments will be equal.\n#\n# Information about the commits which are being pushed is supplied as lines to\n# the standard input in the form:\n#\n#   <local ref> <local oid> <remote ref> <remote oid>\n#\n# This sample shows how to prevent push of commits where the log message starts\n# with \"WIP\" (work in progress).\n\nremote=\"$1\"\nurl=\"$2\"\n\nzero=$(git hash-object --stdin </dev/null | tr '[0-9a-f]' '0')\n\nwhile read local_ref local_oid remote_ref remote_oid\ndo\n\tif test \"$local_oid\" = \"$zero\"\n\tthen\n\t\t# Handle delete\n\t\t:\n\telse\n\t\tif test \"$remote_oid\" = \"$zero\"\n\t\tthen\n\t\t\t# New branch, examine all commits\n\t\t\trange=\"$local_oid\"\n\t\telse\n\t\t\t# Update to existing branch, examine new commits\n\t\t\trange=\"$remote_oid..$local_oid\"\n\t\tfi\n\n\t\t# Check for WIP commit\n\t\tcommit=$(git rev-list -n 1 --grep '^WIP' \"$range\")\n\t\tif test -n \"$commit\"\n\t\tthen\n\t\t\techo >&2 \"Found WIP commit in $local_ref, not pushing\"\n\t\t\texit 1\n\t\tfi\n\tfi\ndone\n\nexit 0\n"
    },
    {
        "path": ".git/hooks/update.sample",
        "contents": "#!/bin/sh\n#\n# An example hook script to block unannotated tags from entering.\n# Called by \"git receive-pack\" with arguments: refname sha1-old sha1-new\n#\n# To enable this hook, rename this file to \"update\".\n#\n# Config\n# ------\n# hooks.allowunannotated\n#   This boolean sets whether unannotated tags will be allowed into the\n#   repository.  By default they won't be.\n# hooks.allowdeletetag\n#   This boolean sets whether deleting tags will be allowed in the\n#   repository.  By default they won't be.\n# hooks.allowmodifytag\n#   This boolean sets whether a tag may be modified after creation. By default\n#   it won't be.\n# hooks.allowdeletebranch\n#   This boolean sets whether deleting branches will be allowed in the\n#   repository.  By default they won't be.\n# hooks.denycreatebranch\n#   This boolean sets whether remotely creating branches will be denied\n#   in the repository.  By default this is allowed.\n#\n\n# --- Command line\nrefname=\"$1\"\noldrev=\"$2\"\nnewrev=\"$3\"\n\n# --- Safety check\nif [ -z \"$GIT_DIR\" ]; then\n\techo \"Don't run this script from the command line.\" >&2\n\techo \" (if you want, you could supply GIT_DIR then run\" >&2\n\techo \"  $0 <ref> <oldrev> <newrev>)\" >&2\n\texit 1\nfi\n\nif [ -z \"$refname\" -o -z \"$oldrev\" -o -z \"$newrev\" ]; then\n\techo \"usage: $0 <ref> <oldrev> <newrev>\" >&2\n\texit 1\nfi\n\n# --- Config\nallowunannotated=$(git config --type=bool hooks.allowunannotated)\nallowdeletebranch=$(git config --type=bool hooks.allowdeletebranch)\ndenycreatebranch=$(git config --type=bool hooks.denycreatebranch)\nallowdeletetag=$(git config --type=bool hooks.allowdeletetag)\nallowmodifytag=$(git config --type=bool hooks.allowmodifytag)\n\n# check for no description\nprojectdesc=$(sed -e '1q' \"$GIT_DIR/description\")\ncase \"$projectdesc\" in\n\"Unnamed repository\"* | \"\")\n\techo \"*** Project description file hasn't been set\" >&2\n\texit 1\n\t;;\nesac\n\n# --- Check types\n# if $newrev is 0000...0000, it's a commit to delete a ref.\nzero=$(git hash-object --stdin </dev/null | tr '[0-9a-f]' '0')\nif [ \"$newrev\" = \"$zero\" ]; then\n\tnewrev_type=delete\nelse\n\tnewrev_type=$(git cat-file -t $newrev)\nfi\n\ncase \"$refname\",\"$newrev_type\" in\n\trefs/tags/*,commit)\n\t\t# un-annotated tag\n\t\tshort_refname=${refname##refs/tags/}\n\t\tif [ \"$allowunannotated\" != \"true\" ]; then\n\t\t\techo \"*** The un-annotated tag, $short_refname, is not allowed in this repository\" >&2\n\t\t\techo \"*** Use 'git tag [ -a | -s ]' for tags you want to propagate.\" >&2\n\t\t\texit 1\n\t\tfi\n\t\t;;\n\trefs/tags/*,delete)\n\t\t# delete tag\n\t\tif [ \"$allowdeletetag\" != \"true\" ]; then\n\t\t\techo \"*** Deleting a tag is not allowed in this repository\" >&2\n\t\t\texit 1\n\t\tfi\n\t\t;;\n\trefs/tags/*,tag)\n\t\t# annotated tag\n\t\tif [ \"$allowmodifytag\" != \"true\" ] && git rev-parse $refname > /dev/null 2>&1\n\t\tthen\n\t\t\techo \"*** Tag '$refname' already exists.\" >&2\n\t\t\techo \"*** Modifying a tag is not allowed in this repository.\" >&2\n\t\t\texit 1\n\t\tfi\n\t\t;;\n\trefs/heads/*,commit)\n\t\t# branch\n\t\tif [ \"$oldrev\" = \"$zero\" -a \"$denycreatebranch\" = \"true\" ]; then\n\t\t\techo \"*** Creating a branch is not allowed in this repository\" >&2\n\t\t\texit 1\n\t\tfi\n\t\t;;\n\trefs/heads/*,delete)\n\t\t# delete branch\n\t\tif [ \"$allowdeletebranch\" != \"true\" ]; then\n\t\t\techo \"*** Deleting a branch is not allowed in this repository\" >&2\n\t\t\texit 1\n\t\tfi\n\t\t;;\n\trefs/remotes/*,commit)\n\t\t# tracking branch\n\t\t;;\n\trefs/remotes/*,delete)\n\t\t# delete tracking branch\n\t\tif [ \"$allowdeletebranch\" != \"true\" ]; then\n\t\t\techo \"*** Deleting a tracking branch is not allowed in this repository\" >&2\n\t\t\texit 1\n\t\tfi\n\t\t;;\n\t*)\n\t\t# Anything else (is there anything else?)\n\t\techo \"*** Update hook: unknown type of update to ref $refname of type $newrev_type\" >&2\n\t\texit 1\n\t\t;;\nesac\n\n# --- Finished\nexit 0\n"
    },
    {
        "path": ".git/hooks/push-to-checkout.sample",
        "contents": "#!/bin/sh\n\n# An example hook script to update a checked-out tree on a git push.\n#\n# This hook is invoked by git-receive-pack(1) when it reacts to git\n# push and updates reference(s) in its repository, and when the push\n# tries to update the branch that is currently checked out and the\n# receive.denyCurrentBranch configuration variable is set to\n# updateInstead.\n#\n# By default, such a push is refused if the working tree and the index\n# of the remote repository has any difference from the currently\n# checked out commit; when both the working tree and the index match\n# the current commit, they are updated to match the newly pushed tip\n# of the branch. This hook is to be used to override the default\n# behaviour; however the code below reimplements the default behaviour\n# as a starting point for convenient modification.\n#\n# The hook receives the commit with which the tip of the current\n# branch is going to be updated:\ncommit=$1\n\n# It can exit with a non-zero status to refuse the push (when it does\n# so, it must not modify the index or the working tree).\ndie () {\n\techo >&2 \"$*\"\n\texit 1\n}\n\n# Or it can make any necessary changes to the working tree and to the\n# index to bring them to the desired state when the tip of the current\n# branch is updated to the new commit, and exit with a zero status.\n#\n# For example, the hook can simply run git read-tree -u -m HEAD \"$1\"\n# in order to emulate git fetch that is run in the reverse direction\n# with git push, as the two-tree form of git read-tree -u -m is\n# essentially the same as git switch or git checkout that switches\n# branches while keeping the local changes in the working tree that do\n# not interfere with the difference between the branches.\n\n# The below is a more-or-less exact translation to shell of the C code\n# for the default behaviour for git's push-to-checkout hook defined in\n# the push_to_deploy() function in builtin/receive-pack.c.\n#\n# Note that the hook will be executed from the repository directory,\n# not from the working tree, so if you want to perform operations on\n# the working tree, you will have to adapt your code accordingly, e.g.\n# by adding \"cd ..\" or using relative paths.\n\nif ! git update-index -q --ignore-submodules --refresh\nthen\n\tdie \"Up-to-date check failed\"\nfi\n\nif ! git diff-files --quiet --ignore-submodules --\nthen\n\tdie \"Working directory has unstaged changes\"\nfi\n\n# This is a rough translation of:\n#\n#   head_has_history() ? \"HEAD\" : EMPTY_TREE_SHA1_HEX\nif git cat-file -e HEAD 2>/dev/null\nthen\n\thead=HEAD\nelse\n\thead=$(git hash-object -t tree --stdin </dev/null)\nfi\n\nif ! git diff-index --quiet --cached --ignore-submodules $head --\nthen\n\tdie \"Working directory has staged changes\"\nfi\n\nif ! git read-tree -u -m \"$commit\"\nthen\n\tdie \"Could not update working tree to new HEAD\"\nfi\n"
    },
    {
        "path": ".git/refs/heads/8.x-1.x",
        "contents": "ce0ed143597475351fa610514cc1d529b4019e5e\n"
    },
    {
        "path": ".git/refs/remotes/origin/HEAD",
        "contents": "ref: refs/remotes/origin/8.x-1.x\n"
    },
    {
        "path": "src/TokenServiceProvider.php",
        "contents": "<?php\n\nnamespace Drupal\\token;\n\nuse Drupal\\Core\\DependencyInjection\\ContainerBuilder;\nuse Drupal\\Core\\DependencyInjection\\ServiceProviderBase;\n\n/**\n * Replace core's token service with our own.\n */\nclass TokenServiceProvider extends ServiceProviderBase {\n\n  /**\n   * {@inheritdoc}\n   */\n  public function alter(ContainerBuilder $container) {\n    $definition = $container->getDefinition('token');\n    $definition->setClass('\\Drupal\\token\\Token');\n  }\n}\n"
    },
    {
        "path": "src/Token.php",
        "contents": "<?php\n\nnamespace Drupal\\token;\n\nuse Drupal\\Core\\Cache\\CacheBackendInterface;\nuse Drupal\\Core\\Language\\LanguageInterface;\nuse Drupal\\Core\\Utility\\Token as TokenBase;\n\n/**\n * Service to retrieve token information.\n *\n * This service replaces the core's token service and provides the same\n * functionality by extending it. It also provides additional functionality\n * commonly required by the additional support provided by token module and\n * other modules.\n */\nclass Token extends TokenBase implements TokenInterface {\n\n  /**\n   * Token definitions.\n   *\n   * @var array[]|null\n   *   An array of token definitions, or NULL when the definitions are not set.\n   *\n   * @see self::resetInfo()\n   */\n  protected $globalTokenTypes;\n\n  /**\n   * {@inheritdoc}\n   */\n  public function getInfo() {\n    if (empty($this->tokenInfo)) {\n      $cache_id = 'token_info_sorted:' . $this->languageManager->getCurrentLanguage(LanguageInterface::TYPE_CONTENT)->getId();\n      $cache = $this->cache->get($cache_id);\n      if ($cache) {\n        $this->tokenInfo = $cache->data;\n      }\n      else {\n        $token_info = $this->moduleHandler->invokeAll('token_info');\n        $this->moduleHandler->alter('token_info', $token_info);\n\n        foreach (array_keys($token_info['types']) as $type_key) {\n          if (isset($token_info['types'][$type_key]['type'])) {\n            $base_type = $token_info['types'][$type_key]['type'];\n            // If this token type extends another token type, then merge in\n            // the base token type's tokens.\n            if (isset($token_info['tokens'][$base_type])) {\n              $token_info['tokens'] += [$type_key => []];\n              $token_info['tokens'][$type_key] += $token_info['tokens'][$base_type];\n            }\n          }\n          else {\n            // Add a 'type' value to each token type information.\n            $token_info['types'][$type_key]['type'] = $type_key;\n          }\n        }\n\n        // Pre-sort tokens.\n        $by_name = $this->prepareMultisort($token_info['types']);\n        array_multisort($by_name, SORT_ASC, SORT_NATURAL | SORT_FLAG_CASE, $token_info['types']);\n        foreach (array_keys($token_info['tokens']) as $type) {\n          $by_name = $this->prepareMultisort($token_info['tokens'][$type]);\n          array_multisort($by_name, SORT_ASC, SORT_NATURAL | SORT_FLAG_CASE, $token_info['tokens'][$type]);\n        }\n\n        $this->tokenInfo = $token_info;\n        $this->cache->set($cache_id, $this->tokenInfo, CacheBackendInterface::CACHE_PERMANENT, [\n          static::TOKEN_INFO_CACHE_TAG,\n        ]);\n      }\n    }\n\n    return $this->tokenInfo;\n  }\n\n  /**\n   * Extracts data from the token data for use in array_multisort().\n   *\n   * @param array $token_info\n   *   List of tokens or token types, each element must have a name key.\n   *\n   * @return string[]\n   *   List of the names keyed by the token key.\n   */\n  protected function prepareMultisort($token_info) {\n    $by_name = [];\n    foreach ($token_info as $key => $token_info_element) {\n      // Check if the \"name\" key exists before accessing it.\n      $by_name[$key] = $token_info_element['name'] ?? NULL;\n    }\n    return $by_name;\n  }\n\n  /**\n   * {@inheritdoc}\n   */\n  public function getTokenInfo($token_type, $token) {\n    if (empty($this->tokenInfo)) {\n      $this->getInfo();\n    }\n\n    return isset($this->tokenInfo['tokens'][$token_type][$token]) ? $this->tokenInfo['tokens'][$token_type][$token] : NULL;\n  }\n\n  /**\n   * {@inheritdoc}\n   */\n  public function getTypeInfo($token_type) {\n    if (empty($this->tokenInfo)) {\n      $this->getInfo();\n    }\n\n    return isset($this->tokenInfo['types'][$token_type]) ? $this->tokenInfo['types'][$token_type] : NULL;\n  }\n\n  /**\n   * {@inheritdoc}\n   */\n  public function getGlobalTokenTypes() {\n    if (empty($this->globalTokenTypes)) {\n      $token_info = $this->getInfo();\n      foreach ($token_info['types'] as $type => $type_info) {\n        // If the token types has not specified that 'needs-data' => TRUE, then\n        // it is a global token type that will always be replaced in any context.\n        if (empty($type_info['needs-data'])) {\n          $this->globalTokenTypes[] = $type;\n        }\n      }\n    }\n\n    return $this->globalTokenTypes;\n  }\n\n  /**\n   * {@inheritdoc}\n   */\n  function getInvalidTokens($type, $tokens) {\n    $token_info = $this->getInfo();\n    $invalid_tokens = [];\n\n    foreach ($tokens as $token => $full_token) {\n      if (isset($token_info['tokens'][$type][$token])) {\n        continue;\n      }\n\n      // Split token up if it has chains.\n      $parts = explode(':', $token, 2);\n\n      if (!isset($token_info['tokens'][$type][$parts[0]])) {\n        // This is an invalid token (not defined).\n        $invalid_tokens[] = $full_token;\n      }\n      elseif (count($parts) == 2) {\n        $sub_token_info = $token_info['tokens'][$type][$parts[0]];\n        if (!empty($sub_token_info['dynamic'])) {\n          // If this token has been flagged as a dynamic token, skip it.\n          continue;\n        }\n        elseif (empty($sub_token_info['type'])) {\n          // If the token has chains, but does not support it, it is invalid.\n          $invalid_tokens[] = $full_token;\n        }\n        else {\n          // Recursively check the chained tokens.\n          $sub_tokens = $this->findWithPrefix([$token => $full_token], $parts[0]);\n          $invalid_tokens = array_merge($invalid_tokens, $this->getInvalidTokens($sub_token_info['type'], $sub_tokens));\n        }\n      }\n    }\n\n    return $invalid_tokens;\n  }\n\n  /**\n   * {@inheritdoc}\n   */\n  public function getInvalidTokensByContext($value, array $valid_types = []) {\n    if (in_array('all', $valid_types)) {\n      $info = $this->getInfo();\n      $valid_types = array_keys($info['types']);\n    }\n    else {\n      // Add the token types that are always valid in global context.\n      $valid_types = array_merge($valid_types, $this->getGlobalTokenTypes());\n    }\n\n    $invalid_tokens = [];\n    $value_tokens = is_string($value) ? $this->scan($value) : $value;\n\n    foreach ($value_tokens as $type => $tokens) {\n      if (!in_array($type, $valid_types)) {\n        // If the token type is not a valid context, its tokens are invalid.\n        $invalid_tokens = array_merge($invalid_tokens, array_values($tokens));\n      }\n      else {\n        // Check each individual token for validity.\n        $invalid_tokens = array_merge($invalid_tokens, $this->getInvalidTokens($type, $tokens));\n      }\n    }\n\n    array_unique($invalid_tokens);\n    return $invalid_tokens;\n  }\n\n  /**\n   * {@inheritdoc}\n   */\n  public function resetInfo() {\n    parent::resetInfo();\n    $this->globalTokenTypes = NULL;\n  }\n\n}\n"
    },
    {
        "path": "src/TokenEntityMapper.php",
        "contents": "<?php\n\nnamespace Drupal\\token;\n\nuse Drupal\\Core\\Entity\\EntityTypeManagerInterface;\nuse Drupal\\Core\\Extension\\ModuleHandlerInterface;\n\n/**\n * Service to provide mappings between entity and token types.\n *\n * Why do we need this? Because when the token API was moved to core we did not\n * reuse the entity type as the base name for taxonomy terms and vocabulary\n * tokens.\n */\nclass TokenEntityMapper implements TokenEntityMapperInterface {\n\n  /**\n   * @var \\Drupal\\Core\\Entity\\EntityTypeManagerInterface\n   */\n  protected $entityTypeManager;\n\n  /**\n   * @var \\Drupal\\Core\\Extension\\ModuleHandlerInterface\n   */\n  protected $moduleHandler;\n\n  /**\n   * @var array\n   */\n  protected $entityMappings;\n\n  public function __construct(EntityTypeManagerInterface $entity_type_manager, ModuleHandlerInterface $module_handler) {\n    $this->entityTypeManager = $entity_type_manager;\n    $this->moduleHandler = $module_handler;\n  }\n\n  /**\n   * {@inheritdoc}\n   */\n  public function getEntityTypeMappings() {\n    if (empty($this->entityMappings)) {\n      foreach ($this->entityTypeManager->getDefinitions() as $entity_type => $info) {\n        $this->entityMappings[$entity_type] = $info->get('token_type') ?: $entity_type;\n      }\n      // Allow modules to alter the mapping array.\n      $this->moduleHandler->alter('token_entity_mapping', $this->entityMappings);\n    }\n\n    return $this->entityMappings;\n  }\n\n  /**\n   * {@inheritdoc}\n   */\n  function getEntityTypeForTokenType($token_type, $fallback = FALSE) {\n    if (empty($this->entityMappings)) {\n      $this->getEntityTypeMappings();\n    }\n\n    $return = array_search($token_type, $this->entityMappings);\n    return $return !== FALSE ? $return : ($fallback ? $token_type : FALSE);\n  }\n\n  /**\n   * {@inheritdoc}\n   */\n  function getTokenTypeForEntityType($entity_type, $fallback = FALSE) {\n    if (empty($this->entityMappings)) {\n      $this->getEntityTypeMappings();\n    }\n\n    return isset($this->entityMappings[$entity_type]) ? $this->entityMappings[$entity_type] : ($fallback ? $entity_type : FALSE);\n  }\n\n  /**\n   * {@inheritdoc}\n   */\n  public function resetInfo() {\n    $this->entityMappings = NULL;\n  }\n\n}\n"
    },
    {
        "path": "src/TreeBuilderInterface.php",
        "contents": "<?php\n\nnamespace Drupal\\token;\n\ninterface TreeBuilderInterface {\n\n  /**\n   * The maximum depth for token tree recursion.\n   */\n  const MAX_DEPTH = 9;\n\n  /**\n   * Build a tree array of tokens used for themeing or information.\n   *\n   * @param string $token_type\n   *   The token type.\n   * @param array $options\n   *   (optional) An associative array of additional options, with the following\n   *   elements:\n   *   - 'flat' (defaults to FALSE): Set to true to generate a flat list of\n   *     token information. Otherwise, child tokens will be inside the\n   *     'children' parameter of a token.\n   *   - 'restricted' (defaults to FALSE): Set to true to how restricted tokens.\n   *   - 'depth' (defaults to 4): Maximum number of token levels to recurse.\n   *\n   * @return array\n   *   The token information constructed in a tree or flat list form depending\n   *   on $options['flat'].\n   */\n  public function buildTree($token_type, array $options = []);\n\n  /**\n   * Flatten a token tree.\n   *\n   * @param array $tree\n   *   The tree array as returned by TreeBuilderInterface::buildTree().\n   *\n   * @return array\n   *   The flattened version of the tree.\n   */\n  public function flattenTree(array $tree);\n\n  /**\n   * Build a render array with token tree built as per specified options.\n   *\n   * @param array $token_types\n   *   An array containing token types that should be shown in the tree.\n   * @param array $options\n   *   (optional) An associative array to control which tokens are shown and\n   *   how. The properties available are:\n   *   - 'global_types' (defaults to TRUE): Show all global token types along\n   *     with the specified types.\n   *   - 'click_insert' (defaults to TRUE): Include classes and caption to show\n   *     allow inserting tokens in fields by clicking on them.\n   *   - 'show_restricted' (defaults to FALSE): Show restricted tokens in the\n   *     tree.\n   *   - 'show_nested' (defaults to FALSE): If this token is nested and should\n   *     therefor not show on the token browser as a top level token.\n   *   - 'recursion_limit' (defaults to 3): Only show tokens up to the specified\n   *     depth.\n   *\n   * @return array\n   *   Render array for the token tree.\n   */\n  public function buildRenderable(array $token_types, array $options = []);\n\n  /**\n   * Build a render array with token tree containing all possible tokens.\n   *\n   * @param array $options\n   *   (optional) An associative array to control which tokens are shown and\n   *   how. The properties available are: See\n   *   \\Drupal\\token\\TreeBuilderInterface::buildRenderable() for details.\n   *\n   * @return array\n   *   Render array for the token tree.\n   */\n  public function buildAllRenderable(array $options = []);\n}\n"
    },
    {
        "path": "src/MenuLinkFieldItemList.php",
        "contents": "<?php\n\nnamespace Drupal\\token;\n\nuse Drupal\\Core\\Field\\EntityReferenceFieldItemList;\nuse Drupal\\Core\\TypedData\\ComputedItemListTrait;\n\n/**\n * Defines a menu link list class for storen menu link information.\n *\n * @see token_entity_base_field_info()\n */\nclass MenuLinkFieldItemList extends EntityReferenceFieldItemList {\n\n  use ComputedItemListTrait;\n\n  /**\n   * {@inheritdoc}\n   */\n  protected function computeValue() {\n    // This field does not really compute anything, it is used to store\n    // the referenced menu link.\n    return NULL;\n  }\n\n}\n"
    },
    {
        "path": "src/TokenFieldRender.php",
        "contents": "<?php\n\nnamespace Drupal\\token;\n\nuse Drupal\\Core\\Render\\Element;\nuse Drupal\\Core\\Security\\TrustedCallbackInterface;\n\nclass TokenFieldRender implements TrustedCallbackInterface {\n\n  /**\n   * {@inheritdoc}\n   */\n  public static function trustedCallbacks() {\n    return ['preRender'];\n  }\n\n  /**\n   * Pre-render callback for field output used with tokens.\n   */\n  public static function preRender($elements) {\n    // Remove the field theme hook, attachments, and JavaScript states.\n    unset($elements['#theme']);\n    unset($elements['#states']);\n    unset($elements['#attached']);\n\n    // Prevent multi-value fields from appearing smooshed together by appending\n    // a join suffix to all but the last value.\n    $deltas = Element::getVisibleChildren($elements);\n    $count = count($deltas);\n    if ($count > 1) {\n      $join = isset($elements['#token_options']['join']) ? $elements['#token_options']['join'] : \", \";\n      foreach ($deltas as $index => $delta) {\n        // Do not add a suffix to the last item.\n        if ($index < ($count - 1)) {\n          $elements[$delta] += ['#suffix' => $join];\n        }\n      }\n    }\n    return $elements;\n  }\n\n}\n"
    },
    {
        "path": "src/TreeBuilder.php",
        "contents": "<?php\n\nnamespace Drupal\\token;\n\nuse Drupal\\Core\\Cache\\Cache;\nuse Drupal\\Core\\Cache\\CacheBackendInterface;\nuse Drupal\\Core\\Language\\LanguageManagerInterface;\nuse Drupal\\Core\\Render\\BubbleableMetadata;\nuse Drupal\\Core\\StringTranslation\\StringTranslationTrait;\n\nclass TreeBuilder implements TreeBuilderInterface {\n\n  use StringTranslationTrait;\n\n  /**\n   * @var \\Drupal\\token\\Token\n   */\n  protected $tokenService;\n\n  /**\n   * @var \\Drupal\\token\\TokenEntityMapperInterface\n   */\n  protected $entityMapper;\n\n  /**\n   * @var \\Drupal\\Core\\Language\\LanguageManagerInterface\n   */\n  protected $languageManager;\n\n  /**\n   * @var \\Drupal\\Core\\Cache\\CacheBackendInterface\n   */\n  protected $cacheBackend;\n\n  /**\n   * Cache already built trees.\n   *\n   * @var array\n   */\n  protected $builtTrees;\n\n  public function __construct(TokenInterface $token_service, TokenEntityMapperInterface $entity_mapper, CacheBackendInterface $cache_backend, LanguageManagerInterface $language_manager) {\n    $this->tokenService = $token_service;\n    $this->entityMapper = $entity_mapper;\n    $this->cacheBackend = $cache_backend;\n    $this->languageManager = $language_manager;\n  }\n\n  /**\n   * {@inheritdoc}\n   */\n  public function buildRenderable(array $token_types, array $options = []) {\n    // Set default options.\n    $options += [\n      'global_types' => TRUE,\n      'click_insert' => TRUE,\n      'show_restricted' => FALSE,\n      'show_nested' => FALSE,\n      'recursion_limit' => 3,\n    ];\n\n    $info = $this->tokenService->getInfo();\n    if ($options['global_types']) {\n      $token_types = array_merge($token_types, $this->tokenService->getGlobalTokenTypes());\n    }\n\n    $element = [\n      /*'#cache' => [\n        'cid' => 'tree-rendered:' . hash('sha256', serialize(['token_types' => $token_types, 'global_types' => NULL] + $variables)),\n        'tags' => [Token::TOKEN_INFO_CACHE_TAG],\n      ],*/\n    ];\n\n    // @todo Find a way to use the render cache for this.\n    $tree_options = [\n      'flat' => TRUE,\n      'restricted' => $options['show_restricted'],\n      'nested' => $options['show_nested'],\n      'depth' => $options['recursion_limit'],\n    ];\n\n    $token_tree = [];\n    foreach ($info['types'] as $type => $type_info) {\n      if (!in_array($type, $token_types)) {\n        continue;\n      }\n\n      $token_tree[$type] = $type_info;\n      $token_tree[$type]['tokens'] = $this->buildTree($type, $tree_options);\n    }\n\n    $element += [\n      '#type' => 'token_tree_table',\n      '#token_tree' => $token_tree,\n      '#show_restricted' => $options['show_restricted'],\n      '#show_nested' => $options['show_nested'],\n      '#click_insert' => $options['click_insert'],\n      '#columns' => ['name', 'token', 'description'],\n      '#empty' => $this->t('No tokens available'),\n    ];\n\n    return $element;\n  }\n\n  /**\n   * {@inheritdoc}\n   */\n  public function buildAllRenderable(array $options = []) {\n    $info = $this->tokenService->getInfo();\n    $token_types = array_keys($info['types']);\n\n    // Disable merging in global types as we will be adding in all token types\n    // explicitly. There is no difference in leaving this set to TRUE except for\n    // an additional method call which is unnecessary.\n    $options['global_types'] = FALSE;\n    return $this->buildRenderable($token_types, $options);\n  }\n\n  /**\n   * {@inheritdoc}\n   */\n  public function buildTree($token_type, array $options = []) {\n    $options += [\n      'restricted' => FALSE,\n      'depth' => 4,\n      'data' => [],\n      'values' => FALSE,\n      'flat' => FALSE,\n    ];\n\n    // Do not allow past the maximum token information depth.\n    $options['depth'] = min($options['depth'], static::MAX_DEPTH);\n\n    // If $token_type is an entity, make sure we are using the actual token type.\n    if ($entity_token_type = $this->entityMapper->getTokenTypeForEntityType($token_type)) {\n      $token_type = $entity_token_type;\n    }\n\n    $langcode = $this->languageManager->getCurrentLanguage()->getId();\n    $tree_cid = \"token_tree:{$token_type}:{$langcode}:{$options['depth']}\";\n\n    // If we do not have this base tree in the static cache, check the cache\n    // otherwise generate and store it in the cache.\n    if (!isset($this->builtTrees[$tree_cid])) {\n      if ($cache = $this->cacheBackend->get($tree_cid)) {\n        $this->builtTrees[$tree_cid] = $cache->data;\n      }\n      else {\n        $options['parents'] = [];\n        $this->builtTrees[$tree_cid] = $this->getTokenData($token_type, $options);\n        $this->cacheBackend->set($tree_cid, $this->builtTrees[$tree_cid], Cache::PERMANENT, [Token::TOKEN_INFO_CACHE_TAG]);\n      }\n    }\n\n    $tree = $this->builtTrees[$tree_cid];\n\n    // If the user has requested a flat tree, convert it.\n    if (!empty($options['flat'])) {\n      $tree = $this->flattenTree($tree);\n    }\n\n    // Fill in token values.\n    if (!empty($options['values'])) {\n      $token_values = [];\n      foreach ($tree as $token => $token_info) {\n        if (!empty($token_info['dynamic']) || !empty($token_info['restricted'])) {\n          continue;\n        }\n        elseif (!isset($token_info['value'])) {\n          $token_values[$token_info['token']] = $token;\n        }\n      }\n      if (!empty($token_values)) {\n        $token_values = $this->tokenService->generate($token_type, $token_values, $options['data'], [], new BubbleableMetadata());\n        foreach ($token_values as $token => $replacement) {\n          $tree[$token]['value'] = $replacement;\n        }\n      }\n    }\n\n    return $tree;\n  }\n\n  /**\n   * {@inheritdoc}\n   */\n  public function flattenTree(array $tree) {\n    $result = [];\n    foreach ($tree as $token => $token_info) {\n      $result[$token] = $token_info;\n      if (isset($token_info['children']) && is_array($token_info['children'])) {\n        $result += $this->flattenTree($token_info['children']);\n      }\n    }\n    return $result;\n  }\n\n  /**\n   * Generate a token tree.\n   *\n   * @param string $token_type\n   *   The token type.\n   * @param array $options\n   *   An associative array of additional options. See documentation for\n   *   TreeBuilderInterface::buildTree() for more information.\n   *\n   * @return array\n   *   The token data for the specified $token_type.\n   *\n   * @internal\n   */\n  protected function getTokenData($token_type, array $options) {\n    $options += [\n      'parents' => [],\n    ];\n\n    $info = $this->tokenService->getInfo();\n    if ($options['depth'] <= 0 || !isset($info['types'][$token_type]) || !isset($info['tokens'][$token_type])) {\n      return [];\n    }\n\n    $tree = [];\n    foreach ($info['tokens'][$token_type] as $token => $token_info) {\n      // Build the raw token string.\n      $token_parents = $options['parents'];\n      if (empty($token_parents)) {\n        // If the parents array is currently empty, assume the token type is its\n        // parent.\n        $token_parents[] = $token_type;\n      }\n      // The 'entity' token will be repeated on nested entity reference fields.\n      elseif ($token !== 'entity' && in_array($token, array_slice($token_parents, 1), TRUE)) {\n        // Prevent duplicate recursive tokens. For example, this will prevent\n        // the tree from generating the following tokens or deeper:\n        // [comment:parent:parent]\n        // [comment:parent:root:parent]\n        continue;\n      }\n\n      $token_parents[] = $token;\n      if (!empty($token_info['dynamic'])) {\n        $token_parents[] = '?';\n      }\n      $raw_token = '[' . implode(':', $token_parents) . ']';\n      $tree[$raw_token] = $token_info;\n      $tree[$raw_token]['raw token'] = $raw_token;\n\n      // Add the token's real name (leave out the base token type).\n      $tree[$raw_token]['token'] = implode(':', array_slice($token_parents, 1));\n\n      // Add the token's parent as its raw token value.\n      if (!empty($options['parents'])) {\n        $tree[$raw_token]['parent'] = '[' . implode(':', $options['parents']) . ']';\n      }\n\n      // Fetch the child tokens.\n      if (!empty($token_info['type'])) {\n        $child_options = $options;\n        $child_options['depth']--;\n        $child_options['parents'] = $token_parents;\n        $tree[$raw_token]['children'] = $this->getTokenData($token_info['type'], $child_options);\n      }\n    }\n\n    return $tree;\n  }\n}\n"
    },
    {
        "path": "src/TokenEntityMapperInterface.php",
        "contents": "<?php\n\nnamespace Drupal\\token;\n\ninterface TokenEntityMapperInterface {\n\n  /**\n   * Return an array of entity type to token type mappings.\n   *\n   * @return array\n   *   An array of mappings with entity type mapping to token type.\n   */\n  public function getEntityTypeMappings();\n\n  /**\n   * Return the entity type of a particular token type.\n   *\n   * @param string $token_type\n   *   The token type for which the mapping is returned.\n   * @param bool $fallback\n   *   (optional) Defaults to FALSE. If true, the same $value is returned in\n   *   case the mapping was not found.\n   *\n   * @return string\n   *   The entity type of the token type specified.\n   *\n   * @see token_entity_info_alter()\n   * @see http://drupal.org/node/737726\n   */\n  function getEntityTypeForTokenType($token_type, $fallback = FALSE);\n\n  /**\n   * Return the token type of a particular entity type.\n   *\n   * @param string $entity_type\n   *   The entity type for which the mapping is returned.\n   * @param bool $fallback\n   *   (optional) Defaults to FALSE. If true, the same $value is returned in\n   *   case the mapping was not found.\n   *\n   * @return string\n   *   The token type of the entity type specified.\n   *\n   * @see token_entity_info_alter()\n   * @see http://drupal.org/node/737726\n   */\n  function getTokenTypeForEntityType($entity_type, $fallback = FALSE);\n\n  /**\n   * Resets metadata describing token and entity mappings.\n   */\n  public function resetInfo();\n}\n"
    },
    {
        "path": "src/TokenInterface.php",
        "contents": "<?php\n\nnamespace Drupal\\token;\n\ninterface TokenInterface {\n\n  /**\n   * Returns metadata describing supported token types.\n   *\n   * @param $token_type\n   *   The token type for which the metadata is required.\n   *\n   * @return array[]\n   *   An array of token type information from hook_token_info() for the\n   *   specified token type.\n   *\n   * @see hook_token_info()\n   * @see hook_token_info_alter()\n   */\n  public function getTypeInfo($token_type);\n\n  /**\n   * Returns metadata describing supported a token.\n   *\n   * @param $token_type\n   *   The token type for which the metadata is required.\n   * @param $token\n   *   The token name for which the metadata is required.\n   *\n   * @return array[]\n   *   An array of information from hook_token_info() for the specified token.\n   *\n   * @see hook_token_info()\n   * @see hook_token_info_alter()\n   */\n  public function getTokenInfo($token_type, $token);\n\n  /**\n   * Get a list of token types that can be used without any context (global).\n   *\n   * @return array[]\n   *   An array of global token types.\n   */\n  public function getGlobalTokenTypes();\n\n  /**\n   * Validate an array of tokens based on their token type.\n   *\n   * @param string $type\n   *   The type of tokens to validate (e.g. 'node', etc.)\n   * @param string[] $tokens\n   *   A keyed array of tokens, and their original raw form in the source text.\n   *\n   * @return string[]\n   *   An array with the invalid tokens in their original raw forms.\n   */\n  function getInvalidTokens($type, $tokens);\n\n  /**\n   * Validate tokens in raw text based on possible contexts.\n   *\n   * @param string|string[] $value\n   *   A string with the raw text containing the raw tokens, or an array of\n   *   tokens from token_scan().\n   * @param string[] $valid_types\n   *   An array of token types that will be used when token replacement is\n   *   performed.\n   *\n   * @return string[]\n   *   An array with the invalid tokens in their original raw forms.\n   */\n  public function getInvalidTokensByContext($value, array $valid_types = []);\n}\n"
    },
    {
        "path": "src/TokenModuleProvider.php",
        "contents": "<?php\n\nnamespace Drupal\\token;\n\nuse Drupal\\Core\\Cache\\CacheBackendInterface;\nuse Drupal\\Core\\Cache\\CacheCollector;\nuse Drupal\\Core\\Lock\\LockBackendInterface;\n\n/**\n * Token module provider.\n */\nclass TokenModuleProvider extends CacheCollector {\n\n  /**\n   * Separator for the cache key.\n   *\n   * @internal\n   */\n  const SEPARATOR = '::';\n\n  /**\n   * The token service.\n   *\n   * @var \\Drupal\\token\\TokenInterface\n   */\n  protected TokenInterface $token;\n\n  /**\n   * {@inheritdoc}\n   */\n  public function __construct(CacheBackendInterface $cache, LockBackendInterface $lock, TokenInterface $token) {\n    parent::__construct('token_module', $cache, $lock, [Token::TOKEN_INFO_CACHE_TAG]);\n    $this->token = $token;\n  }\n\n  /**\n   * Return the module responsible for a token.\n   *\n   * @param string $type\n   *   The token type.\n   * @param string $name\n   *   The token name.\n   *\n   * @return string|null\n   *   The value of $info['tokens'][$type][$name]['module'] from token info, or\n   *   NULL if the value does not exist.\n   */\n  public function getTokenModule(string $type, string $name): ?string {\n    return $this->get($type . static::SEPARATOR . $name);\n  }\n\n  /**\n   * {@inheritdoc}\n   */\n  protected function resolveCacheMiss($key) {\n    [$type, $name] = explode(static::SEPARATOR, $key, 2);\n    $token_info = $this->token->getTokenInfo($type, $name);\n    $this->storage[$key] = $token_info['module'] ?? NULL;\n    $this->persist($key);\n    return $this->storage[$key];\n  }\n\n}\n"
    },
    {
        "path": "src/Plugin/Derivative/DevelLocalTask.php",
        "contents": "<?php\n\nnamespace Drupal\\token\\Plugin\\Derivative;\n\nuse Drupal\\Component\\Plugin\\Derivative\\DeriverBase;\nuse Drupal\\Core\\Entity\\EntityTypeManagerInterface;\nuse Drupal\\Core\\Plugin\\Discovery\\ContainerDeriverInterface;\nuse Drupal\\Core\\StringTranslation\\StringTranslationTrait;\nuse Drupal\\Core\\StringTranslation\\TranslationInterface;\nuse Symfony\\Component\\DependencyInjection\\ContainerInterface;\n\nclass DevelLocalTask extends DeriverBase implements ContainerDeriverInterface {\n\n  use StringTranslationTrait;\n\n  protected $entityTypeManager;\n\n  public function __construct(EntityTypeManagerInterface $entity_type_manager, TranslationInterface $string_translation) {\n    $this->entityTypeManager = $entity_type_manager;\n    $this->stringTranslation = $string_translation;\n  }\n\n  /**\n   * {@inheritdoc}\n   */\n  public static function create(ContainerInterface $container, $base_plugin_id) {\n    return new static(\n      $container->get('entity_type.manager'),\n      $container->get('string_translation')\n    );\n  }\n\n  /**\n   * {@inheritdoc}\n   */\n  public function getDerivativeDefinitions($base_plugin_definition) {\n    $this->derivatives = [];\n\n    foreach ($this->entityTypeManager->getDefinitions() as $entity_type_id => $entity_type) {\n      if ($entity_type->hasLinkTemplate('token-devel')) {\n        $this->derivatives[\"$entity_type_id.token_devel_tab\"] = [\n          'route_name' => \"entity.$entity_type_id.token_devel\",\n          'weight' => 110,\n          'title' => $this->t('Tokens'),\n          'parent_id' => \"devel.entities:$entity_type_id.devel_tab\",\n        ];\n      }\n    }\n\n    foreach ($this->derivatives as &$entry) {\n      $entry += $base_plugin_definition;\n    }\n\n    return $this->derivatives;\n  }\n}\n"
    },
    {
        "path": "src/Element/TokenTreeTable.php",
        "contents": "<?php\n\nnamespace Drupal\\token\\Element;\n\nuse Drupal\\Component\\Utility\\Html;\nuse Drupal\\Core\\Render\\Element\\Table;\n\n/**\n * Provides a render element for a token tree table.\n *\n * @RenderElement(\"token_tree_table\")\n */\nclass TokenTreeTable extends Table {\n\n  protected static $cssFilter = [' ' => '-', '_' => '-', '/' => '-', '[' => '-', ']' => '', ':' => '--', '?' => '', '<' => '-', '>' => '-'];\n\n  /**\n   * {@inheritdoc}\n   */\n  public function getInfo() {\n    $class = get_class($this);\n    return [\n      '#header' => [],\n      '#rows' => [],\n      '#token_tree' => [],\n      '#columns' => ['name', 'token', 'description'],\n      '#empty' => '',\n      '#show_restricted' => FALSE,\n      '#show_nested' => FALSE,\n      '#skip_empty_values' => FALSE,\n      '#click_insert' => TRUE,\n      '#sticky' => FALSE,\n      '#responsive' => TRUE,\n      '#input' => FALSE,\n      '#pre_render' => [\n        [$class, 'preRenderTokenTree'],\n        [$class, 'preRenderTable'],\n      ],\n      '#theme' => 'table__token_tree',\n      '#attached' => [\n        'library' => [\n          'token/token',\n        ],\n      ],\n    ];\n  }\n\n  /**\n   * Pre-render the token tree to transform rows in the token tree.\n   *\n   * @param array $element\n   *\n   * @return array\n   *   The processed element.\n   */\n  public static function preRenderTokenTree($element) {\n    $multiple_token_types = count($element['#token_tree']) > 1;\n    foreach ($element['#token_tree'] as $token_type => $type_info) {\n      // Do not show nested tokens.\n      if (!empty($type_info['nested']) && empty($element['#show_nested'])) {\n        continue;\n      }\n\n      if ($multiple_token_types) {\n        $row = static::formatRow($token_type, $type_info, $element['#columns'], TRUE);\n        $element['#rows'][] = $row;\n      }\n\n      foreach ($type_info['tokens'] as $token => $token_info) {\n        if (!empty($token_info['restricted']) && empty($element['#show_restricted'])) {\n          continue;\n        }\n        if ($element['#skip_empty_values'] && empty($token_info['value']) && !empty($token_info['parent']) && !isset($tree[$token_info['parent']]['value'])) {\n          continue;\n        }\n        if ($multiple_token_types && !isset($token_info['parent'])) {\n          $token_info['parent'] = $token_type;\n        }\n        $row = static::formatRow($token, $token_info, $element['#columns']);\n        $element['#rows'][] = $row;\n      }\n    }\n\n    // Fill headers if one is not specified.\n    if (empty($element['#header'])) {\n      $column_map = [\n        'name' => t('Name'),\n        'token' => t('Token'),\n        'value' => t('Value'),\n        'description' => t('Description'),\n      ];\n      foreach ($element['#columns'] as $col) {\n        $element['#header'][] = $column_map[$col];\n      }\n    }\n\n    $element['#attributes']['class'][] = 'token-tree';\n\n    if ($element['#click_insert']) {\n      $element['#caption'] = t('Click a token to insert it into the field you\\'ve last clicked.');\n      $element['#attributes']['class'][] = 'token-click-insert';\n    }\n\n    return $element;\n  }\n\n  protected static function cleanCssIdentifier($id) {\n    return 'token-' . Html::cleanCssIdentifier(trim($id, '[]'), static::$cssFilter);\n  }\n\n  protected static function formatRow($token, $token_info, $columns, $is_group = FALSE) {\n    $row = [\n      'id' => static::cleanCssIdentifier($token),\n      'data-tt-id' => static::cleanCssIdentifier($token),\n      'class' => [],\n      'data' => [],\n    ];\n\n    foreach ($columns as $col) {\n      switch ($col) {\n        case 'name':\n          $row['data'][$col] = $token_info['name'];\n          break;\n\n        case 'token':\n          $row['data'][$col]['data'] = $token;\n          $row['data'][$col]['class'][] = 'token-key';\n          break;\n\n        case 'description':\n          $row['data'][$col] = isset($token_info['description']) ? $token_info['description'] : '';\n          break;\n\n        case 'value':\n          $row['data'][$col] = !$is_group && isset($token_info['value']) ? $token_info['value'] : '';\n          break;\n      }\n    }\n\n    if ($is_group) {\n      // This is a token type/group.\n      $row['class'][] = 'token-group';\n    }\n    elseif (!empty($token_info['parent'])) {\n      $row['data-tt-parent-id'] = static::cleanCssIdentifier($token_info['parent']);\n    }\n\n    return $row;\n  }\n}\n"
    },
    {
        "path": "src/Controller/TokenTreeController.php",
        "contents": "<?php\n\nnamespace Drupal\\token\\Controller;\n\nuse Drupal\\Component\\Serialization\\Json;\nuse Drupal\\Core\\Controller\\ControllerBase;\nuse Drupal\\token\\TreeBuilderInterface;\nuse Symfony\\Component\\DependencyInjection\\ContainerInterface;\nuse Symfony\\Component\\HttpFoundation\\Request;\n\n/**\n * Returns tree responses for tokens.\n */\nclass TokenTreeController extends ControllerBase {\n\n  /**\n   * @var \\Drupal\\token\\TreeBuilderInterface\n   */\n  protected $treeBuilder;\n\n  public function __construct(TreeBuilderInterface $tree_builder) {\n    $this->treeBuilder = $tree_builder;\n  }\n\n  /**\n   * {@inheritdoc}\n   */\n  public static function create(ContainerInterface $container) {\n    return new static(\n      $container->get('token.tree_builder')\n    );\n  }\n\n  /**\n   * Page callback to output a token tree as an empty page.\n   */\n  function outputTree(Request $request) {\n    $options = $request->query->has('options') ? Json::decode($request->query->get('options')) : [];\n\n    // The option token_types may only be an array OR 'all'. If it is not set,\n    // we assume that only global token types are requested.\n    $token_types = !empty($options['token_types']) ? $options['token_types'] : [];\n    if ($token_types == 'all') {\n      $build = $this->treeBuilder->buildAllRenderable($options);\n    }\n    else {\n      $build = $this->treeBuilder->buildRenderable($token_types, $options);\n    }\n\n    $build['#cache']['contexts'][] = 'url.query_args:options';\n    $build['#title'] = $this->t('Available tokens');\n\n    // If this is an AJAX/modal request, add a wrapping div to the contents so\n    // that Drupal.behaviors.tokenTree and Drupal.behaviors.tokenAttach can\n    // stil find the elements they need to.\n    // @see https://www.drupal.org/project/token/issues/2994671\n    // @see https://www.drupal.org/node/2940704\n    // @see http://danielnouri.org/notes/2011/03/14/a-jquery-find-that-also-finds-the-root-element/\n    if ($request->isXmlHttpRequest()) {\n      $build['#prefix'] = '<div>';\n      $build['#suffix'] = '</div>';\n    }\n\n    return $build;\n  }\n\n}\n"
    },
    {
        "path": "src/Controller/TokenCacheController.php",
        "contents": "<?php\n\nnamespace Drupal\\token\\Controller;\n\nuse Drupal\\Core\\Controller\\ControllerBase;\n\n/**\n * Clears cache for tokens.\n */\nclass TokenCacheController extends ControllerBase {\n\n  /**\n   * Clear caches and redirect back to the frontpage.\n   */\n  public function flush() {\n    token_clear_cache();\n    $this->messenger()->addMessage($this->t('Token registry caches cleared.'));\n    return $this->redirect('<front>');\n  }\n\n}\n"
    },
    {
        "path": "src/Controller/TokenDevelController.php",
        "contents": "<?php\n\nnamespace Drupal\\token\\Controller;\n\nuse Drupal\\Core\\Controller\\ControllerBase;\nuse Drupal\\Core\\Entity\\EntityInterface;\nuse Drupal\\Core\\Routing\\RouteMatchInterface;\nuse Drupal\\token\\TokenEntityMapperInterface;\nuse Drupal\\token\\TreeBuilderInterface;\nuse Symfony\\Component\\DependencyInjection\\ContainerInterface;\n\n/**\n * Devel integration for tokens.\n */\nclass TokenDevelController extends ControllerBase {\n\n  /**\n   * @var \\Drupal\\token\\TreeBuilderInterface\n   */\n  protected $treeBuilder;\n\n  /**\n   * @var \\Drupal\\token\\TokenEntityMapperInterface\n   */\n  protected $entityMapper;\n\n  public function __construct(TreeBuilderInterface $tree_builder, TokenEntityMapperInterface $entity_mapper) {\n    $this->treeBuilder = $tree_builder;\n    $this->entityMapper = $entity_mapper;\n  }\n\n  /**\n   * {@inheritdoc}\n   */\n  public static function create(ContainerInterface $container) {\n    return new static(\n      $container->get('token.tree_builder'),\n      $container->get('token.entity_mapper')\n    );\n  }\n\n  /**\n   * Prints the loaded structure of the current entity.\n   *\n   * @param \\Drupal\\Core\\Routing\\RouteMatchInterface $route_match\n   *    A RouteMatch object.\n   *\n   * @return array\n   *    Array of page elements to render.\n   */\n  public function entityTokens(RouteMatchInterface $route_match) {\n    $output = [];\n\n    $parameter_name = $route_match->getRouteObject()->getOption('_token_entity_type_id');\n    $entity = $route_match->getParameter($parameter_name);\n\n    if ($entity && $entity instanceof EntityInterface) {\n      $output = $this->renderTokenTree($entity);\n    }\n\n    return $output;\n  }\n\n  /**\n   * Render the token tree for the specified entity.\n   *\n   * @param \\Drupal\\Core\\Entity\\EntityInterface $entity\n   *   The entity for which the token tree should be rendered.\n   *\n   * @return array\n   *   Render array of the token tree for the $entity.\n   *\n   * @see static::entityLoad\n   */\n  protected function renderTokenTree(EntityInterface $entity) {\n    $this->moduleHandler()->loadInclude('token', 'pages.inc');\n    $entity_type = $entity->getEntityTypeId();\n\n    $token_type = $this->entityMapper->getTokenTypeForEntityType($entity_type);\n    $options = [\n      'flat' => TRUE,\n      'values' => TRUE,\n      'data' => [$token_type => $entity],\n    ];\n\n    $token_tree = [\n      $token_type => [\n        'tokens' => $this->treeBuilder->buildTree($token_type, $options),\n      ],\n    ];\n//    foreach ($tree as $token => $token_info) {\n//      if (!isset($token_info['value']) && !empty($token_info['parent']) && !isset($tree[$token_info['parent']]['value'])) {\n//        continue;\n//      }\n//    }\n\n    $build['tokens'] = [\n      '#type' => 'token_tree_table',\n      '#show_restricted' => FALSE,\n      '#show_nested' => FALSE,\n      '#skip_empty_values' => TRUE,\n      '#token_tree' => $token_tree,\n      '#columns' => ['token', 'value'],\n      '#empty' => $this->t('No tokens available.'),\n    ];\n\n    return $build;\n  }\n}\n"
    },
    {
        "path": "src/Routing/RouteSubscriber.php",
        "contents": "<?php\n\nnamespace Drupal\\token\\Routing;\n\nuse Drupal\\Core\\Entity\\EntityTypeManagerInterface;\nuse Drupal\\Core\\Extension\\ModuleHandlerInterface;\nuse Drupal\\Core\\Routing\\RouteSubscriberBase;\nuse Drupal\\Core\\Routing\\RoutingEvents;\nuse Symfony\\Component\\Routing\\Route;\nuse Symfony\\Component\\Routing\\RouteCollection;\n\n/**\n * Subscriber for Devel routes.\n */\nclass RouteSubscriber extends RouteSubscriberBase {\n\n  /**\n   * @var \\Drupal\\Core\\Entity\\EntityTypeManagerInterface\n   */\n  protected $entityTypeManager;\n\n  /**\n   * @var \\Drupal\\Core\\Extension\\ModuleHandlerInterface\n   */\n  protected $moduleHandler;\n\n  public function __construct(EntityTypeManagerInterface $entity_type_manager, ModuleHandlerInterface $module_handler) {\n    $this->entityTypeManager = $entity_type_manager;\n    $this->moduleHandler = $module_handler;\n  }\n\n  /**\n   * {@inheritdoc}\n   */\n  protected function alterRoutes(RouteCollection $collection) {\n    foreach ($this->entityTypeManager->getDefinitions() as $entity_type_id => $entity_type) {\n      if ($devel_render = $entity_type->getLinkTemplate('token-devel')) {\n        $options = [\n          '_admin_route' => TRUE,\n          '_token_entity_type_id' => $entity_type_id,\n          'parameters' => [\n            $entity_type_id => [\n              'type' => 'entity:' . $entity_type_id,\n            ],\n          ],\n        ];\n\n        $route = new Route(\n          $devel_render,\n          [\n            '_controller' => '\\Drupal\\token\\Controller\\TokenDevelController::entityTokens',\n            '_title' => 'Devel Tokens',\n          ],\n          [\n            '_permission' => 'access devel information',\n            '_module_dependencies' => 'devel',\n          ],\n          $options\n        );\n\n        $collection->add(\"entity.$entity_type_id.token_devel\", $route);\n      }\n    }\n  }\n\n  /**\n   * {@inheritdoc}\n   */\n  public static function getSubscribedEvents(): array {\n    $events = parent::getSubscribedEvents();\n    $events[RoutingEvents::ALTER] = array('onAlterRoutes', 100);\n    return $events;\n  }\n\n}\n"
    },
    {
        "path": "src/Drush/Commands/TokenCommands.php",
        "contents": "<?php\n\nnamespace Drupal\\token\\Drush\\Commands;\n\nuse Drupal\\Component\\DependencyInjection\\ContainerInterface;\nuse Drupal\\Core\\Extension\\ModuleHandlerInterface;\nuse Drush\\Commands\\DrushCommands;\n\n/**\n * TokenCommands provides the Drush hook implementation for cache clears.\n */\nclass TokenCommands extends DrushCommands {\n\n  /**\n   * The module_handler service.\n   *\n   * @var \\Drupal\\Core\\Extension\\ModuleHandlerInterface\n   */\n  protected $moduleHandler;\n\n  /**\n   * TokenCommands constructor.\n   *\n   * @param \\Drupal\\Core\\Extension\\ModuleHandlerInterface $moduleHandler\n   *   The module_handler service.\n   */\n  public function __construct(ModuleHandlerInterface $moduleHandler) {\n    $this->moduleHandler = $moduleHandler;\n  }\n\n  /**\n   * {@inheritdoc}\n   */\n  public static function create(ContainerInterface $container): self {\n    return new static(\n      $container->get('module_handler')\n    );\n  }\n\n  /**\n   * Adds a cache clear option for tokens.\n   *\n   * @param array $types\n   *   The Drush clear types to make available.\n   * @param bool $includeBootstrappedTypes\n   *   Whether to include types only available in a bootstrapped Drupal or not.\n   *\n   * @hook on-event cache-clear\n   */\n  public function cacheClear(array &$types, $includeBootstrappedTypes) {\n    if (!$includeBootstrappedTypes || !$this->moduleHandler->moduleExists('token')) {\n      return;\n    }\n\n    $types['token'] = 'token_clear_cache';\n  }\n\n}\n"
    }
]
